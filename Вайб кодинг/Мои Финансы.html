<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мои Финансы</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Встроенные стили -->
    <style>
        :root {
            /* Основные цвета из вашего градиента */
            --primary: #4AA54E;
            /* Зеленый из градиента */
            --primary-dark: #166088;
            /* Синий из градиента */
            --accent: #FFE033;
            /* Желтый из фона */

            /* Новая гармоничная палитра */
            --success: #4AA54E;
            /* Зеленый */
            --success-light: #6BBF6F;
            --info: #166088;
            /* Синий */
            --info-light: #1D7BA9;
            --warning: #FFB74D;
            /* Оранжевый вместо желтого */
            --warning-light: #FFE033AA;
            /* Полупрозрачный желтый */
            --danger: #FF7043;
            /* Красный */
            --danger-light: #FF8A65;

            /* Нейтральные цвета */
            --light-bg: rgb(255, 224, 51, 0.68);
            /* Слегка желтый фон */
            --card-bg: rgba(255, 253, 240, 0.95);
            /* Мягкий кремово-желтый */
            --card-gradient: linear-gradient(135deg, rgb(243, 236, 141), rgb(253, 247, 221));
            --card-border: 5px solid rgba(74, 165, 78, 0.2);
            /* Зеленый ободок */
            --text-primary: #2C3E50;
            --text-secondary: #546E7A;
            --border-color: #E0E0E0;
            --shadow: 0 5px 15px rgba(74, 165, 78, 0.08);
            --shadow-hover: 0 10px 25px rgba(74, 165, 78, 0.15);

            /* Скругления */
            --border-radius-lg: 20px;
            /* Большие скругления */
            --border-radius-md: 12px;
            --border-radius-sm: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }


        body {
            background-color: #f5f5f5;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }


        /* Шапка - ОБНОВЛЕНО */
        .app-header {
            background: linear-gradient(135deg, var(--success), var(--info));
            color: white;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 20px rgba(22, 96, 136, 0.2);
        }

        .app-header h1 {
            margin-bottom: 1rem;
            font-size: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .main-nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 1rem;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            padding: 0.6rem 1.5rem;
            border-radius: var(--border-radius-lg);
            background-color: rgba(255, 255, 255, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 12px;
        }

        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .nav-link.active {
            background-color: white;
            color: var(--info);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .app-main {
            flex: 1;
            padding: 2rem;
            background: rgb(255, 224, 51, 0.68);
            /* Прямое значение */
            /* или background: var(--light-bg); если обновили переменную */
            min-height: calc(100vh - 200px);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        /* Футер */
        .app-footer {
            background: linear-gradient(135deg, #1A3C40, #2C3E50);
            color: white;
            padding: 1.5rem;
            text-align: center;
            font-size: 1.1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin-top: 2rem;
        }

        .total-balance {
            font-size: 1.3rem;
            font-weight: 600;
        }


        #total-balance {
            color: var(--accent);
            font-size: 1.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Стили для главной страницы - ОБНОВЛЕНО */
        .main-page-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 1rem;
        }

        .add-transaction-card,
        .recent-transactions {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .add-transaction-card::before,
        .recent-transactions::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--success), var(--success-light));
            border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
        }

        .add-transaction-card:hover,
        .recent-transactions:hover {
            box-shadow: 0 8px 25px rgba(74, 165, 78, 0.15);
            border-color: rgba(74, 165, 78, 0.4);
        }

        .add-transaction-card h3,
        .recent-transactions h3 {
            margin-bottom: 1.2rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 1.2rem;
        }



        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-control {
            width: 100%;
            padding: 0.9rem 1.2rem;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            transition: all 0.3s;
            background: #FFFFFF;
            border-radius: 12px;
        }


        .form-control:focus {
            outline: none;
            border-color: var(--info);
            box-shadow: 0 0 0 3px rgba(22, 96, 136, 0.1);
        }

        .btn {
            padding: 0.8rem 1.8rem;
            border: none;
            border-radius: var(--border-radius-lg);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--success), var(--success-light));
            color: white;
            box-shadow: 0 4px 15px rgba(74, 165, 78, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--success-light), var(--success));
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 165, 78, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--info), var(--info-light));
            color: white;
            box-shadow: 0 4px 15px rgba(22, 96, 136, 0.3);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, var(--info-light), var(--info));
            transform: translateY(-2px);
        }

        /* Список транзакций */
        .transaction-item {
            background-color: #f8f9fa;
            border-radius: var(--border-radius-sm);
            padding: 1rem;
            margin-bottom: 0.8rem;
            border-left: 4px solid var(--border-color);
            transition: all 0.3s ease;
            border-radius: 12px;
        }

        .transaction-item:hover {
            transform: translateX(5px);
        }

        .transaction-item.income {
            border-left-color: var(--success);
        }

        .transaction-item.expense {
            border-left-color: var(--danger);
        }

        .transaction-item.transfer {
            border-left-color: var(--info);
        }

        .transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .transaction-category {
            font-weight: 600;
            color: var(--text-primary);
        }

        .transaction-amount {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .transaction-amount.income {
            color: var(--success);
        }

        .transaction-amount.expense {
            color: var(--danger);
        }

        .transaction-amount.transfer {
            color: var(--info);
        }

        .transaction-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }


        .transaction-account,
        .transaction-date,
        .transaction-comment {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .main-page-container {
                grid-template-columns: 1fr;
            }

            .main-nav {
                flex-direction: column;
                align-items: center;
            }

            .nav-link {
                width: 100%;
                max-width: 300px;
                justify-content: center;
            }

            .app-main {
                flex: 1;
                padding: 2rem;
                background: linear-gradient(135deg,
                        rgba(255, 253, 245, 0.9),
                        rgba(255, 251, 235, 0.9));
                min-height: calc(100vh - 200px);
                backdrop-filter: blur(10px);
            }
        }

        .text-muted {
            color: #95a5a6;
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        /* Стили для страницы счетов */
        .accounts-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .add-account-form {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .form-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .accounts-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .account-item {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }

        .account-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--success), var(--success-light));
            border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
        }


        .account-item:hover {
            box-shadow: 0 8px 25px rgba(74, 165, 78, 0.15);
            border-color: rgba(74, 165, 78, 0.4);
        }

        .account-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .account-name {
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .account-balance {
            font-size: 1.2rem;
            font-weight: bold;
            color: #27ae60;
        }

        .account-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-icon {
            background: none;
            border: none;
            color: #7f8c8d;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .btn-icon:hover {
            background-color: #e0e0e0;
            color: #333;
        }

        /* Стили для страницы категорий */
        .categories-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .category-forms {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .add-category-form {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .categories-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }


        .category-item {
            --category-bg: rgba(74, 165, 78, 0.1);
            --category-color: var(--success);
            margin-bottom: 1rem;
            width: 100%;
            max-width: 100%;
            border-radius: 12px;
        }

        .category-item.main-category {
            border-left: 4px solid #3498db;
        }

        .category-item.subcategory {
            border-left: 4px solid #2ecc71;
            margin-left: 2rem;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        /* Область категории (овальная карточка) */
        .category-badge {
            display: flex;
            align-items: center;
            background-color: var(--category-bg);
            border-radius: 50px;
            padding: 12px 24px;
            min-height: 48px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            flex-wrap: nowrap;
            overflow: hidden;
            position: relative;
            width: fit-content;
            max-width: 100%;
        }

        .category-badge:hover {
            border-color: var(--category-color);
            box-shadow: 0 4px 12px rgba(74, 165, 78, 0.2);
        }

        /* Иконка категории */
        .category-icon {
            margin-right: 12px;
            font-size: 1.3rem;
            color: var(--category-color);
            min-width: 28px;
            text-align: center;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
        }

        /* Название категории */
        .category-name {
            color: var(--category-color);
            font-weight: 700;
            font-size: 1.1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .category-type-badge.income {
            background-color: #d5f4e6;
            color: #27ae60;
        }

        .category-type-badge.expense {
            background-color: #fadbd8;
            color: #e74c3c;
        }

        .subcategories-list {
            margin-top: 0.5rem;
            padding-left: 1rem;
            border-left: 2px dashed #bdc3c7;
        }

        /* Стили для страницы лимитов */
        .limits-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .planned-income-card {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .limits-setup {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .limits-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        /* Лимиты - адаптивные */
        .limit-item {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }

        .limit-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--success), var(--success-light));
            border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
        }

        .limit-item:hover {
            box-shadow: 0 8px 25px rgba(74, 165, 78, 0.15);
            border-color: rgba(74, 165, 78, 0.4);
        }

        .limit-info {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .limit-category {
            font-weight: 600;
            color: #2c3e50;
        }

        .limit-details {
            display: flex;
            gap: 1rem;
            color: #7f8c8d;
        }

        .limit-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .limit-slider {
            width: 200px;
        }

        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #3498db;
        }

        .total-limits-info {
            display: flex;
            justify-content: space-between;
            margin: 1.5rem 0;
            padding: 1rem;
            background-color: #e8f4fc;
            border-radius: 8px;
        }

        .total-percentage,
        .remaining-percentage {
            font-size: 1.1rem;
            font-weight: 600;
        }

        #total-percentage {
            color: #e74c3c;
        }

        #remaining-percentage {
            color: #27ae60;
        }

        /* Стили для обновленной страницы лимитов */
        .limits-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .input-with-button {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .input-with-button .form-control {
            flex: 1;
        }

        .add-limit-form {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .add-limit-form h5 {
            margin-bottom: 1rem;
            color: #2c3e50;
        }

        .limit-header {
            margin-bottom: 1rem;
        }

        .limit-category-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .limit-category-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
            flex: 1;
            min-width: 200px;
            max-width: 100%;
            word-break: break-word;
        }

        .limit-category-actions {
            display: flex;
            gap: 0.5rem;
        }

        .limit-details {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .limit-setting {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .limit-input-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .limit-input-group label {
            font-weight: 600;
            color: #34495e;
            white-space: nowrap;
        }

        .limit-input-with-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .limit-input-with-button .form-control-sm {
            width: 80px;
            padding: 0.5rem;
            font-size: 1rem;
            text-align: center;
        }

        .limit-percentage-suffix {
            font-weight: 600;
            color: #7f8c8d;
        }

        .limit-amount {
            font-size: 1.3rem;
            font-weight: bold;
            color: #2c3e50;
            background-color: #f8f9fa;
            padding: 0.5rem 1rem;
            border-radius: 6px;
        }

        .limit-progress {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .spent-amount {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spent-label {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .spent-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .progress-percentage {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 0.5rem 0;
        }

        .progress-bar {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        .overspend-warning {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #e74c3c;
            font-weight: 600;
            background-color: rgba(231, 76, 60, 0.1);
            padding: 0.5rem;
            border-radius: 4px;
            margin-top: 0.5rem;
        }

        /* Стили для страницы сводки */
        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .date-filters {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .report-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--success), var(--success-light));
            border-radius: var(--border-radius-md) var(--border-radius-md) 0 0;
        }

        .stat-card.income {
            border-left: 4px solid #27ae60;
        }

        .stat-card.expense {
            border-left: 4px solid #e74c3c;
        }

        .stat-card.balance {
            border-left: 4px solid #3498db;
        }

        .stat-icon {
            font-size: 2rem;
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stat-card.income .stat-icon {
            background-color: #27ae60;
        }

        .stat-card.expense .stat-icon {
            background-color: #e74c3c;
        }

        .stat-card.balance .stat-icon {
            background-color: #3498db;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .report-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .chart-container,
        .report-table-container {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        #expenses-chart {
            width: 100%;
            height: 300px;
        }

        .report-table {
            width: 100%;
            border-collapse: collapse;
        }

        .report-table th,
        .report-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .report-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .report-table tr:hover {
            background-color: #f5f5f5;
        }

        /* Стили для кнопок действий в транзакциях */
        .transaction-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: flex-end;
        }

        /* Стили для управления таблицами в отчете */
        .table-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid #3498db;
            color: #3498db;
        }

        .btn-outline:hover {
            background-color: #3498db;
            color: white;
        }

        .btn-outline.active {
            background-color: #3498db;
            color: white;
        }

        .report-table-content {
            overflow-x: auto;
        }

        .subcategory-row {
            background-color: #fafafa;
        }

        .btn-icon-sm {
            background: none;
            border: none;
            color: #7f8c8d;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.2rem;
            margin-left: 0.5rem;
        }

        .btn-icon-sm:hover {
            color: #3498db;
        }

        /* Стили для формы с подкатегориями */
        #subcategory-group {
            margin-top: -0.5rem;
            transition: all 0.3s ease;
        }

        /* Модальное окно для редактирования счета */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }


        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-bottom: 1px solid #ecf0f1;
        }

        .modal-header h3 {
            margin: 0;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #7f8c8d;
            transition: color 0.3s;
        }

        .modal-close:hover {
            color: #e74c3c;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .modal-buttons .btn {
            flex: 1;
        }

        /* Адаптивность для лимитов */
        @media (max-width: 768px) {
            .limits-header-row {
                flex-direction: column;
                align-items: stretch;
                gap: 1rem;
            }

            .limit-setting {
                flex-direction: column;
                align-items: stretch;
            }

            .limit-input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .limit-input-with-button {
                justify-content: center;
            }

            .modal-content {
                width: 95%;
                margin: 1rem;
            }

            /* ИСПРАВЛЯЕМ ПЛАНИРУЕМЫЙ ДОХОД НА ТЕЛЕФОНЕ */
            .planned-income-card .input-with-button {
                flex-direction: column;
                gap: 1rem;
            }

            .planned-income-card .input-with-button input {
                width: 100%;
                font-size: 1.1rem;
                padding: 1rem;
            }

            .planned-income-card .input-with-button button {
                width: 100%;
                padding: 0.9rem;
            }

            /* Улучшаем отображение лимитов на телефоне */
            .limit-input-with-button {
                width: 100%;
                justify-content: space-between;
            }

            .limit-input-with-button .form-control-sm {
                width: 100px;
                font-size: 1.1rem;
                padding: 0.7rem;
            }

            .limit-amount {
                font-size: 1.1rem;
                text-align: center;
                width: 100%;
                margin-top: 0.5rem;
            }

            .btn {
                padding: 0.9rem 1.5rem;
                font-size: 1rem;
                border-radius: 12px;
            }

            /* Улучшаем форму добавления операции */
            #add-transaction-form .form-control {
                padding: 1rem;
                font-size: 1.1rem;
            }

            /* Улучшаем фильтр операций */
            .filter-row {
                flex-direction: column;
            }

            .filter-group {
                width: 100%;
            }

            .filter-group .form-control-sm {
                padding: 0.8rem;
                font-size: 1rem;
            }

        }

        /* Адаптивность для сводки */
        @media (max-width: 768px) {
            .report-content {
                grid-template-columns: 1fr;
            }

            .report-header {
                flex-direction: column;
                align-items: stretch;
            }

            .date-filters {
                flex-direction: column;
                align-items: stretch;
            }

            .category-forms {
                flex-direction: column;
            }
        }

        /* Для очень маленьких экранов */
        @media (max-width: 480px) {
            .planned-income-card input#planned-income {
                font-size: 1.2rem;
                height: 50px;
            }

            .limit-input-with-button .form-control-sm {
                width: 80px;
            }
        }


        /* Ограничиваем высоту списка операций */
        .recent-transactions {
            max-height: 600px;
            /* Фиксированная максимальная высота */
            overflow-y: auto;
            /* Вертикальная прокрутка */
            padding-right: 5px;
            /* Чтобы полоса прокрутки не наезжала на контент */
        }

        /* Стили для полосы прокрутки */
        .recent-transactions::-webkit-scrollbar {
            width: 6px;
        }

        .recent-transactions::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .recent-transactions::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .recent-transactions::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Стили для заголовка транзакций */
        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .date-filter {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .form-control-sm {
            padding: 0.4rem 0.6rem;
            font-size: 0.9rem;
        }

        /* Разделение категорий */
        .categories-section {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid #f0f0f0;
        }

        .categories-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-title {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .income-title {
            color: #27ae60;
            border-bottom-color: #27ae60;
        }

        .expense-title {
            color: #e74c3c;
            border-bottom-color: #e74c3c;
        }

        /* Подкатегории */
        .subcategories-list {
            margin-top: 0.5rem;
            padding-left: 1.5rem;
            border-left: 2px dashed #bdc3c7;
        }

        .toggle-subcategories {
            background: none;
            border: none;
            color: #7f8c8d;
            cursor: pointer;
            font-size: 1rem;
        }

        /* Фикс для цветов счетов */
        .account-name[style*="color"] {
            padding: 2px 8px;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.05);
        }

        /* Стили для главной страницы (фильтр дат) */
        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .date-filter {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            min-width: 300px;
        }

        .filter-row {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            min-width: 140px;
        }

        .filter-group label {
            white-space: nowrap;
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        .filter-group .form-control-sm {
            flex: 1;
            min-width: 120px;
        }

        .filter-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        /* Стили для сводки */
        .report-type-switcher {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .btn-group {
            display: flex;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #3498db;
        }

        .btn-group .btn {
            border-radius: 0;
            border: none;
            padding: 0.5rem 1rem;
        }

        .btn-group .btn.active {
            background-color: #3498db;
            color: white;
        }

        /* Фиксация размеров графиков и таблиц */
        .chart-wrapper {
            height: 300px;
            position: relative;
            margin-bottom: 1rem;
        }

        #expenses-chart {
            width: 100% !important;
            height: 100% !important;
        }

        .table-wrapper {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 0.5rem;
        }

        /* Стили для полосы прокрутки таблицы */
        .table-wrapper::-webkit-scrollbar {
            width: 8px;
        }

        .table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .table-wrapper::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .transactions-header {
                flex-direction: column;
            }

            .date-filter {
                width: 100%;
            }

            .filter-row {
                flex-direction: column;
            }

            .filter-group {
                width: 100%;
            }

            .report-type-switcher {
                flex-direction: column;
                align-items: stretch;
            }

            .btn-group {
                width: 100%;
            }

            .btn-group .btn {
                flex: 1;
                text-align: center;
            }
        }

        /* Стили для страницы экспорта */
        .export-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .export-info {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .export-info ul {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        .export-info li {
            margin-bottom: 0.5rem;
        }

        .warning-note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .warning-note i {
            color: #856404;
        }

        .export-actions {
            display: flex;
            gap: 1rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .export-result {
            margin-top: 2rem;
            min-height: 100px;
        }

        .success-message {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1.5rem;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .success-message i {
            color: #28a745;
            font-size: 1.5rem;
        }

        .error-message {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 1.5rem;
            border-radius: 8px;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .error-message i {
            color: #dc3545;
            font-size: 1.5rem;
        }

        .file-info {
            color: #6c757d;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        /* Предпросмотр JSON */
        .export-preview {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
            border: 1px solid #dee2e6;
        }

        .json-preview {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            margin: 1rem 0;
            max-height: 400px;
            overflow-y: auto;
        }

        .json-preview pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #close-preview {
            margin-top: 1rem;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .export-actions {
                flex-direction: column;
            }

            .export-actions .btn {
                width: 100%;
            }
        }

        /* Стили для страницы импорта */
        .import-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .import-info {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .warning-box {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            border-radius: 4px;
            margin: 1.5rem 0;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .warning-box i {
            color: #856404;
            font-size: 1.5rem;
            margin-top: 0.2rem;
        }

        .warning-box strong {
            color: #856404;
        }

        /* Область загрузки файла */
        .file-upload-area {
            border: 2px dashed #3498db;
            border-radius: 12px;
            padding: 3rem 1rem;
            text-align: center;
            margin: 2rem 0;
            background-color: rgba(52, 152, 219, 0.05);
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload-area:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .file-upload-area.dragover {
            background-color: rgba(52, 152, 219, 0.2);
            border-color: #2980b9;
        }

        .upload-icon {
            font-size: 3rem;
            color: #3498db;
            margin-bottom: 1rem;
        }

        .file-upload-area p {
            color: #7f8c8d;
            margin-bottom: 1rem;
        }

        .file-hint {
            font-size: 0.9rem;
            color: #95a5a6;
            margin-top: 1rem;
        }

        /* Информация о файле */
        .import-preview {
            background-color: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
            border: 1px solid #dee2e6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .file-info-summary {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 6px;
            margin: 1.5rem 0;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            font-weight: 600;
            color: #2c3e50;
        }

        .import-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        /* Общие стили для сообщений */
        .success-message,
        .error-message {
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: flex-start;
            gap: 1rem;
        }

        .success-message {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .success-message i {
            color: #28a745;
            font-size: 1.5rem;
        }

        .error-message {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .error-message i {
            color: #dc3545;
            font-size: 1.5rem;
        }

        /* Кнопка выбора файла */
        .btn-outline {
            background-color: transparent;
            border: 2px solid #3498db;
            color: #3498db;
            padding: 0.6rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-outline:hover {
            background-color: #3498db;
            color: white;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .import-actions {
                flex-direction: column;
            }

            .import-actions .btn {
                width: 100%;
            }

            .file-upload-area {
                padding: 2rem 1rem;
            }

            .info-row {
                flex-direction: column;
                gap: 0.3rem;
                padding: 0.8rem 0;
            }
        }


        /* Стили для переключателя глазка */
        .eye-toggle {
            background: none;
            border: none;
            cursor: pointer;
            color: #7f8c8d;
            font-size: 1.2rem;
            padding: 0.5rem;
            transition: color 0.3s;
        }

        .eye-toggle:hover {
            color: #3498db;
        }

        .eye-toggle.active {
            color: #4cd964;
        }

        /* Стиль для скрытого счета */
        .account-item.hidden {
            opacity: 0.6;
            background-color: #f0f0f0;
        }

        .account-item.hidden .account-balance {
            color: #95a5a6;
        }

        /* Стили для чекбокса в модальном окне */
        .checkbox-group {
            margin-top: 1rem;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 600;
            color: #34495e;
            margin-bottom: 0.5rem;
        }

        .checkbox-label input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-label .text-muted {
            font-weight: normal;
            color: #7f8c8d;
            font-size: 0.85rem;
            margin-left: 28px;
        }

        /* Стили для множественного добавления подкатегорий */
        .subcategory-fields-container {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .subcategory-fields {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .subcategory-field-group {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .input-with-button {
            display: flex;
            gap: 0.5rem;
        }

        .input-with-button .form-control {
            flex: 1;
        }

        .btn-success {
            background-color: #28a745;
            border-color: #28a745;
            color: white;
            padding: 0.5rem 0.8rem;
            min-width: 40px;
        }

        .btn-success:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }

        .btn-danger {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
            padding: 0.5rem 0.8rem;
            min-width: 40px;
        }

        .btn-danger:hover {
            background-color: #c82333;
            border-color: #bd2130;
        }

        /* Улучшаем отображение формы */
        .add-category-form .text-muted {
            display: block;
            margin-top: 0.5rem;
            font-size: 0.85rem;
        }

        /* Стили для перетаскивания лимитов */
        .limit-item {
            cursor: move;
            /* Курсор "перемещение" */
            user-select: none;
            /* Запрещаем выделение текста */
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .limit-item.dragging {
            opacity: 0.7;
            transform: rotate(3deg);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }

        .limit-item.drag-over {
            border-top: 3px solid #3498db;
            margin-top: 5px;
        }

        /* Иконка для перетаскивания */
        .drag-handle {
            cursor: grab;
            color: #7f8c8d;
            padding: 0.5rem;
            margin-right: 0.5rem;
        }

        .drag-handle:hover {
            color: #3498db;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-icon {
            font-size: 1rem;
        }

        /* Визуальная подсказка при перетаскивании */
        .drag-hint {
            color: #95a5a6;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            text-align: center;
            font-style: italic;
        }


        /* Временные уведомления */
        .temp-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: fadeInOut 3s ease;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                transform: translateY(-20px);
            }

            10% {
                opacity: 1;
                transform: translateY(0);
            }

            90% {
                opacity: 1;
                transform: translateY(0);
            }

            100% {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .temp-notification.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .temp-notification.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .temp-notification.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Стили для индикатора процентов */
        .percentage-indicator-card {
            background: var(--card-gradient);
            border-radius: var(--border-radius-md);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            border: var(--card-border);
            margin-bottom: 1.5rem;
            position: relative;
            overflow: hidden;
        }

        .percentage-info {
            margin-top: 1rem;
        }

        .percentage-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            background-color: white;
            border-radius: 6px;
        }

        .percentage-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .percentage-value {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .percentage-value.exceeded {
            color: #ff3b30;
        }

        .percentage-value.negative {
            color: #ff9500;
        }

        .percentage-progress {
            margin: 1.5rem 0;
        }

        .progress-bar-bg {
            width: 100%;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-bottom: 0.5rem;
        }

        .progress-bar-used {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-bar-exceeded {
            height: 100%;
            background-color: #ff3b30;
            position: absolute;
            top: 0;
            right: 0;
            opacity: 0.7;
        }

        .percentage-markers {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .percentage-markers .marker {
            position: relative;
        }

        .percentage-markers .marker:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 6px;
            background-color: #bdc3c7;
        }

        .percentage-warning {
            background-color: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.3);
            color: #ff3b30;
            padding: 0.8rem;
            border-radius: 6px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        /* Дополнительные стили для индикатора процентов */
        .percentage-indicator-card {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            border-left: 4px solid #9b59b6;
        }

        .percentage-info {
            margin-top: 1rem;
        }

        .percentage-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            background-color: white;
            border-radius: 6px;
        }

        .percentage-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .percentage-value {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .percentage-value.exceeded {
            color: #ff3b30;
        }

        .percentage-value.negative {
            color: #ff9500;
        }

        .percentage-progress {
            margin: 1.5rem 0;
        }

        .progress-bar-bg {
            width: 100%;
            height: 20px;
            background-color: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-bottom: 0.5rem;
        }

        .progress-bar-used {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .progress-bar-exceeded {
            height: 100%;
            background-color: #ff3b30;
            position: absolute;
            top: 0;
            right: 0;
            opacity: 0.7;
        }

        .percentage-markers {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #7f8c8d;
        }

        .percentage-markers .marker {
            position: relative;
        }

        .percentage-markers .marker:before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 6px;
            background-color: #bdc3c7;
        }

        .percentage-warning {
            background-color: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.3);
            color: #ff3b30;
            padding: 0.8rem;
            border-radius: 6px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }




        /* Стили для переводов */
        .transaction-item.transfer {
            border-left-color: #3498db;
            background-color: #e8f4fc;
        }

        .transaction-amount.transfer {
            color: #3498db;
        }

        .transfer-icon {
            color: #3498db;
            margin-right: 5px;
        }

        .transfer-details {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .transfer-arrow {
            color: #3498db;
            font-size: 0.8rem;
        }

        #to-account-group {
            transition: all 0.3s ease;
        }

        /* Адаптивность для телефона - ОБНОВЛЕНО */
        @media (max-width: 768px) {
            .app-main {
                padding: 1rem;
            }

            .main-page-container {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .report-content {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }

            .main-nav {
                flex-direction: column;
                gap: 0.5rem;
            }

            .nav-link {
                width: 100%;
                justify-content: center;
                padding: 0.8rem;
            }

            /* Категории на телефоне */
            .category-badge {
                padding: 10px 20px;
                min-height: 44px;
                border-radius: 40px;
                width: 100%;
            }

            .category-icon {
                font-size: 1.2rem;
                min-width: 24px;
                margin-right: 10px;
            }

            .category-name {
                font-size: 1rem;
            }

            /* Лимиты на телефоне */
            .limit-item {
                padding: 1.2rem;
            }

            .limit-category-name {
                font-size: 1.1rem;
                min-width: 100%;
            }

            .limit-setting {
                flex-direction: column;
                align-items: stretch;
                gap: 0.8rem;
            }

            .limit-input-group {
                flex-direction: column;
                gap: 0.5rem;
            }
        }

        @media (max-width: 480px) {
            .app-header h1 {
                font-size: 1.8rem;
            }

            .category-badge {
                padding: 8px 16px;
                min-height: 40px;
                border-radius: 35px;
            }

            .category-icon {
                font-size: 1.1rem;
                min-width: 22px;
                margin-right: 8px;
            }

            .category-name {
                font-size: 0.95rem;
            }

            .limit-item {
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .limit-category-name {
                font-size: 1rem;
            }

            .btn {
                padding: 0.7rem 1.5rem;
                font-size: 0.95rem;
                width: 100%;
            }
        }

        /* Остальные стили оставляем как есть, но ДОБАВИМ: */
        .text-muted {
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--info);
            color: var(--info);
        }

        .btn-outline:hover {
            background-color: var(--info);
            color: white;
        }

        /* Очистите все ДУБЛИРУЮЩИЕСЯ стили ниже этого комментария */
        /* Удалите все что повторяет вышеуказанные стили */
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Шапка -->
        <header class="app-header">
            <h1><i class="fas fa-wallet"></i> Мои Финансы</h1>
            <nav class="main-nav">
                <a href="#" class="nav-link active" data-page="main"><i class="fas fa-home"></i> Главная</a>
                <a href="#" class="nav-link" data-page="accounts"><i class="fas fa-credit-card"></i> Счета</a>
                <a href="#" class="nav-link" data-page="categories"><i class="fas fa-tags"></i> Категории</a>
                <a href="#" class="nav-link" data-page="limits"><i class="fas fa-chart-pie"></i> Лимиты</a>
                <a href="#" class="nav-link" data-page="report"><i class="fas fa-chart-bar"></i> Сводка</a>
                <!-- НОВЫЕ КНОПКИ -->
                <a href="#" class="nav-link" data-page="export"><i class="fas fa-file-export"></i> Экспорт</a>
                <a href="#" class="nav-link" data-page="import"><i class="fas fa-file-import"></i> Импорт</a>

            </nav>
        </header>

        <!-- Основное содержимое (будет меняться) -->
        <main class="app-main" id="app-main">
            <!-- Здесь будет загружаться содержимое страниц -->
            <div class="page active" id="page-main">
                <h2>Главная</h2>
                <!-- Сюда вставим форму и список операций -->
            </div>
            <div class="page" id="page-accounts">
                <h2>Управление счетами</h2>
            </div>
            <div class="page" id="page-categories">
                <h2>Категории и подкатегории</h2>
            </div>
            <div class="page" id="page-limits">
                <h2>Лимиты на месяц</h2>
            </div>
            <div class="page" id="page-report">
                <h2>Сводка и графики</h2>
            </div>
            <div class="page" id="page-export">
                <h2>Экспорт данных</h2>
            </div>
            <div class="page" id="page-import">
                <h2>Импорт данных</h2>
            </div>

        </main>

        <!-- Футер с балансом -->
        <footer class="app-footer">
            <div class="total-balance">
                Общий баланс: <strong id="total-balance">0 ₽</strong>
            </div>
        </footer>
    </div>

    <!-- Подключаем Dexie для работы с IndexedDB -->
    <script>
        /*
         * Dexie.js - a minimalistic wrapper for IndexedDB
         * ===============================================
         *
         * By David Fahlander, david.fahlander@gmail.com
         *
         * Version 4.3.0, Sat Dec 20 2025
         *
         * https://dexie.org
         *
         * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
         */

        (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dexie = factory());
        })(this, (function () {
            'use strict';

            var extendStatics = function (d, b) {
                extendStatics = Object.setPrototypeOf ||
                    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                    function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
                return extendStatics(d, b);
            };
            function __extends(d, b) {
                if (typeof b !== "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                extendStatics(d, b);
                function __() { this.constructor = d; }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            }
            var __assign = function () {
                __assign = Object.assign || function __assign(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };
            function __spreadArray(to, from, pack) {
                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                    if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                    }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
            }
            typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
                var e = new Error(message);
                return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
            };

            var _global = typeof globalThis !== 'undefined' ? globalThis :
                typeof self !== 'undefined' ? self :
                    typeof window !== 'undefined' ? window :
                        global;

            var keys = Object.keys;
            var isArray = Array.isArray;
            if (typeof Promise !== 'undefined' && !_global.Promise) {
                _global.Promise = Promise;
            }
            function extend(obj, extension) {
                if (typeof extension !== 'object')
                    return obj;
                keys(extension).forEach(function (key) {
                    obj[key] = extension[key];
                });
                return obj;
            }
            var getProto = Object.getPrototypeOf;
            var _hasOwn = {}.hasOwnProperty;
            function hasOwn(obj, prop) {
                return _hasOwn.call(obj, prop);
            }
            function props(proto, extension) {
                if (typeof extension === 'function')
                    extension = extension(getProto(proto));
                (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {
                    setProp(proto, key, extension[key]);
                });
            }
            var defineProperty = Object.defineProperty;
            function setProp(obj, prop, functionOrGetSet, options) {
                defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
                    { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
                    { value: functionOrGetSet, configurable: true, writable: true }, options));
            }
            function derive(Child) {
                return {
                    from: function (Parent) {
                        Child.prototype = Object.create(Parent.prototype);
                        setProp(Child.prototype, "constructor", Child);
                        return {
                            extend: props.bind(null, Child.prototype)
                        };
                    }
                };
            }
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            function getPropertyDescriptor(obj, prop) {
                var pd = getOwnPropertyDescriptor(obj, prop);
                var proto;
                return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
            }
            var _slice = [].slice;
            function slice(args, start, end) {
                return _slice.call(args, start, end);
            }
            function override(origFunc, overridedFactory) {
                return overridedFactory(origFunc);
            }
            function assert(b) {
                if (!b)
                    throw new Error("Assertion Failed");
            }
            function asap$1(fn) {
                if (_global.setImmediate)
                    setImmediate(fn);
                else
                    setTimeout(fn, 0);
            }
            function arrayToObject(array, extractor) {
                return array.reduce(function (result, item, i) {
                    var nameAndValue = extractor(item, i);
                    if (nameAndValue)
                        result[nameAndValue[0]] = nameAndValue[1];
                    return result;
                }, {});
            }
            function getByKeyPath(obj, keyPath) {
                if (typeof keyPath === 'string' && hasOwn(obj, keyPath))
                    return obj[keyPath];
                if (!keyPath)
                    return obj;
                if (typeof keyPath !== 'string') {
                    var rv = [];
                    for (var i = 0, l = keyPath.length; i < l; ++i) {
                        var val = getByKeyPath(obj, keyPath[i]);
                        rv.push(val);
                    }
                    return rv;
                }
                var period = keyPath.indexOf('.');
                if (period !== -1) {
                    var innerObj = obj[keyPath.substr(0, period)];
                    return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
                }
                return undefined;
            }
            function setByKeyPath(obj, keyPath, value) {
                if (!obj || keyPath === undefined)
                    return;
                if ('isFrozen' in Object && Object.isFrozen(obj))
                    return;
                if (typeof keyPath !== 'string' && 'length' in keyPath) {
                    assert(typeof value !== 'string' && 'length' in value);
                    for (var i = 0, l = keyPath.length; i < l; ++i) {
                        setByKeyPath(obj, keyPath[i], value[i]);
                    }
                }
                else {
                    var period = keyPath.indexOf('.');
                    if (period !== -1) {
                        var currentKeyPath = keyPath.substr(0, period);
                        var remainingKeyPath = keyPath.substr(period + 1);
                        if (remainingKeyPath === "")
                            if (value === undefined) {
                                if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                                    obj.splice(currentKeyPath, 1);
                                else
                                    delete obj[currentKeyPath];
                            }
                            else
                                obj[currentKeyPath] = value;
                        else {
                            var innerObj = obj[currentKeyPath];
                            if (!innerObj || !hasOwn(obj, currentKeyPath))
                                innerObj = (obj[currentKeyPath] = {});
                            setByKeyPath(innerObj, remainingKeyPath, value);
                        }
                    }
                    else {
                        if (value === undefined) {
                            if (isArray(obj) && !isNaN(parseInt(keyPath)))
                                obj.splice(keyPath, 1);
                            else
                                delete obj[keyPath];
                        }
                        else
                            obj[keyPath] = value;
                    }
                }
            }
            function delByKeyPath(obj, keyPath) {
                if (typeof keyPath === 'string')
                    setByKeyPath(obj, keyPath, undefined);
                else if ('length' in keyPath)
                    [].map.call(keyPath, function (kp) {
                        setByKeyPath(obj, kp, undefined);
                    });
            }
            function shallowClone(obj) {
                var rv = {};
                for (var m in obj) {
                    if (hasOwn(obj, m))
                        rv[m] = obj[m];
                }
                return rv;
            }
            var concat = [].concat;
            function flatten(a) {
                return concat.apply([], a);
            }
            var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
                .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return ["Int", "Uint", "Float"].map(function (t) { return t + num + "Array"; }); }))).filter(function (t) { return _global[t]; });
            var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));
            function cloneSimpleObjectTree(o) {
                var rv = {};
                for (var k in o)
                    if (hasOwn(o, k)) {
                        var v = o[k];
                        rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
                    }
                return rv;
            }
            function objectIsEmpty(o) {
                for (var k in o)
                    if (hasOwn(o, k))
                        return false;
                return true;
            }
            var circularRefs = null;
            function deepClone(any) {
                circularRefs = new WeakMap();
                var rv = innerDeepClone(any);
                circularRefs = null;
                return rv;
            }
            function innerDeepClone(x) {
                if (!x || typeof x !== 'object')
                    return x;
                var rv = circularRefs.get(x);
                if (rv)
                    return rv;
                if (isArray(x)) {
                    rv = [];
                    circularRefs.set(x, rv);
                    for (var i = 0, l = x.length; i < l; ++i) {
                        rv.push(innerDeepClone(x[i]));
                    }
                }
                else if (intrinsicTypes.has(x.constructor)) {
                    rv = x;
                }
                else {
                    var proto = getProto(x);
                    rv = proto === Object.prototype ? {} : Object.create(proto);
                    circularRefs.set(x, rv);
                    for (var prop in x) {
                        if (hasOwn(x, prop)) {
                            rv[prop] = innerDeepClone(x[prop]);
                        }
                    }
                }
                return rv;
            }
            var toString = {}.toString;
            function toStringTag(o) {
                return toString.call(o).slice(8, -1);
            }
            var iteratorSymbol = typeof Symbol !== 'undefined' ?
                Symbol.iterator :
                '@@iterator';
            var getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
                var i;
                return x != null && (i = x[iteratorSymbol]) && i.apply(x);
            } : function () { return null; };
            function delArrayItem(a, x) {
                var i = a.indexOf(x);
                if (i >= 0)
                    a.splice(i, 1);
                return i >= 0;
            }
            var NO_CHAR_ARRAY = {};
            function getArrayOf(arrayLike) {
                var i, a, x, it;
                if (arguments.length === 1) {
                    if (isArray(arrayLike))
                        return arrayLike.slice();
                    if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                        return [arrayLike];
                    if ((it = getIteratorOf(arrayLike))) {
                        a = [];
                        while ((x = it.next()), !x.done)
                            a.push(x.value);
                        return a;
                    }
                    if (arrayLike == null)
                        return [arrayLike];
                    i = arrayLike.length;
                    if (typeof i === 'number') {
                        a = new Array(i);
                        while (i--)
                            a[i] = arrayLike[i];
                        return a;
                    }
                    return [arrayLike];
                }
                i = arguments.length;
                a = new Array(i);
                while (i--)
                    a[i] = arguments[i];
                return a;
            }
            var isAsyncFunction = typeof Symbol !== 'undefined'
                ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }
                : function () { return false; };

            var dexieErrorNames = [
                'Modify',
                'Bulk',
                'OpenFailed',
                'VersionChange',
                'Schema',
                'Upgrade',
                'InvalidTable',
                'MissingAPI',
                'NoSuchDatabase',
                'InvalidArgument',
                'SubTransaction',
                'Unsupported',
                'Internal',
                'DatabaseClosed',
                'PrematureCommit',
                'ForeignAwait'
            ];
            var idbDomErrorNames = [
                'Unknown',
                'Constraint',
                'Data',
                'TransactionInactive',
                'ReadOnly',
                'Version',
                'NotFound',
                'InvalidState',
                'InvalidAccess',
                'Abort',
                'Timeout',
                'QuotaExceeded',
                'Syntax',
                'DataClone'
            ];
            var errorList = dexieErrorNames.concat(idbDomErrorNames);
            var defaultTexts = {
                VersionChanged: "Database version changed by other database connection",
                DatabaseClosed: "Database has been closed",
                Abort: "Transaction aborted",
                TransactionInactive: "Transaction has already completed or failed",
                MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
            };
            function DexieError(name, msg) {
                this.name = name;
                this.message = msg;
            }
            derive(DexieError).from(Error).extend({
                toString: function () { return this.name + ": " + this.message; }
            });
            function getMultiErrorMessage(msg, failures) {
                return msg + ". Errors: " + Object.keys(failures)
                    .map(function (key) { return failures[key].toString(); })
                    .filter(function (v, i, s) { return s.indexOf(v) === i; })
                    .join('\n');
            }
            function ModifyError(msg, failures, successCount, failedKeys) {
                this.failures = failures;
                this.failedKeys = failedKeys;
                this.successCount = successCount;
                this.message = getMultiErrorMessage(msg, failures);
            }
            derive(ModifyError).from(DexieError);
            function BulkError(msg, failures) {
                this.name = "BulkError";
                this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });
                this.failuresByPos = failures;
                this.message = getMultiErrorMessage(msg, this.failures);
            }
            derive(BulkError).from(DexieError);
            var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + "Error", obj); }, {});
            var BaseException = DexieError;
            var exceptions = errorList.reduce(function (obj, name) {
                var fullName = name + "Error";
                function DexieError(msgOrInner, inner) {
                    this.name = fullName;
                    if (!msgOrInner) {
                        this.message = defaultTexts[name] || fullName;
                        this.inner = null;
                    }
                    else if (typeof msgOrInner === 'string') {
                        this.message = "".concat(msgOrInner).concat(!inner ? '' : '\n ' + inner);
                        this.inner = inner || null;
                    }
                    else if (typeof msgOrInner === 'object') {
                        this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
                        this.inner = msgOrInner;
                    }
                }
                derive(DexieError).from(BaseException);
                obj[name] = DexieError;
                return obj;
            }, {});
            exceptions.Syntax = SyntaxError;
            exceptions.Type = TypeError;
            exceptions.Range = RangeError;
            var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
                obj[name + "Error"] = exceptions[name];
                return obj;
            }, {});
            function mapError(domError, message) {
                if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
                    return domError;
                var rv = new exceptionMap[domError.name](message || domError.message, domError);
                if ("stack" in domError) {
                    setProp(rv, "stack", {
                        get: function () {
                            return this.inner.stack;
                        }
                    });
                }
                return rv;
            }
            var fullNameExceptions = errorList.reduce(function (obj, name) {
                if (["Syntax", "Type", "Range"].indexOf(name) === -1)
                    obj[name + "Error"] = exceptions[name];
                return obj;
            }, {});
            fullNameExceptions.ModifyError = ModifyError;
            fullNameExceptions.DexieError = DexieError;
            fullNameExceptions.BulkError = BulkError;

            function nop() { }
            function mirror(val) { return val; }
            function pureFunctionChain(f1, f2) {
                if (f1 == null || f1 === mirror)
                    return f2;
                return function (val) {
                    return f2(f1(val));
                };
            }
            function callBoth(on1, on2) {
                return function () {
                    on1.apply(this, arguments);
                    on2.apply(this, arguments);
                };
            }
            function hookCreatingChain(f1, f2) {
                if (f1 === nop)
                    return f2;
                return function () {
                    var res = f1.apply(this, arguments);
                    if (res !== undefined)
                        arguments[0] = res;
                    var onsuccess = this.onsuccess,
                        onerror = this.onerror;
                    this.onsuccess = null;
                    this.onerror = null;
                    var res2 = f2.apply(this, arguments);
                    if (onsuccess)
                        this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
                    if (onerror)
                        this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
                    return res2 !== undefined ? res2 : res;
                };
            }
            function hookDeletingChain(f1, f2) {
                if (f1 === nop)
                    return f2;
                return function () {
                    f1.apply(this, arguments);
                    var onsuccess = this.onsuccess,
                        onerror = this.onerror;
                    this.onsuccess = this.onerror = null;
                    f2.apply(this, arguments);
                    if (onsuccess)
                        this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
                    if (onerror)
                        this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
                };
            }
            function hookUpdatingChain(f1, f2) {
                if (f1 === nop)
                    return f2;
                return function (modifications) {
                    var res = f1.apply(this, arguments);
                    extend(modifications, res);
                    var onsuccess = this.onsuccess,
                        onerror = this.onerror;
                    this.onsuccess = null;
                    this.onerror = null;
                    var res2 = f2.apply(this, arguments);
                    if (onsuccess)
                        this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
                    if (onerror)
                        this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
                    return res === undefined ?
                        (res2 === undefined ? undefined : res2) :
                        (extend(res, res2));
                };
            }
            function reverseStoppableEventChain(f1, f2) {
                if (f1 === nop)
                    return f2;
                return function () {
                    if (f2.apply(this, arguments) === false)
                        return false;
                    return f1.apply(this, arguments);
                };
            }
            function promisableChain(f1, f2) {
                if (f1 === nop)
                    return f2;
                return function () {
                    var res = f1.apply(this, arguments);
                    if (res && typeof res.then === 'function') {
                        var thiz = this, i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        return res.then(function () {
                            return f2.apply(thiz, args);
                        });
                    }
                    return f2.apply(this, arguments);
                };
            }

            var debug = typeof location !== 'undefined' &&
                /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
            function setDebug(value, filter) {
                debug = value;
            }

            var INTERNAL = {};
            var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?
                [] :
                (function () {
                    var globalP = Promise.resolve();
                    if (typeof crypto === 'undefined' || !crypto.subtle)
                        return [globalP, getProto(globalP), globalP];
                    var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
                    return [
                        nativeP,
                        getProto(nativeP),
                        globalP
                    ];
                })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
            var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
            var patchGlobalPromise = !!resolvedGlobalPromise;
            function schedulePhysicalTick() {
                queueMicrotask(physicalTick);
            }
            var asap = function (callback, args) {
                microtickQueue.push([callback, args]);
                if (needsNewPhysicalTick) {
                    schedulePhysicalTick();
                    needsNewPhysicalTick = false;
                }
            };
            var isOutsideMicroTick = true,
                needsNewPhysicalTick = true,
                unhandledErrors = [],
                rejectingErrors = [],
                rejectionMapper = mirror;
            var globalPSD = {
                id: 'global',
                global: true,
                ref: 0,
                unhandleds: [],
                onunhandled: nop,
                pgp: false,
                env: {},
                finalize: nop
            };
            var PSD = globalPSD;
            var microtickQueue = [];
            var numScheduledCalls = 0;
            var tickFinalizers = [];
            function DexiePromise(fn) {
                if (typeof this !== 'object')
                    throw new TypeError('Promises must be constructed via new');
                this._listeners = [];
                this._lib = false;
                var psd = (this._PSD = PSD);
                if (typeof fn !== 'function') {
                    if (fn !== INTERNAL)
                        throw new TypeError('Not a function');
                    this._state = arguments[1];
                    this._value = arguments[2];
                    if (this._state === false)
                        handleRejection(this, this._value);
                    return;
                }
                this._state = null;
                this._value = null;
                ++psd.ref;
                executePromiseTask(this, fn);
            }
            var thenProp = {
                get: function () {
                    var psd = PSD, microTaskId = totalEchoes;
                    function then(onFulfilled, onRejected) {
                        var _this = this;
                        var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                        var cleanup = possibleAwait && !decrementExpectedAwaits();
                        var rv = new DexiePromise(function (resolve, reject) {
                            propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                        });
                        if (this._consoleTask)
                            rv._consoleTask = this._consoleTask;
                        return rv;
                    }
                    then.prototype = INTERNAL;
                    return then;
                },
                set: function (value) {
                    setProp(this, 'then', value && value.prototype === INTERNAL ?
                        thenProp :
                        {
                            get: function () {
                                return value;
                            },
                            set: thenProp.set
                        });
                }
            };
            props(DexiePromise.prototype, {
                then: thenProp,
                _then: function (onFulfilled, onRejected) {
                    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
                },
                catch: function (onRejected) {
                    if (arguments.length === 1)
                        return this.then(null, onRejected);
                    var type = arguments[0], handler = arguments[1];
                    return typeof type === 'function' ? this.then(null, function (err) {
                        return err instanceof type ? handler(err) : PromiseReject(err);
                    })
                        : this.then(null, function (err) {
                            return err && err.name === type ? handler(err) : PromiseReject(err);
                        });
                },
                finally: function (onFinally) {
                    return this.then(function (value) {
                        return DexiePromise.resolve(onFinally()).then(function () { return value; });
                    }, function (err) {
                        return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });
                    });
                },
                timeout: function (ms, msg) {
                    var _this = this;
                    return ms < Infinity ?
                        new DexiePromise(function (resolve, reject) {
                            var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);
                            _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                        }) : this;
                }
            });
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
                setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
            globalPSD.env = snapShot();
            function Listener(onFulfilled, onRejected, resolve, reject, zone) {
                this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
                this.onRejected = typeof onRejected === 'function' ? onRejected : null;
                this.resolve = resolve;
                this.reject = reject;
                this.psd = zone;
            }
            props(DexiePromise, {
                all: function () {
                    var values = getArrayOf.apply(null, arguments)
                        .map(onPossibleParallellAsync);
                    return new DexiePromise(function (resolve, reject) {
                        if (values.length === 0)
                            resolve([]);
                        var remaining = values.length;
                        values.forEach(function (a, i) {
                            return DexiePromise.resolve(a).then(function (x) {
                                values[i] = x;
                                if (!--remaining)
                                    resolve(values);
                            }, reject);
                        });
                    });
                },
                resolve: function (value) {
                    if (value instanceof DexiePromise)
                        return value;
                    if (value && typeof value.then === 'function')
                        return new DexiePromise(function (resolve, reject) {
                            value.then(resolve, reject);
                        });
                    var rv = new DexiePromise(INTERNAL, true, value);
                    return rv;
                },
                reject: PromiseReject,
                race: function () {
                    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                    return new DexiePromise(function (resolve, reject) {
                        values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });
                    });
                },
                PSD: {
                    get: function () { return PSD; },
                    set: function (value) { return PSD = value; }
                },
                totalEchoes: { get: function () { return totalEchoes; } },
                newPSD: newScope,
                usePSD: usePSD,
                scheduler: {
                    get: function () { return asap; },
                    set: function (value) { asap = value; }
                },
                rejectionMapper: {
                    get: function () { return rejectionMapper; },
                    set: function (value) { rejectionMapper = value; }
                },
                follow: function (fn, zoneProps) {
                    return new DexiePromise(function (resolve, reject) {
                        return newScope(function (resolve, reject) {
                            var psd = PSD;
                            psd.unhandleds = [];
                            psd.onunhandled = reject;
                            psd.finalize = callBoth(function () {
                                var _this = this;
                                run_at_end_of_this_or_next_physical_tick(function () {
                                    _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                                });
                            }, psd.finalize);
                            fn();
                        }, zoneProps, resolve, reject);
                    });
                }
            });
            if (NativePromise) {
                if (NativePromise.allSettled)
                    setProp(DexiePromise, "allSettled", function () {
                        var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                        return new DexiePromise(function (resolve) {
                            if (possiblePromises.length === 0)
                                resolve([]);
                            var remaining = possiblePromises.length;
                            var results = new Array(remaining);
                            possiblePromises.forEach(function (p, i) {
                                return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: "fulfilled", value: value }; }, function (reason) { return results[i] = { status: "rejected", reason: reason }; })
                                    .then(function () { return --remaining || resolve(results); });
                            });
                        });
                    });
                if (NativePromise.any && typeof AggregateError !== 'undefined')
                    setProp(DexiePromise, "any", function () {
                        var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                        return new DexiePromise(function (resolve, reject) {
                            if (possiblePromises.length === 0)
                                reject(new AggregateError([]));
                            var remaining = possiblePromises.length;
                            var failures = new Array(remaining);
                            possiblePromises.forEach(function (p, i) {
                                return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {
                                    failures[i] = failure;
                                    if (!--remaining)
                                        reject(new AggregateError(failures));
                                });
                            });
                        });
                    });
                if (NativePromise.withResolvers)
                    DexiePromise.withResolvers = NativePromise.withResolvers;
            }
            function executePromiseTask(promise, fn) {
                try {
                    fn(function (value) {
                        if (promise._state !== null)
                            return;
                        if (value === promise)
                            throw new TypeError('A promise cannot be resolved with itself.');
                        var shouldExecuteTick = promise._lib && beginMicroTickScope();
                        if (value && typeof value.then === 'function') {
                            executePromiseTask(promise, function (resolve, reject) {
                                value instanceof DexiePromise ?
                                    value._then(resolve, reject) :
                                    value.then(resolve, reject);
                            });
                        }
                        else {
                            promise._state = true;
                            promise._value = value;
                            propagateAllListeners(promise);
                        }
                        if (shouldExecuteTick)
                            endMicroTickScope();
                    }, handleRejection.bind(null, promise));
                }
                catch (ex) {
                    handleRejection(promise, ex);
                }
            }
            function handleRejection(promise, reason) {
                rejectingErrors.push(reason);
                if (promise._state !== null)
                    return;
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                reason = rejectionMapper(reason);
                promise._state = false;
                promise._value = reason;
                addPossiblyUnhandledError(promise);
                propagateAllListeners(promise);
                if (shouldExecuteTick)
                    endMicroTickScope();
            }
            function propagateAllListeners(promise) {
                var listeners = promise._listeners;
                promise._listeners = [];
                for (var i = 0, len = listeners.length; i < len; ++i) {
                    propagateToListener(promise, listeners[i]);
                }
                var psd = promise._PSD;
                --psd.ref || psd.finalize();
                if (numScheduledCalls === 0) {
                    ++numScheduledCalls;
                    asap(function () {
                        if (--numScheduledCalls === 0)
                            finalizePhysicalTick();
                    }, []);
                }
            }
            function propagateToListener(promise, listener) {
                if (promise._state === null) {
                    promise._listeners.push(listener);
                    return;
                }
                var cb = promise._state ? listener.onFulfilled : listener.onRejected;
                if (cb === null) {
                    return (promise._state ? listener.resolve : listener.reject)(promise._value);
                }
                ++listener.psd.ref;
                ++numScheduledCalls;
                asap(callListener, [cb, promise, listener]);
            }
            function callListener(cb, promise, listener) {
                try {
                    var ret, value = promise._value;
                    if (!promise._state && rejectingErrors.length)
                        rejectingErrors = [];
                    ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);
                    if (!promise._state && rejectingErrors.indexOf(value) === -1) {
                        markErrorAsHandled(promise);
                    }
                    listener.resolve(ret);
                }
                catch (e) {
                    listener.reject(e);
                }
                finally {
                    if (--numScheduledCalls === 0)
                        finalizePhysicalTick();
                    --listener.psd.ref || listener.psd.finalize();
                }
            }
            function physicalTick() {
                usePSD(globalPSD, function () {
                    beginMicroTickScope() && endMicroTickScope();
                });
            }
            function beginMicroTickScope() {
                var wasRootExec = isOutsideMicroTick;
                isOutsideMicroTick = false;
                needsNewPhysicalTick = false;
                return wasRootExec;
            }
            function endMicroTickScope() {
                var callbacks, i, l;
                do {
                    while (microtickQueue.length > 0) {
                        callbacks = microtickQueue;
                        microtickQueue = [];
                        l = callbacks.length;
                        for (i = 0; i < l; ++i) {
                            var item = callbacks[i];
                            item[0].apply(null, item[1]);
                        }
                    }
                } while (microtickQueue.length > 0);
                isOutsideMicroTick = true;
                needsNewPhysicalTick = true;
            }
            function finalizePhysicalTick() {
                var unhandledErrs = unhandledErrors;
                unhandledErrors = [];
                unhandledErrs.forEach(function (p) {
                    p._PSD.onunhandled.call(null, p._value, p);
                });
                var finalizers = tickFinalizers.slice(0);
                var i = finalizers.length;
                while (i)
                    finalizers[--i]();
            }
            function run_at_end_of_this_or_next_physical_tick(fn) {
                function finalizer() {
                    fn();
                    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
                }
                tickFinalizers.push(finalizer);
                ++numScheduledCalls;
                asap(function () {
                    if (--numScheduledCalls === 0)
                        finalizePhysicalTick();
                }, []);
            }
            function addPossiblyUnhandledError(promise) {
                if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))
                    unhandledErrors.push(promise);
            }
            function markErrorAsHandled(promise) {
                var i = unhandledErrors.length;
                while (i)
                    if (unhandledErrors[--i]._value === promise._value) {
                        unhandledErrors.splice(i, 1);
                        return;
                    }
            }
            function PromiseReject(reason) {
                return new DexiePromise(INTERNAL, false, reason);
            }
            function wrap(fn, errorCatcher) {
                var psd = PSD;
                return function () {
                    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
                    try {
                        switchToZone(psd, true);
                        return fn.apply(this, arguments);
                    }
                    catch (e) {
                        errorCatcher && errorCatcher(e);
                    }
                    finally {
                        switchToZone(outerScope, false);
                        if (wasRootExec)
                            endMicroTickScope();
                    }
                };
            }
            var task = { awaits: 0, echoes: 0, id: 0 };
            var taskCounter = 0;
            var zoneStack = [];
            var zoneEchoes = 0;
            var totalEchoes = 0;
            var zone_id_counter = 0;
            function newScope(fn, props, a1, a2) {
                var parent = PSD, psd = Object.create(parent);
                psd.parent = parent;
                psd.ref = 0;
                psd.global = false;
                psd.id = ++zone_id_counter;
                globalPSD.env;
                psd.env = patchGlobalPromise ? {
                    Promise: DexiePromise,
                    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
                    all: DexiePromise.all,
                    race: DexiePromise.race,
                    allSettled: DexiePromise.allSettled,
                    any: DexiePromise.any,
                    resolve: DexiePromise.resolve,
                    reject: DexiePromise.reject,
                } : {};
                if (props)
                    extend(psd, props);
                ++parent.ref;
                psd.finalize = function () {
                    --this.parent.ref || this.parent.finalize();
                };
                var rv = usePSD(psd, fn, a1, a2);
                if (psd.ref === 0)
                    psd.finalize();
                return rv;
            }
            function incrementExpectedAwaits() {
                if (!task.id)
                    task.id = ++taskCounter;
                ++task.awaits;
                task.echoes += ZONE_ECHO_LIMIT;
                return task.id;
            }
            function decrementExpectedAwaits() {
                if (!task.awaits)
                    return false;
                if (--task.awaits === 0)
                    task.id = 0;
                task.echoes = task.awaits * ZONE_ECHO_LIMIT;
                return true;
            }
            if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
                incrementExpectedAwaits = decrementExpectedAwaits = nop;
            }
            function onPossibleParallellAsync(possiblePromise) {
                if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
                    incrementExpectedAwaits();
                    return possiblePromise.then(function (x) {
                        decrementExpectedAwaits();
                        return x;
                    }, function (e) {
                        decrementExpectedAwaits();
                        return rejection(e);
                    });
                }
                return possiblePromise;
            }
            function zoneEnterEcho(targetZone) {
                ++totalEchoes;
                if (!task.echoes || --task.echoes === 0) {
                    task.echoes = task.awaits = task.id = 0;
                }
                zoneStack.push(PSD);
                switchToZone(targetZone, true);
            }
            function zoneLeaveEcho() {
                var zone = zoneStack[zoneStack.length - 1];
                zoneStack.pop();
                switchToZone(zone, false);
            }
            function switchToZone(targetZone, bEnteringZone) {
                var currentZone = PSD;
                if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
                    queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
                }
                if (targetZone === PSD)
                    return;
                PSD = targetZone;
                if (currentZone === globalPSD)
                    globalPSD.env = snapShot();
                if (patchGlobalPromise) {
                    var GlobalPromise = globalPSD.env.Promise;
                    var targetEnv = targetZone.env;
                    if (currentZone.global || targetZone.global) {
                        Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                        GlobalPromise.all = targetEnv.all;
                        GlobalPromise.race = targetEnv.race;
                        GlobalPromise.resolve = targetEnv.resolve;
                        GlobalPromise.reject = targetEnv.reject;
                        if (targetEnv.allSettled)
                            GlobalPromise.allSettled = targetEnv.allSettled;
                        if (targetEnv.any)
                            GlobalPromise.any = targetEnv.any;
                    }
                }
            }
            function snapShot() {
                var GlobalPromise = _global.Promise;
                return patchGlobalPromise ? {
                    Promise: GlobalPromise,
                    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
                    all: GlobalPromise.all,
                    race: GlobalPromise.race,
                    allSettled: GlobalPromise.allSettled,
                    any: GlobalPromise.any,
                    resolve: GlobalPromise.resolve,
                    reject: GlobalPromise.reject,
                } : {};
            }
            function usePSD(psd, fn, a1, a2, a3) {
                var outerScope = PSD;
                try {
                    switchToZone(psd, true);
                    return fn(a1, a2, a3);
                }
                finally {
                    switchToZone(outerScope, false);
                }
            }
            function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
                return typeof fn !== 'function' ? fn : function () {
                    var outerZone = PSD;
                    if (possibleAwait)
                        incrementExpectedAwaits();
                    switchToZone(zone, true);
                    try {
                        return fn.apply(this, arguments);
                    }
                    finally {
                        switchToZone(outerZone, false);
                        if (cleanup)
                            queueMicrotask(decrementExpectedAwaits);
                    }
                };
            }
            function execInGlobalContext(cb) {
                if (Promise === NativePromise && task.echoes === 0) {
                    if (zoneEchoes === 0) {
                        cb();
                    }
                    else {
                        enqueueNativeMicroTask(cb);
                    }
                }
                else {
                    setTimeout(cb, 0);
                }
            }
            var rejection = DexiePromise.reject;

            function tempTransaction(db, mode, storeNames, fn) {
                if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
                    if (db._state.openComplete) {
                        return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
                    }
                    if (!db._state.isBeingOpened) {
                        if (!db._state.autoOpen)
                            return rejection(new exceptions.DatabaseClosed());
                        db.open().catch(nop);
                    }
                    return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });
                }
                else {
                    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
                    try {
                        trans.create();
                        db._state.PR1398_maxLoop = 3;
                    }
                    catch (ex) {
                        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                            console.warn('Dexie: Need to reopen db');
                            db.close({ disableAutoOpen: false });
                            return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });
                        }
                        return rejection(ex);
                    }
                    return trans._promise(mode, function (resolve, reject) {
                        return newScope(function () {
                            PSD.trans = trans;
                            return fn(resolve, reject, trans);
                        });
                    }).then(function (result) {
                        if (mode === 'readwrite')
                            try {
                                trans.idbtrans.commit();
                            }
                            catch (_a) { }
                        return mode === 'readonly' ? result : trans._completion.then(function () { return result; });
                    });
                }
            }

            var DEXIE_VERSION = '4.3.0';
            var maxString = String.fromCharCode(65535);
            var minKey = -Infinity;
            var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
            var STRING_EXPECTED = "String expected.";
            var connections = [];
            var DBNAMES_DB = '__dbnames';
            var READONLY = 'readonly';
            var READWRITE = 'readwrite';

            function combine(filter1, filter2) {
                return filter1 ?
                    filter2 ?
                        function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                        filter1 :
                    filter2;
            }

            var AnyRange = {
                type: 3,
                lower: -Infinity,
                lowerOpen: false,
                upper: [[]],
                upperOpen: false
            };

            function workaroundForUndefinedPrimKey(keyPath) {
                return typeof keyPath === "string" && !/\./.test(keyPath)
                    ? function (obj) {
                        if (obj[keyPath] === undefined && (keyPath in obj)) {
                            obj = deepClone(obj);
                            delete obj[keyPath];
                        }
                        return obj;
                    }
                    : function (obj) { return obj; };
            }

            function Entity() {
                throw exceptions.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
            }

            function cmp(a, b) {
                try {
                    var ta = type(a);
                    var tb = type(b);
                    if (ta !== tb) {
                        if (ta === 'Array')
                            return 1;
                        if (tb === 'Array')
                            return -1;
                        if (ta === 'binary')
                            return 1;
                        if (tb === 'binary')
                            return -1;
                        if (ta === 'string')
                            return 1;
                        if (tb === 'string')
                            return -1;
                        if (ta === 'Date')
                            return 1;
                        if (tb !== 'Date')
                            return NaN;
                        return -1;
                    }
                    switch (ta) {
                        case 'number':
                        case 'Date':
                        case 'string':
                            return a > b ? 1 : a < b ? -1 : 0;
                        case 'binary': {
                            return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                        }
                        case 'Array':
                            return compareArrays(a, b);
                    }
                }
                catch (_a) { }
                return NaN;
            }
            function compareArrays(a, b) {
                var al = a.length;
                var bl = b.length;
                var l = al < bl ? al : bl;
                for (var i = 0; i < l; ++i) {
                    var res = cmp(a[i], b[i]);
                    if (res !== 0)
                        return res;
                }
                return al === bl ? 0 : al < bl ? -1 : 1;
            }
            function compareUint8Arrays(a, b) {
                var al = a.length;
                var bl = b.length;
                var l = al < bl ? al : bl;
                for (var i = 0; i < l; ++i) {
                    if (a[i] !== b[i])
                        return a[i] < b[i] ? -1 : 1;
                }
                return al === bl ? 0 : al < bl ? -1 : 1;
            }
            function type(x) {
                var t = typeof x;
                if (t !== 'object')
                    return t;
                if (ArrayBuffer.isView(x))
                    return 'binary';
                var tsTag = toStringTag(x);
                return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
            }
            function getUint8Array(a) {
                if (a instanceof Uint8Array)
                    return a;
                if (ArrayBuffer.isView(a))
                    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
                return new Uint8Array(a);
            }

            function builtInDeletionTrigger(table, keys, res) {
                var yProps = table.schema.yProps;
                if (!yProps)
                    return res;
                if (keys && res.numFailures > 0)
                    keys = keys.filter(function (_, i) { return !res.failures[i]; });
                return Promise.all(yProps.map(function (_a) {
                    var updatesTable = _a.updatesTable;
                    return keys
                        ? table.db.table(updatesTable).where('k').anyOf(keys).delete()
                        : table.db.table(updatesTable).clear();
                })).then(function () { return res; });
            }

            var PropModification = (function () {
                function PropModification(spec) {
                    this["@@propmod"] = spec;
                }
                PropModification.prototype.execute = function (value) {
                    var _a;
                    var spec = this["@@propmod"];
                    if (spec.add !== undefined) {
                        var term = spec.add;
                        if (isArray(term)) {
                            return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();
                        }
                        if (typeof term === 'number')
                            return (Number(value) || 0) + term;
                        if (typeof term === 'bigint') {
                            try {
                                return BigInt(value) + term;
                            }
                            catch (_b) {
                                return BigInt(0) + term;
                            }
                        }
                        throw new TypeError("Invalid term ".concat(term));
                    }
                    if (spec.remove !== undefined) {
                        var subtrahend_1 = spec.remove;
                        if (isArray(subtrahend_1)) {
                            return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];
                        }
                        if (typeof subtrahend_1 === 'number')
                            return Number(value) - subtrahend_1;
                        if (typeof subtrahend_1 === 'bigint') {
                            try {
                                return BigInt(value) - subtrahend_1;
                            }
                            catch (_c) {
                                return BigInt(0) - subtrahend_1;
                            }
                        }
                        throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
                    }
                    var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];
                    if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {
                        return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
                    }
                    return value;
                };
                return PropModification;
            }());

            function applyUpdateSpec(obj, changes) {
                var keyPaths = keys(changes);
                var numKeys = keyPaths.length;
                var anythingModified = false;
                for (var i = 0; i < numKeys; ++i) {
                    var keyPath = keyPaths[i];
                    var value = changes[keyPath];
                    var origValue = getByKeyPath(obj, keyPath);
                    if (value instanceof PropModification) {
                        setByKeyPath(obj, keyPath, value.execute(origValue));
                        anythingModified = true;
                    }
                    else if (origValue !== value) {
                        setByKeyPath(obj, keyPath, value);
                        anythingModified = true;
                    }
                }
                return anythingModified;
            }

            var Table = (function () {
                function Table() {
                }
                Table.prototype._trans = function (mode, fn, writeLocked) {
                    var trans = this._tx || PSD.trans;
                    var tableName = this.name;
                    var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask("Dexie: ".concat(mode === 'readonly' ? 'read' : 'write', " ").concat(this.name));
                    function checkTableInTransaction(resolve, reject, trans) {
                        if (!trans.schema[tableName])
                            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                        return fn(trans.idbtrans, trans);
                    }
                    var wasRootExec = beginMicroTickScope();
                    try {
                        var p = trans && trans.db._novip === this.db._novip ?
                            trans === PSD.trans ?
                                trans._promise(mode, checkTableInTransaction, writeLocked) :
                                newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :
                            tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
                        if (task) {
                            p._consoleTask = task;
                            p = p.catch(function (err) {
                                console.trace(err);
                                return rejection(err);
                            });
                        }
                        return p;
                    }
                    finally {
                        if (wasRootExec)
                            endMicroTickScope();
                    }
                };
                Table.prototype.get = function (keyOrCrit, cb) {
                    var _this = this;
                    if (keyOrCrit && keyOrCrit.constructor === Object)
                        return this.where(keyOrCrit).first(cb);
                    if (keyOrCrit == null)
                        return rejection(new exceptions.Type("Invalid argument to Table.get()"));
                    return this._trans('readonly', function (trans) {
                        return _this.core.get({ trans: trans, key: keyOrCrit })
                            .then(function (res) { return _this.hook.reading.fire(res); });
                    }).then(cb);
                };
                Table.prototype.where = function (indexOrCrit) {
                    if (typeof indexOrCrit === 'string')
                        return new this.db.WhereClause(this, indexOrCrit);
                    if (isArray(indexOrCrit))
                        return new this.db.WhereClause(this, "[".concat(indexOrCrit.join('+'), "]"));
                    var keyPaths = keys(indexOrCrit);
                    if (keyPaths.length === 1)
                        return this
                            .where(keyPaths[0])
                            .equals(indexOrCrit[keyPaths[0]]);
                    var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                        if (ix.compound &&
                            keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {
                            for (var i = 0; i < keyPaths.length; ++i) {
                                if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                                    return false;
                            }
                            return true;
                        }
                        return false;
                    }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];
                    if (compoundIndex && this.db._maxKey !== maxString) {
                        var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
                        return this
                            .where(keyPathsInValidOrder)
                            .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));
                    }
                    if (!compoundIndex && debug)
                        console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") +
                            "compound index [".concat(keyPaths.join('+'), "]"));
                    var idxByName = this.schema.idxByName;
                    function equals(a, b) {
                        return cmp(a, b) === 0;
                    }
                    var _a = keyPaths.reduce(function (_a, keyPath) {
                        var prevIndex = _a[0], prevFilterFn = _a[1];
                        var index = idxByName[keyPath];
                        var value = indexOrCrit[keyPath];
                        return [
                            prevIndex || index,
                            prevIndex || !index ?
                                combine(prevFilterFn, index && index.multi ?
                                    function (x) {
                                        var prop = getByKeyPath(x, keyPath);
                                        return isArray(prop) && prop.some(function (item) { return equals(value, item); });
                                    } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })
                                : prevFilterFn
                        ];
                    }, [null, null]), idx = _a[0], filterFunction = _a[1];
                    return idx ?
                        this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                            .filter(filterFunction) :
                        compoundIndex ?
                            this.filter(filterFunction) :
                            this.where(keyPaths).equals('');
                };
                Table.prototype.filter = function (filterFunction) {
                    return this.toCollection().and(filterFunction);
                };
                Table.prototype.count = function (thenShortcut) {
                    return this.toCollection().count(thenShortcut);
                };
                Table.prototype.offset = function (offset) {
                    return this.toCollection().offset(offset);
                };
                Table.prototype.limit = function (numRows) {
                    return this.toCollection().limit(numRows);
                };
                Table.prototype.each = function (callback) {
                    return this.toCollection().each(callback);
                };
                Table.prototype.toArray = function (thenShortcut) {
                    return this.toCollection().toArray(thenShortcut);
                };
                Table.prototype.toCollection = function () {
                    return new this.db.Collection(new this.db.WhereClause(this));
                };
                Table.prototype.orderBy = function (index) {
                    return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
                        "[".concat(index.join('+'), "]") :
                        index));
                };
                Table.prototype.reverse = function () {
                    return this.toCollection().reverse();
                };
                Table.prototype.mapToClass = function (constructor) {
                    var _a = this, db = _a.db, tableName = _a.name;
                    this.schema.mappedClass = constructor;
                    if (constructor.prototype instanceof Entity) {
                        constructor = (function (_super) {
                            __extends(class_1, _super);
                            function class_1() {
                                return _super !== null && _super.apply(this, arguments) || this;
                            }
                            Object.defineProperty(class_1.prototype, "db", {
                                get: function () { return db; },
                                enumerable: false,
                                configurable: true
                            });
                            class_1.prototype.table = function () { return tableName; };
                            return class_1;
                        }(constructor));
                    }
                    var inheritedProps = new Set();
                    for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
                        Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });
                    }
                    var readHook = function (obj) {
                        if (!obj)
                            return obj;
                        var res = Object.create(constructor.prototype);
                        for (var m in obj)
                            if (!inheritedProps.has(m))
                                try {
                                    res[m] = obj[m];
                                }
                                catch (_) { }
                        return res;
                    };
                    if (this.schema.readHook) {
                        this.hook.reading.unsubscribe(this.schema.readHook);
                    }
                    this.schema.readHook = readHook;
                    this.hook("reading", readHook);
                    return constructor;
                };
                Table.prototype.defineClass = function () {
                    function Class(content) {
                        extend(this, content);
                    }
                    return this.mapToClass(Class);
                };
                Table.prototype.add = function (obj, key) {
                    var _this = this;
                    var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                    var objToAdd = obj;
                    if (keyPath && auto) {
                        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
                    }
                    return this._trans('readwrite', function (trans) {
                        return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
                    }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                        .then(function (lastResult) {
                            if (keyPath) {
                                try {
                                    setByKeyPath(obj, keyPath, lastResult);
                                }
                                catch (_) { }
                            }
                            return lastResult;
                        });
                };
                Table.prototype.upsert = function (key, modifications) {
                    var _this = this;
                    var keyPath = this.schema.primKey.keyPath;
                    return this._trans('readwrite', function (trans) {
                        return _this.core.get({ trans: trans, key: key }).then(function (existing) {
                            var obj = existing !== null && existing !== void 0 ? existing : {};
                            applyUpdateSpec(obj, modifications);
                            if (keyPath)
                                setByKeyPath(obj, keyPath, key);
                            return _this.core.mutate({
                                trans: trans,
                                type: 'put',
                                values: [obj],
                                keys: [key],
                                upsert: true,
                                updates: { keys: [key], changeSpecs: [modifications] }
                            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : !!existing; });
                        });
                    });
                };
                Table.prototype.update = function (keyOrObject, modifications) {
                    if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                        var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                        if (key === undefined)
                            return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                        return this.where(":id").equals(key).modify(modifications);
                    }
                    else {
                        return this.where(":id").equals(keyOrObject).modify(modifications);
                    }
                };
                Table.prototype.put = function (obj, key) {
                    var _this = this;
                    var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                    var objToAdd = obj;
                    if (keyPath && auto) {
                        objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
                    }
                    return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })
                        .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                        .then(function (lastResult) {
                            if (keyPath) {
                                try {
                                    setByKeyPath(obj, keyPath, lastResult);
                                }
                                catch (_) { }
                            }
                            return lastResult;
                        });
                };
                Table.prototype.delete = function (key) {
                    var _this = this;
                    return this._trans('readwrite', function (trans) {
                        return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] })
                            .then(function (res) { return builtInDeletionTrigger(_this, [key], res); })
                            .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
                    });
                };
                Table.prototype.clear = function () {
                    var _this = this;
                    return this._trans('readwrite', function (trans) {
                        return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange })
                            .then(function (res) { return builtInDeletionTrigger(_this, null, res); });
                    })
                        .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
                };
                Table.prototype.bulkGet = function (keys) {
                    var _this = this;
                    return this._trans('readonly', function (trans) {
                        return _this.core.getMany({
                            keys: keys,
                            trans: trans
                        }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });
                    });
                };
                Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
                    var _this = this;
                    var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
                    options = options || (keys ? undefined : keysOrOptions);
                    var wantResults = options ? options.allKeys : undefined;
                    return this._trans('readwrite', function (trans) {
                        var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                        if (keyPath && keys)
                            throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                        if (keys && keys.length !== objects.length)
                            throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                        var numObjects = objects.length;
                        var objectsToAdd = keyPath && auto ?
                            objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                            objects;
                        return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })
                            .then(function (_a) {
                                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                                var result = wantResults ? results : lastResult;
                                if (numFailures === 0)
                                    return result;
                                throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                            });
                    });
                };
                Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
                    var _this = this;
                    var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
                    options = options || (keys ? undefined : keysOrOptions);
                    var wantResults = options ? options.allKeys : undefined;
                    return this._trans('readwrite', function (trans) {
                        var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                        if (keyPath && keys)
                            throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                        if (keys && keys.length !== objects.length)
                            throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                        var numObjects = objects.length;
                        var objectsToPut = keyPath && auto ?
                            objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                            objects;
                        return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })
                            .then(function (_a) {
                                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                                var result = wantResults ? results : lastResult;
                                if (numFailures === 0)
                                    return result;
                                throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                            });
                    });
                };
                Table.prototype.bulkUpdate = function (keysAndChanges) {
                    var _this = this;
                    var coreTable = this.core;
                    var keys = keysAndChanges.map(function (entry) { return entry.key; });
                    var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });
                    var offsetMap = [];
                    return this._trans('readwrite', function (trans) {
                        return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {
                            var resultKeys = [];
                            var resultObjs = [];
                            keysAndChanges.forEach(function (_a, idx) {
                                var key = _a.key, changes = _a.changes;
                                var obj = objs[idx];
                                if (obj) {
                                    for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                                        var keyPath = _b[_i];
                                        var value = changes[keyPath];
                                        if (keyPath === _this.schema.primKey.keyPath) {
                                            if (cmp(value, key) !== 0) {
                                                throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                                            }
                                        }
                                        else {
                                            setByKeyPath(obj, keyPath, value);
                                        }
                                    }
                                    offsetMap.push(idx);
                                    resultKeys.push(key);
                                    resultObjs.push(obj);
                                }
                            });
                            var numEntries = resultKeys.length;
                            return coreTable
                                .mutate({
                                    trans: trans,
                                    type: 'put',
                                    keys: resultKeys,
                                    values: resultObjs,
                                    updates: {
                                        keys: keys,
                                        changeSpecs: changeSpecs
                                    }
                                })
                                .then(function (_a) {
                                    var numFailures = _a.numFailures, failures = _a.failures;
                                    if (numFailures === 0)
                                        return numEntries;
                                    for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                                        var offset = _b[_i];
                                        var mappedOffset = offsetMap[Number(offset)];
                                        if (mappedOffset != null) {
                                            var failure = failures[offset];
                                            delete failures[offset];
                                            failures[mappedOffset] = failure;
                                        }
                                    }
                                    throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                                });
                        });
                    });
                };
                Table.prototype.bulkDelete = function (keys) {
                    var _this = this;
                    var numKeys = keys.length;
                    return this._trans('readwrite', function (trans) {
                        return _this.core.mutate({ trans: trans, type: 'delete', keys: keys })
                            .then(function (res) { return builtInDeletionTrigger(_this, keys, res); });
                    }).then(function (_a) {
                        var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                        if (numFailures === 0)
                            return lastResult;
                        throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
                    });
                };
                return Table;
            }());

            function Events(ctx) {
                var evs = {};
                var rv = function (eventName, subscriber) {
                    if (subscriber) {
                        var i = arguments.length, args = new Array(i - 1);
                        while (--i)
                            args[i - 1] = arguments[i];
                        evs[eventName].subscribe.apply(null, args);
                        return ctx;
                    }
                    else if (typeof (eventName) === 'string') {
                        return evs[eventName];
                    }
                };
                rv.addEventType = add;
                for (var i = 1, l = arguments.length; i < l; ++i) {
                    add(arguments[i]);
                }
                return rv;
                function add(eventName, chainFunction, defaultFunction) {
                    if (typeof eventName === 'object')
                        return addConfiguredEvents(eventName);
                    if (!chainFunction)
                        chainFunction = reverseStoppableEventChain;
                    if (!defaultFunction)
                        defaultFunction = nop;
                    var context = {
                        subscribers: [],
                        fire: defaultFunction,
                        subscribe: function (cb) {
                            if (context.subscribers.indexOf(cb) === -1) {
                                context.subscribers.push(cb);
                                context.fire = chainFunction(context.fire, cb);
                            }
                        },
                        unsubscribe: function (cb) {
                            context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                            context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                        }
                    };
                    evs[eventName] = rv[eventName] = context;
                    return context;
                }
                function addConfiguredEvents(cfg) {
                    keys(cfg).forEach(function (eventName) {
                        var args = cfg[eventName];
                        if (isArray(args)) {
                            add(eventName, cfg[eventName][0], cfg[eventName][1]);
                        }
                        else if (args === 'asap') {
                            var context = add(eventName, mirror, function fire() {
                                var i = arguments.length, args = new Array(i);
                                while (i--)
                                    args[i] = arguments[i];
                                context.subscribers.forEach(function (fn) {
                                    asap$1(function fireEvent() {
                                        fn.apply(null, args);
                                    });
                                });
                            });
                        }
                        else
                            throw new exceptions.InvalidArgument("Invalid event config");
                    });
                }
            }

            function makeClassConstructor(prototype, constructor) {
                derive(constructor).from({ prototype: prototype });
                return constructor;
            }

            function createTableConstructor(db) {
                return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
                    this.db = db;
                    this._tx = trans;
                    this.name = name;
                    this.schema = tableSchema;
                    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                        "creating": [hookCreatingChain, nop],
                        "reading": [pureFunctionChain, mirror],
                        "updating": [hookUpdatingChain, nop],
                        "deleting": [hookDeletingChain, nop]
                    });
                });
            }

            function isPlainKeyRange(ctx, ignoreLimitFilter) {
                return !(ctx.filter || ctx.algorithm || ctx.or) &&
                    (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
            }
            function addFilter(ctx, fn) {
                ctx.filter = combine(ctx.filter, fn);
            }
            function addReplayFilter(ctx, factory, isLimitFilter) {
                var curr = ctx.replayFilter;
                ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;
                ctx.justLimit = isLimitFilter && !curr;
            }
            function addMatchFilter(ctx, fn) {
                ctx.isMatch = combine(ctx.isMatch, fn);
            }
            function getIndexOrStore(ctx, coreSchema) {
                if (ctx.isPrimKey)
                    return coreSchema.primaryKey;
                var index = coreSchema.getIndexByKeyPath(ctx.index);
                if (!index)
                    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
                return index;
            }
            function openCursor(ctx, coreTable, trans) {
                var index = getIndexOrStore(ctx, coreTable.schema);
                return coreTable.openCursor({
                    trans: trans,
                    values: !ctx.keysOnly,
                    reverse: ctx.dir === 'prev',
                    unique: !!ctx.unique,
                    query: {
                        index: index,
                        range: ctx.range
                    }
                });
            }
            function iter(ctx, fn, coreTrans, coreTable) {
                var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
                if (!ctx.or) {
                    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
                }
                else {
                    var set_1 = {};
                    var union = function (item, cursor, advance) {
                        if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {
                            var primaryKey = cursor.primaryKey;
                            var key = '' + primaryKey;
                            if (key === '[object ArrayBuffer]')
                                key = '' + new Uint8Array(primaryKey);
                            if (!hasOwn(set_1, key)) {
                                set_1[key] = true;
                                fn(item, cursor, advance);
                            }
                        }
                    };
                    return Promise.all([
                        ctx.or._iterate(union, coreTrans),
                        iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
                    ]);
                }
            }
            function iterate(cursorPromise, filter, fn, valueMapper) {
                var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;
                var wrappedFn = wrap(mappedFn);
                return cursorPromise.then(function (cursor) {
                    if (cursor) {
                        return cursor.start(function () {
                            var c = function () { return cursor.continue(); };
                            if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))
                                wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });
                            c();
                        });
                    }
                });
            }

            var Collection = (function () {
                function Collection() {
                }
                Collection.prototype._read = function (fn, cb) {
                    var ctx = this._ctx;
                    return ctx.error ?
                        ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                        ctx.table._trans('readonly', fn).then(cb);
                };
                Collection.prototype._write = function (fn) {
                    var ctx = this._ctx;
                    return ctx.error ?
                        ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                        ctx.table._trans('readwrite', fn, "locked");
                };
                Collection.prototype._addAlgorithm = function (fn) {
                    var ctx = this._ctx;
                    ctx.algorithm = combine(ctx.algorithm, fn);
                };
                Collection.prototype._iterate = function (fn, coreTrans) {
                    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
                };
                Collection.prototype.clone = function (props) {
                    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
                    if (props)
                        extend(ctx, props);
                    rv._ctx = ctx;
                    return rv;
                };
                Collection.prototype.raw = function () {
                    this._ctx.valueMapper = null;
                    return this;
                };
                Collection.prototype.each = function (fn) {
                    var ctx = this._ctx;
                    return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });
                };
                Collection.prototype.count = function (cb) {
                    var _this = this;
                    return this._read(function (trans) {
                        var ctx = _this._ctx;
                        var coreTable = ctx.table.core;
                        if (isPlainKeyRange(ctx, true)) {
                            return coreTable.count({
                                trans: trans,
                                query: {
                                    index: getIndexOrStore(ctx, coreTable.schema),
                                    range: ctx.range
                                }
                            }).then(function (count) { return Math.min(count, ctx.limit); });
                        }
                        else {
                            var count = 0;
                            return iter(ctx, function () { ++count; return false; }, trans, coreTable)
                                .then(function () { return count; });
                        }
                    }).then(cb);
                };
                Collection.prototype.sortBy = function (keyPath, cb) {
                    var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
                    function getval(obj, i) {
                        if (i)
                            return getval(obj[parts[i]], i - 1);
                        return obj[lastPart];
                    }
                    var order = this._ctx.dir === "next" ? 1 : -1;
                    function sorter(a, b) {
                        var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                        return cmp(aVal, bVal) * order;
                    }
                    return this.toArray(function (a) {
                        return a.sort(sorter);
                    }).then(cb);
                };
                Collection.prototype.toArray = function (cb) {
                    var _this = this;
                    return this._read(function (trans) {
                        var ctx = _this._ctx;
                        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                            var valueMapper_1 = ctx.valueMapper;
                            var index = getIndexOrStore(ctx, ctx.table.core.schema);
                            return ctx.table.core.query({
                                trans: trans,
                                limit: ctx.limit,
                                values: true,
                                query: {
                                    index: index,
                                    range: ctx.range
                                }
                            }).then(function (_a) {
                                var result = _a.result;
                                return valueMapper_1 ? result.map(valueMapper_1) : result;
                            });
                        }
                        else {
                            var a_1 = [];
                            return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });
                        }
                    }, cb);
                };
                Collection.prototype.offset = function (offset) {
                    var ctx = this._ctx;
                    if (offset <= 0)
                        return this;
                    ctx.offset += offset;
                    if (isPlainKeyRange(ctx)) {
                        addReplayFilter(ctx, function () {
                            var offsetLeft = offset;
                            return function (cursor, advance) {
                                if (offsetLeft === 0)
                                    return true;
                                if (offsetLeft === 1) {
                                    --offsetLeft;
                                    return false;
                                }
                                advance(function () {
                                    cursor.advance(offsetLeft);
                                    offsetLeft = 0;
                                });
                                return false;
                            };
                        });
                    }
                    else {
                        addReplayFilter(ctx, function () {
                            var offsetLeft = offset;
                            return function () { return (--offsetLeft < 0); };
                        });
                    }
                    return this;
                };
                Collection.prototype.limit = function (numRows) {
                    this._ctx.limit = Math.min(this._ctx.limit, numRows);
                    addReplayFilter(this._ctx, function () {
                        var rowsLeft = numRows;
                        return function (cursor, advance, resolve) {
                            if (--rowsLeft <= 0)
                                advance(resolve);
                            return rowsLeft >= 0;
                        };
                    }, true);
                    return this;
                };
                Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
                    addFilter(this._ctx, function (cursor, advance, resolve) {
                        if (filterFunction(cursor.value)) {
                            advance(resolve);
                            return bIncludeStopEntry;
                        }
                        else {
                            return true;
                        }
                    });
                    return this;
                };
                Collection.prototype.first = function (cb) {
                    return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
                };
                Collection.prototype.last = function (cb) {
                    return this.reverse().first(cb);
                };
                Collection.prototype.filter = function (filterFunction) {
                    addFilter(this._ctx, function (cursor) {
                        return filterFunction(cursor.value);
                    });
                    addMatchFilter(this._ctx, filterFunction);
                    return this;
                };
                Collection.prototype.and = function (filter) {
                    return this.filter(filter);
                };
                Collection.prototype.or = function (indexName) {
                    return new this.db.WhereClause(this._ctx.table, indexName, this);
                };
                Collection.prototype.reverse = function () {
                    this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
                    if (this._ondirectionchange)
                        this._ondirectionchange(this._ctx.dir);
                    return this;
                };
                Collection.prototype.desc = function () {
                    return this.reverse();
                };
                Collection.prototype.eachKey = function (cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    return this.each(function (val, cursor) { cb(cursor.key, cursor); });
                };
                Collection.prototype.eachUniqueKey = function (cb) {
                    this._ctx.unique = "unique";
                    return this.eachKey(cb);
                };
                Collection.prototype.eachPrimaryKey = function (cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
                };
                Collection.prototype.keys = function (cb) {
                    var ctx = this._ctx;
                    ctx.keysOnly = !ctx.isMatch;
                    var a = [];
                    return this.each(function (item, cursor) {
                        a.push(cursor.key);
                    }).then(function () {
                        return a;
                    }).then(cb);
                };
                Collection.prototype.primaryKeys = function (cb) {
                    var ctx = this._ctx;
                    if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                        return this._read(function (trans) {
                            var index = getIndexOrStore(ctx, ctx.table.core.schema);
                            return ctx.table.core.query({
                                trans: trans,
                                values: false,
                                limit: ctx.limit,
                                query: {
                                    index: index,
                                    range: ctx.range
                                }
                            });
                        }).then(function (_a) {
                            var result = _a.result;
                            return result;
                        }).then(cb);
                    }
                    ctx.keysOnly = !ctx.isMatch;
                    var a = [];
                    return this.each(function (item, cursor) {
                        a.push(cursor.primaryKey);
                    }).then(function () {
                        return a;
                    }).then(cb);
                };
                Collection.prototype.uniqueKeys = function (cb) {
                    this._ctx.unique = "unique";
                    return this.keys(cb);
                };
                Collection.prototype.firstKey = function (cb) {
                    return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
                };
                Collection.prototype.lastKey = function (cb) {
                    return this.reverse().firstKey(cb);
                };
                Collection.prototype.distinct = function () {
                    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
                    if (!idx || !idx.multi)
                        return this;
                    var set = {};
                    addFilter(this._ctx, function (cursor) {
                        var strKey = cursor.primaryKey.toString();
                        var found = hasOwn(set, strKey);
                        set[strKey] = true;
                        return !found;
                    });
                    return this;
                };
                Collection.prototype.modify = function (changes) {
                    var _this = this;
                    var ctx = this._ctx;
                    return this._write(function (trans) {
                        var modifyer;
                        if (typeof changes === 'function') {
                            modifyer = changes;
                        }
                        else {
                            modifyer = function (item) { return applyUpdateSpec(item, changes); };
                        }
                        var coreTable = ctx.table.core;
                        var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                        var limit = 200;
                        var modifyChunkSize = _this.db._options.modifyChunkSize;
                        if (modifyChunkSize) {
                            if (typeof modifyChunkSize == 'object') {
                                limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;
                            }
                            else {
                                limit = modifyChunkSize;
                            }
                        }
                        var totalFailures = [];
                        var successCount = 0;
                        var failedKeys = [];
                        var applyMutateResult = function (expectedCount, res) {
                            var failures = res.failures, numFailures = res.numFailures;
                            successCount += expectedCount - numFailures;
                            for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
                                var pos = _a[_i];
                                totalFailures.push(failures[pos]);
                            }
                        };
                        var isUnconditionalDelete = changes === deleteCallback;
                        return _this.clone().primaryKeys().then(function (keys) {
                            var criteria = isPlainKeyRange(ctx) &&
                                ctx.limit === Infinity &&
                                (typeof changes !== 'function' || isUnconditionalDelete) && {
                                index: ctx.index,
                                range: ctx.range
                            };
                            var nextChunk = function (offset) {
                                var count = Math.min(limit, keys.length - offset);
                                var keysInChunk = keys.slice(offset, offset + count);
                                return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({
                                    trans: trans,
                                    keys: keysInChunk,
                                    cache: "immutable"
                                })).then(function (values) {
                                    var addValues = [];
                                    var putValues = [];
                                    var putKeys = outbound ? [] : null;
                                    var deleteKeys = isUnconditionalDelete ? keysInChunk : [];
                                    if (!isUnconditionalDelete)
                                        for (var i = 0; i < count; ++i) {
                                            var origValue = values[i];
                                            var ctx_1 = {
                                                value: deepClone(origValue),
                                                primKey: keys[offset + i]
                                            };
                                            if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                                if (ctx_1.value == null) {
                                                    deleteKeys.push(keys[offset + i]);
                                                }
                                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                                    deleteKeys.push(keys[offset + i]);
                                                    addValues.push(ctx_1.value);
                                                }
                                                else {
                                                    putValues.push(ctx_1.value);
                                                    if (outbound)
                                                        putKeys.push(keys[offset + i]);
                                                }
                                            }
                                        }
                                    return Promise.resolve(addValues.length > 0 &&
                                        coreTable.mutate({ trans: trans, type: 'add', values: addValues })
                                            .then(function (res) {
                                                for (var pos in res.failures) {
                                                    deleteKeys.splice(parseInt(pos), 1);
                                                }
                                                applyMutateResult(addValues.length, res);
                                            })).then(function () {
                                                return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                                                    coreTable.mutate({
                                                        trans: trans,
                                                        type: 'put',
                                                        keys: putKeys,
                                                        values: putValues,
                                                        criteria: criteria,
                                                        changeSpec: typeof changes !== 'function'
                                                            && changes,
                                                        isAdditionalChunk: offset > 0
                                                    }).then(function (res) { return applyMutateResult(putValues.length, res); });
                                            }).then(function () {
                                                return (deleteKeys.length > 0 || (criteria && isUnconditionalDelete)) &&
                                                    coreTable.mutate({
                                                        trans: trans,
                                                        type: 'delete',
                                                        keys: deleteKeys,
                                                        criteria: criteria,
                                                        isAdditionalChunk: offset > 0
                                                    }).then(function (res) { return builtInDeletionTrigger(ctx.table, deleteKeys, res); })
                                                        .then(function (res) { return applyMutateResult(deleteKeys.length, res); });
                                            }).then(function () {
                                                return keys.length > offset + count && nextChunk(offset + limit);
                                            });
                                });
                            };
                            return nextChunk(0).then(function () {
                                if (totalFailures.length > 0)
                                    throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                                return keys.length;
                            });
                        });
                    });
                };
                Collection.prototype.delete = function () {
                    var ctx = this._ctx, range = ctx.range;
                    if (isPlainKeyRange(ctx) &&
                        !ctx.table.schema.yProps &&
                        (ctx.isPrimKey || range.type === 3)) {
                        return this._write(function (trans) {
                            var primaryKey = ctx.table.core.schema.primaryKey;
                            var coreRange = range;
                            return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {
                                return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })
                                    .then(function (_a) {
                                        var failures = _a.failures, numFailures = _a.numFailures;
                                        if (numFailures)
                                            throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);
                                        return count - numFailures;
                                    });
                            });
                        });
                    }
                    return this.modify(deleteCallback);
                };
                return Collection;
            }());
            var deleteCallback = function (value, ctx) { return ctx.value = null; };

            function createCollectionConstructor(db) {
                return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
                    this.db = db;
                    var keyRange = AnyRange, error = null;
                    if (keyRangeGenerator)
                        try {
                            keyRange = keyRangeGenerator();
                        }
                        catch (ex) {
                            error = ex;
                        }
                    var whereCtx = whereClause._ctx;
                    var table = whereCtx.table;
                    var readingHook = table.hook.reading.fire;
                    this._ctx = {
                        table: table,
                        index: whereCtx.index,
                        isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                        range: keyRange,
                        keysOnly: false,
                        dir: "next",
                        unique: "",
                        algorithm: null,
                        filter: null,
                        replayFilter: null,
                        justLimit: true,
                        isMatch: null,
                        offset: 0,
                        limit: Infinity,
                        error: error,
                        or: whereCtx.or,
                        valueMapper: readingHook !== mirror ? readingHook : null
                    };
                });
            }

            function simpleCompare(a, b) {
                return a < b ? -1 : a === b ? 0 : 1;
            }
            function simpleCompareReverse(a, b) {
                return a > b ? -1 : a === b ? 0 : 1;
            }

            function fail(collectionOrWhereClause, err, T) {
                var collection = collectionOrWhereClause instanceof WhereClause ?
                    new collectionOrWhereClause.Collection(collectionOrWhereClause) :
                    collectionOrWhereClause;
                collection._ctx.error = T ? new T(err) : new TypeError(err);
                return collection;
            }
            function emptyCollection(whereClause) {
                return new whereClause.Collection(whereClause, function () { return rangeEqual(""); }).limit(0);
            }
            function upperFactory(dir) {
                return dir === "next" ?
                    function (s) { return s.toUpperCase(); } :
                    function (s) { return s.toLowerCase(); };
            }
            function lowerFactory(dir) {
                return dir === "next" ?
                    function (s) { return s.toLowerCase(); } :
                    function (s) { return s.toUpperCase(); };
            }
            function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
                var length = Math.min(key.length, lowerNeedle.length);
                var llp = -1;
                for (var i = 0; i < length; ++i) {
                    var lwrKeyChar = lowerKey[i];
                    if (lwrKeyChar !== lowerNeedle[i]) {
                        if (cmp(key[i], upperNeedle[i]) < 0)
                            return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                        if (cmp(key[i], lowerNeedle[i]) < 0)
                            return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                        if (llp >= 0)
                            return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                        return null;
                    }
                    if (cmp(key[i], lwrKeyChar) < 0)
                        llp = i;
                }
                if (length < lowerNeedle.length && dir === "next")
                    return key + upperNeedle.substr(key.length);
                if (length < key.length && dir === "prev")
                    return key.substr(0, upperNeedle.length);
                return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
            }
            function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
                var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
                if (!needles.every(function (s) { return typeof s === 'string'; })) {
                    return fail(whereClause, STRING_EXPECTED);
                }
                function initDirection(dir) {
                    upper = upperFactory(dir);
                    lower = lowerFactory(dir);
                    compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
                    var needleBounds = needles.map(function (needle) {
                        return { lower: lower(needle), upper: upper(needle) };
                    }).sort(function (a, b) {
                        return compare(a.lower, b.lower);
                    });
                    upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
                    lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
                    direction = dir;
                    nextKeySuffix = (dir === "next" ? "" : suffix);
                }
                initDirection("next");
                var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });
                c._ondirectionchange = function (direction) {
                    initDirection(direction);
                };
                var firstPossibleNeedle = 0;
                c._addAlgorithm(function (cursor, advance, resolve) {
                    var key = cursor.key;
                    if (typeof key !== 'string')
                        return false;
                    var lowerKey = lower(key);
                    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                        return true;
                    }
                    else {
                        var lowestPossibleCasing = null;
                        for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                            var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                            if (casing === null && lowestPossibleCasing === null)
                                firstPossibleNeedle = i + 1;
                            else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                                lowestPossibleCasing = casing;
                            }
                        }
                        if (lowestPossibleCasing !== null) {
                            advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                        }
                        else {
                            advance(resolve);
                        }
                        return false;
                    }
                });
                return c;
            }
            function createRange(lower, upper, lowerOpen, upperOpen) {
                return {
                    type: 2,
                    lower: lower,
                    upper: upper,
                    lowerOpen: lowerOpen,
                    upperOpen: upperOpen
                };
            }
            function rangeEqual(value) {
                return {
                    type: 1,
                    lower: value,
                    upper: value
                };
            }

            var WhereClause = (function () {
                function WhereClause() {
                }
                Object.defineProperty(WhereClause.prototype, "Collection", {
                    get: function () {
                        return this._ctx.table.db.Collection;
                    },
                    enumerable: false,
                    configurable: true
                });
                WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
                    includeLower = includeLower !== false;
                    includeUpper = includeUpper === true;
                    try {
                        if ((this._cmp(lower, upper) > 0) ||
                            (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                            return emptyCollection(this);
                        return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });
                    }
                    catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                };
                WhereClause.prototype.equals = function (value) {
                    if (value == null)
                        return fail(this, INVALID_KEY_ARGUMENT);
                    return new this.Collection(this, function () { return rangeEqual(value); });
                };
                WhereClause.prototype.above = function (value) {
                    if (value == null)
                        return fail(this, INVALID_KEY_ARGUMENT);
                    return new this.Collection(this, function () { return createRange(value, undefined, true); });
                };
                WhereClause.prototype.aboveOrEqual = function (value) {
                    if (value == null)
                        return fail(this, INVALID_KEY_ARGUMENT);
                    return new this.Collection(this, function () { return createRange(value, undefined, false); });
                };
                WhereClause.prototype.below = function (value) {
                    if (value == null)
                        return fail(this, INVALID_KEY_ARGUMENT);
                    return new this.Collection(this, function () { return createRange(undefined, value, false, true); });
                };
                WhereClause.prototype.belowOrEqual = function (value) {
                    if (value == null)
                        return fail(this, INVALID_KEY_ARGUMENT);
                    return new this.Collection(this, function () { return createRange(undefined, value); });
                };
                WhereClause.prototype.startsWith = function (str) {
                    if (typeof str !== 'string')
                        return fail(this, STRING_EXPECTED);
                    return this.between(str, str + maxString, true, true);
                };
                WhereClause.prototype.startsWithIgnoreCase = function (str) {
                    if (str === "")
                        return this.startsWith(str);
                    return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);
                };
                WhereClause.prototype.equalsIgnoreCase = function (str) {
                    return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], "");
                };
                WhereClause.prototype.anyOfIgnoreCase = function () {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0)
                        return emptyCollection(this);
                    return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, "");
                };
                WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0)
                        return emptyCollection(this);
                    return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);
                };
                WhereClause.prototype.anyOf = function () {
                    var _this = this;
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    var compare = this._cmp;
                    try {
                        set.sort(compare);
                    }
                    catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    if (set.length === 0)
                        return emptyCollection(this);
                    var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });
                    c._ondirectionchange = function (direction) {
                        compare = (direction === "next" ?
                            _this._ascending :
                            _this._descending);
                        set.sort(compare);
                    };
                    var i = 0;
                    c._addAlgorithm(function (cursor, advance, resolve) {
                        var key = cursor.key;
                        while (compare(key, set[i]) > 0) {
                            ++i;
                            if (i === set.length) {
                                advance(resolve);
                                return false;
                            }
                        }
                        if (compare(key, set[i]) === 0) {
                            return true;
                        }
                        else {
                            advance(function () { cursor.continue(set[i]); });
                            return false;
                        }
                    });
                    return c;
                };
                WhereClause.prototype.notEqual = function (value) {
                    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
                };
                WhereClause.prototype.noneOf = function () {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (set.length === 0)
                        return new this.Collection(this);
                    try {
                        set.sort(this._ascending);
                    }
                    catch (e) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    var ranges = set.reduce(function (res, val) {
                        return res ?
                            res.concat([[res[res.length - 1][1], val]]) :
                            [[minKey, val]];
                    }, null);
                    ranges.push([set[set.length - 1], this.db._maxKey]);
                    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
                };
                WhereClause.prototype.inAnyRange = function (ranges, options) {
                    var _this = this;
                    var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
                    if (ranges.length === 0)
                        return emptyCollection(this);
                    if (!ranges.every(function (range) {
                        return range[0] !== undefined &&
                            range[1] !== undefined &&
                            ascending(range[0], range[1]) <= 0;
                    })) {
                        return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
                    }
                    var includeLowers = !options || options.includeLowers !== false;
                    var includeUppers = options && options.includeUppers === true;
                    function addRange(ranges, newRange) {
                        var i = 0, l = ranges.length;
                        for (; i < l; ++i) {
                            var range = ranges[i];
                            if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                                range[0] = min(range[0], newRange[0]);
                                range[1] = max(range[1], newRange[1]);
                                break;
                            }
                        }
                        if (i === l)
                            ranges.push(newRange);
                        return ranges;
                    }
                    var sortDirection = ascending;
                    function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
                    var set;
                    try {
                        set = ranges.reduce(addRange, []);
                        set.sort(rangeSorter);
                    }
                    catch (ex) {
                        return fail(this, INVALID_KEY_ARGUMENT);
                    }
                    var rangePos = 0;
                    var keyIsBeyondCurrentEntry = includeUppers ?
                        function (key) { return ascending(key, set[rangePos][1]) > 0; } :
                        function (key) { return ascending(key, set[rangePos][1]) >= 0; };
                    var keyIsBeforeCurrentEntry = includeLowers ?
                        function (key) { return descending(key, set[rangePos][0]) > 0; } :
                        function (key) { return descending(key, set[rangePos][0]) >= 0; };
                    function keyWithinCurrentRange(key) {
                        return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
                    }
                    var checkKey = keyIsBeyondCurrentEntry;
                    var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });
                    c._ondirectionchange = function (direction) {
                        if (direction === "next") {
                            checkKey = keyIsBeyondCurrentEntry;
                            sortDirection = ascending;
                        }
                        else {
                            checkKey = keyIsBeforeCurrentEntry;
                            sortDirection = descending;
                        }
                        set.sort(rangeSorter);
                    };
                    c._addAlgorithm(function (cursor, advance, resolve) {
                        var key = cursor.key;
                        while (checkKey(key)) {
                            ++rangePos;
                            if (rangePos === set.length) {
                                advance(resolve);
                                return false;
                            }
                        }
                        if (keyWithinCurrentRange(key)) {
                            return true;
                        }
                        else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                            return false;
                        }
                        else {
                            advance(function () {
                                if (sortDirection === ascending)
                                    cursor.continue(set[rangePos][0]);
                                else
                                    cursor.continue(set[rangePos][1]);
                            });
                            return false;
                        }
                    });
                    return c;
                };
                WhereClause.prototype.startsWithAnyOf = function () {
                    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
                    if (!set.every(function (s) { return typeof s === 'string'; })) {
                        return fail(this, "startsWithAnyOf() only works with strings");
                    }
                    if (set.length === 0)
                        return emptyCollection(this);
                    return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));
                };
                return WhereClause;
            }());

            function createWhereClauseConstructor(db) {
                return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
                    this.db = db;
                    this._ctx = {
                        table: table,
                        index: index === ":id" ? null : index,
                        or: orCollection
                    };
                    this._cmp = this._ascending = cmp;
                    this._descending = function (a, b) { return cmp(b, a); };
                    this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };
                    this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };
                    this._IDBKeyRange = db._deps.IDBKeyRange;
                    if (!this._IDBKeyRange)
                        throw new exceptions.MissingAPI();
                });
            }

            function eventRejectHandler(reject) {
                return wrap(function (event) {
                    preventDefault(event);
                    reject(event.target.error);
                    return false;
                });
            }
            function preventDefault(event) {
                if (event.stopPropagation)
                    event.stopPropagation();
                if (event.preventDefault)
                    event.preventDefault();
            }

            var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
            var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
            var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

            var Transaction = (function () {
                function Transaction() {
                }
                Transaction.prototype._lock = function () {
                    assert(!PSD.global);
                    ++this._reculock;
                    if (this._reculock === 1 && !PSD.global)
                        PSD.lockOwnerFor = this;
                    return this;
                };
                Transaction.prototype._unlock = function () {
                    assert(!PSD.global);
                    if (--this._reculock === 0) {
                        if (!PSD.global)
                            PSD.lockOwnerFor = null;
                        while (this._blockedFuncs.length > 0 && !this._locked()) {
                            var fnAndPSD = this._blockedFuncs.shift();
                            try {
                                usePSD(fnAndPSD[1], fnAndPSD[0]);
                            }
                            catch (e) { }
                        }
                    }
                    return this;
                };
                Transaction.prototype._locked = function () {
                    return this._reculock && PSD.lockOwnerFor !== this;
                };
                Transaction.prototype.create = function (idbtrans) {
                    var _this = this;
                    if (!this.mode)
                        return this;
                    var idbdb = this.db.idbdb;
                    var dbOpenError = this.db._state.dbOpenError;
                    assert(!this.idbtrans);
                    if (!idbtrans && !idbdb) {
                        switch (dbOpenError && dbOpenError.name) {
                            case "DatabaseClosedError":
                                throw new exceptions.DatabaseClosed(dbOpenError);
                            case "MissingAPIError":
                                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                            default:
                                throw new exceptions.OpenFailed(dbOpenError);
                        }
                    }
                    if (!this.active)
                        throw new exceptions.TransactionInactive();
                    assert(this._completion._state === null);
                    idbtrans = this.idbtrans = idbtrans ||
                        (this.db.core
                            ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                            : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
                    idbtrans.onerror = wrap(function (ev) {
                        preventDefault(ev);
                        _this._reject(idbtrans.error);
                    });
                    idbtrans.onabort = wrap(function (ev) {
                        preventDefault(ev);
                        _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                        _this.active = false;
                        _this.on("abort").fire(ev);
                    });
                    idbtrans.oncomplete = wrap(function () {
                        _this.active = false;
                        _this._resolve();
                        if ('mutatedParts' in idbtrans) {
                            globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                        }
                    });
                    return this;
                };
                Transaction.prototype._promise = function (mode, fn, bWriteLock) {
                    var _this = this;
                    if (mode === 'readwrite' && this.mode !== 'readwrite')
                        return rejection(new exceptions.ReadOnly("Transaction is readonly"));
                    if (!this.active)
                        return rejection(new exceptions.TransactionInactive());
                    if (this._locked()) {
                        return new DexiePromise(function (resolve, reject) {
                            _this._blockedFuncs.push([function () {
                                _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                            }, PSD]);
                        });
                    }
                    else if (bWriteLock) {
                        return newScope(function () {
                            var p = new DexiePromise(function (resolve, reject) {
                                _this._lock();
                                var rv = fn(resolve, reject, _this);
                                if (rv && rv.then)
                                    rv.then(resolve, reject);
                            });
                            p.finally(function () { return _this._unlock(); });
                            p._lib = true;
                            return p;
                        });
                    }
                    else {
                        var p = new DexiePromise(function (resolve, reject) {
                            var rv = fn(resolve, reject, _this);
                            if (rv && rv.then)
                                rv.then(resolve, reject);
                        });
                        p._lib = true;
                        return p;
                    }
                };
                Transaction.prototype._root = function () {
                    return this.parent ? this.parent._root() : this;
                };
                Transaction.prototype.waitFor = function (promiseLike) {
                    var root = this._root();
                    var promise = DexiePromise.resolve(promiseLike);
                    if (root._waitingFor) {
                        root._waitingFor = root._waitingFor.then(function () { return promise; });
                    }
                    else {
                        root._waitingFor = promise;
                        root._waitingQueue = [];
                        var store = root.idbtrans.objectStore(root.storeNames[0]);
                        (function spin() {
                            ++root._spinCount;
                            while (root._waitingQueue.length)
                                (root._waitingQueue.shift())();
                            if (root._waitingFor)
                                store.get(-Infinity).onsuccess = spin;
                        }());
                    }
                    var currentWaitPromise = root._waitingFor;
                    return new DexiePromise(function (resolve, reject) {
                        promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {
                            if (root._waitingFor === currentWaitPromise) {
                                root._waitingFor = null;
                            }
                        });
                    });
                };
                Transaction.prototype.abort = function () {
                    if (this.active) {
                        this.active = false;
                        if (this.idbtrans)
                            this.idbtrans.abort();
                        this._reject(new exceptions.Abort());
                    }
                };
                Transaction.prototype.table = function (tableName) {
                    var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
                    if (hasOwn(memoizedTables, tableName))
                        return memoizedTables[tableName];
                    var tableSchema = this.schema[tableName];
                    if (!tableSchema) {
                        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                    }
                    var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
                    transactionBoundTable.core = this.db.core.table(tableName);
                    memoizedTables[tableName] = transactionBoundTable;
                    return transactionBoundTable;
                };
                return Transaction;
            }());

            function createTransactionConstructor(db) {
                return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
                    var _this = this;
                    if (mode !== 'readonly')
                        storeNames.forEach(function (storeName) {
                            var _a;
                            var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;
                            if (yProps)
                                storeNames = storeNames.concat(yProps.map(function (p) { return p.updatesTable; }));
                        });
                    this.db = db;
                    this.mode = mode;
                    this.storeNames = storeNames;
                    this.schema = dbschema;
                    this.chromeTransactionDurability = chromeTransactionDurability;
                    this.idbtrans = null;
                    this.on = Events(this, "complete", "error", "abort");
                    this.parent = parent || null;
                    this.active = true;
                    this._reculock = 0;
                    this._blockedFuncs = [];
                    this._resolve = null;
                    this._reject = null;
                    this._waitingFor = null;
                    this._waitingQueue = null;
                    this._spinCount = 0;
                    this._completion = new DexiePromise(function (resolve, reject) {
                        _this._resolve = resolve;
                        _this._reject = reject;
                    });
                    this._completion.then(function () {
                        _this.active = false;
                        _this.on.complete.fire();
                    }, function (e) {
                        var wasActive = _this.active;
                        _this.active = false;
                        _this.on.error.fire(e);
                        _this.parent ?
                            _this.parent._reject(e) :
                            wasActive && _this.idbtrans && _this.idbtrans.abort();
                        return rejection(e);
                    });
                });
            }

            function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {
                return {
                    name: name,
                    keyPath: keyPath,
                    unique: unique,
                    multi: multi,
                    auto: auto,
                    compound: compound,
                    src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath),
                    type: type
                };
            }
            function nameFromKeyPath(keyPath) {
                return typeof keyPath === 'string' ?
                    keyPath :
                    keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
            }

            function createTableSchema(name, primKey, indexes) {
                return {
                    name: name,
                    primKey: primKey,
                    indexes: indexes,
                    mappedClass: null,
                    idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; }),
                };
            }

            function safariMultiStoreFix(storeNames) {
                return storeNames.length === 1 ? storeNames[0] : storeNames;
            }
            var getMaxKey = function (IdbKeyRange) {
                try {
                    IdbKeyRange.only([[]]);
                    getMaxKey = function () { return [[]]; };
                    return [[]];
                }
                catch (e) {
                    getMaxKey = function () { return maxString; };
                    return maxString;
                }
            };

            function getKeyExtractor(keyPath) {
                if (keyPath == null) {
                    return function () { return undefined; };
                }
                else if (typeof keyPath === 'string') {
                    return getSinglePathKeyExtractor(keyPath);
                }
                else {
                    return function (obj) { return getByKeyPath(obj, keyPath); };
                }
            }
            function getSinglePathKeyExtractor(keyPath) {
                var split = keyPath.split('.');
                if (split.length === 1) {
                    return function (obj) { return obj[keyPath]; };
                }
                else {
                    return function (obj) { return getByKeyPath(obj, keyPath); };
                }
            }

            function arrayify(arrayLike) {
                return [].slice.call(arrayLike);
            }
            var _id_counter = 0;
            function getKeyPathAlias(keyPath) {
                return keyPath == null ?
                    ":id" :
                    typeof keyPath === 'string' ?
                        keyPath :
                        "[".concat(keyPath.join('+'), "]");
            }
            function createDBCore(db, IdbKeyRange, tmpTrans) {
                function extractSchema(db, trans) {
                    var tables = arrayify(db.objectStoreNames);
                    return {
                        schema: {
                            name: db.name,
                            tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {
                                var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                                var compound = isArray(keyPath);
                                var outbound = keyPath == null;
                                var indexByKeyPath = {};
                                var result = {
                                    name: store.name,
                                    primaryKey: {
                                        name: null,
                                        isPrimaryKey: true,
                                        outbound: outbound,
                                        compound: compound,
                                        keyPath: keyPath,
                                        autoIncrement: autoIncrement,
                                        unique: true,
                                        extractKey: getKeyExtractor(keyPath)
                                    },
                                    indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })
                                        .map(function (index) {
                                            var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                            var compound = isArray(keyPath);
                                            var result = {
                                                name: name,
                                                compound: compound,
                                                keyPath: keyPath,
                                                unique: unique,
                                                multiEntry: multiEntry,
                                                extractKey: getKeyExtractor(keyPath)
                                            };
                                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                            return result;
                                        }),
                                    getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }
                                };
                                indexByKeyPath[":id"] = result.primaryKey;
                                if (keyPath != null) {
                                    indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                                }
                                return result;
                            })
                        },
                        hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                            !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                                !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                                [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
                    };
                }
                function makeIDBKeyRange(range) {
                    if (range.type === 3)
                        return null;
                    if (range.type === 4)
                        throw new Error("Cannot convert never type to IDBKeyRange");
                    var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
                    var idbRange = lower === undefined ?
                        upper === undefined ?
                            null :
                            IdbKeyRange.upperBound(upper, !!upperOpen) :
                        upper === undefined ?
                            IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                            IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
                    return idbRange;
                }
                function createDbCoreTable(tableSchema) {
                    var tableName = tableSchema.name;
                    function mutate(_a) {
                        var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
                        return new Promise(function (resolve, reject) {
                            resolve = wrap(resolve);
                            var store = trans.objectStore(tableName);
                            var outbound = store.keyPath == null;
                            var isAddOrPut = type === "put" || type === "add";
                            if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                                throw new Error("Invalid operation type: " + type);
                            var length = (keys || values || { length: 1 }).length;
                            if (keys && values && keys.length !== values.length) {
                                throw new Error("Given keys array must have same length as given values array.");
                            }
                            if (length === 0)
                                return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                            var req;
                            var reqs = [];
                            var failures = [];
                            var numFailures = 0;
                            var errorHandler = function (event) {
                                ++numFailures;
                                preventDefault(event);
                            };
                            if (type === 'deleteRange') {
                                if (range.type === 4)
                                    return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });
                                if (range.type === 3)
                                    reqs.push(req = store.clear());
                                else
                                    reqs.push(req = store.delete(makeIDBKeyRange(range)));
                            }
                            else {
                                var _a = isAddOrPut ?
                                    outbound ?
                                        [values, keys] :
                                        [values, null] :
                                    [keys, null], args1 = _a[0], args2 = _a[1];
                                if (isAddOrPut) {
                                    for (var i = 0; i < length; ++i) {
                                        reqs.push(req = (args2 && args2[i] !== undefined ?
                                            store[type](args1[i], args2[i]) :
                                            store[type](args1[i])));
                                        req.onerror = errorHandler;
                                    }
                                }
                                else {
                                    for (var i = 0; i < length; ++i) {
                                        reqs.push(req = store[type](args1[i]));
                                        req.onerror = errorHandler;
                                    }
                                }
                            }
                            var done = function (event) {
                                var lastResult = event.target.result;
                                reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });
                                resolve({
                                    numFailures: numFailures,
                                    failures: failures,
                                    results: type === "delete" ? keys : reqs.map(function (req) { return req.result; }),
                                    lastResult: lastResult
                                });
                            };
                            req.onerror = function (event) {
                                errorHandler(event);
                                done(event);
                            };
                            req.onsuccess = done;
                        });
                    }
                    function openCursor(_a) {
                        var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                        return new Promise(function (resolve, reject) {
                            resolve = wrap(resolve);
                            var index = query.index, range = query.range;
                            var store = trans.objectStore(tableName);
                            var source = index.isPrimaryKey ?
                                store :
                                store.index(index.name);
                            var direction = reverse ?
                                unique ?
                                    "prevunique" :
                                    "prev" :
                                unique ?
                                    "nextunique" :
                                    "next";
                            var req = values || !('openKeyCursor' in source) ?
                                source.openCursor(makeIDBKeyRange(range), direction) :
                                source.openKeyCursor(makeIDBKeyRange(range), direction);
                            req.onerror = eventRejectHandler(reject);
                            req.onsuccess = wrap(function (ev) {
                                var cursor = req.result;
                                if (!cursor) {
                                    resolve(null);
                                    return;
                                }
                                cursor.___id = ++_id_counter;
                                cursor.done = false;
                                var _cursorContinue = cursor.continue.bind(cursor);
                                var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                                if (_cursorContinuePrimaryKey)
                                    _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                                var _cursorAdvance = cursor.advance.bind(cursor);
                                var doThrowCursorIsNotStarted = function () { throw new Error("Cursor not started"); };
                                var doThrowCursorIsStopped = function () { throw new Error("Cursor not stopped"); };
                                cursor.trans = trans;
                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                                cursor.fail = wrap(reject);
                                cursor.next = function () {
                                    var _this = this;
                                    var gotOne = 1;
                                    return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });
                                };
                                cursor.start = function (callback) {
                                    var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
                                        resolveIteration = wrap(resolveIteration);
                                        req.onerror = eventRejectHandler(rejectIteration);
                                        cursor.fail = rejectIteration;
                                        cursor.stop = function (value) {
                                            cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                            resolveIteration(value);
                                        };
                                    });
                                    var guardedCallback = function () {
                                        if (req.result) {
                                            try {
                                                callback();
                                            }
                                            catch (err) {
                                                cursor.fail(err);
                                            }
                                        }
                                        else {
                                            cursor.done = true;
                                            cursor.start = function () { throw new Error("Cursor behind last entry"); };
                                            cursor.stop();
                                        }
                                    };
                                    req.onsuccess = wrap(function (ev) {
                                        req.onsuccess = guardedCallback;
                                        guardedCallback();
                                    });
                                    cursor.continue = _cursorContinue;
                                    cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                                    cursor.advance = _cursorAdvance;
                                    guardedCallback();
                                    return iterationPromise;
                                };
                                resolve(cursor);
                            }, reject);
                        });
                    }
                    function query(hasGetAll) {
                        return function (request) {
                            return new Promise(function (resolve, reject) {
                                resolve = wrap(resolve);
                                var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                                var nonInfinitLimit = limit === Infinity ? undefined : limit;
                                var index = query.index, range = query.range;
                                var store = trans.objectStore(tableName);
                                var source = index.isPrimaryKey ? store : store.index(index.name);
                                var idbKeyRange = makeIDBKeyRange(range);
                                if (limit === 0)
                                    return resolve({ result: [] });
                                if (hasGetAll) {
                                    var req = values ?
                                        source.getAll(idbKeyRange, nonInfinitLimit) :
                                        source.getAllKeys(idbKeyRange, nonInfinitLimit);
                                    req.onsuccess = function (event) { return resolve({ result: event.target.result }); };
                                    req.onerror = eventRejectHandler(reject);
                                }
                                else {
                                    var count_1 = 0;
                                    var req_1 = values || !('openKeyCursor' in source) ?
                                        source.openCursor(idbKeyRange) :
                                        source.openKeyCursor(idbKeyRange);
                                    var result_1 = [];
                                    req_1.onsuccess = function (event) {
                                        var cursor = req_1.result;
                                        if (!cursor)
                                            return resolve({ result: result_1 });
                                        result_1.push(values ? cursor.value : cursor.primaryKey);
                                        if (++count_1 === limit)
                                            return resolve({ result: result_1 });
                                        cursor.continue();
                                    };
                                    req_1.onerror = eventRejectHandler(reject);
                                }
                            });
                        };
                    }
                    return {
                        name: tableName,
                        schema: tableSchema,
                        mutate: mutate,
                        getMany: function (_a) {
                            var trans = _a.trans, keys = _a.keys;
                            return new Promise(function (resolve, reject) {
                                resolve = wrap(resolve);
                                var store = trans.objectStore(tableName);
                                var length = keys.length;
                                var result = new Array(length);
                                var keyCount = 0;
                                var callbackCount = 0;
                                var req;
                                var successHandler = function (event) {
                                    var req = event.target;
                                    if ((result[req._pos] = req.result) != null)
                                        ;
                                    if (++callbackCount === keyCount)
                                        resolve(result);
                                };
                                var errorHandler = eventRejectHandler(reject);
                                for (var i = 0; i < length; ++i) {
                                    var key = keys[i];
                                    if (key != null) {
                                        req = store.get(keys[i]);
                                        req._pos = i;
                                        req.onsuccess = successHandler;
                                        req.onerror = errorHandler;
                                        ++keyCount;
                                    }
                                }
                                if (keyCount === 0)
                                    resolve(result);
                            });
                        },
                        get: function (_a) {
                            var trans = _a.trans, key = _a.key;
                            return new Promise(function (resolve, reject) {
                                resolve = wrap(resolve);
                                var store = trans.objectStore(tableName);
                                var req = store.get(key);
                                req.onsuccess = function (event) { return resolve(event.target.result); };
                                req.onerror = eventRejectHandler(reject);
                            });
                        },
                        query: query(hasGetAll),
                        openCursor: openCursor,
                        count: function (_a) {
                            var query = _a.query, trans = _a.trans;
                            var index = query.index, range = query.range;
                            return new Promise(function (resolve, reject) {
                                var store = trans.objectStore(tableName);
                                var source = index.isPrimaryKey ? store : store.index(index.name);
                                var idbKeyRange = makeIDBKeyRange(range);
                                var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                                req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });
                                req.onerror = eventRejectHandler(reject);
                            });
                        }
                    };
                }
                var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
                var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });
                var tableMap = {};
                tables.forEach(function (table) { return tableMap[table.name] = table; });
                return {
                    stack: "dbcore",
                    transaction: db.transaction.bind(db),
                    table: function (name) {
                        var result = tableMap[name];
                        if (!result)
                            throw new Error("Table '".concat(name, "' not found"));
                        return tableMap[name];
                    },
                    MIN_KEY: -Infinity,
                    MAX_KEY: getMaxKey(IdbKeyRange),
                    schema: schema
                };
            }

            function createMiddlewareStack(stackImpl, middlewares) {
                return middlewares.reduce(function (down, _a) {
                    var create = _a.create;
                    return (__assign(__assign({}, down), create(down)));
                }, stackImpl);
            }
            function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
                var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;
                var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
                return {
                    dbcore: dbcore
                };
            }
            function generateMiddlewareStacks(db, tmpTrans) {
                var idbdb = tmpTrans.db;
                var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
                db.core = stacks.dbcore;
                db.tables.forEach(function (table) {
                    var tableName = table.name;
                    if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {
                        table.core = db.core.table(tableName);
                        if (db[tableName] instanceof db.Table) {
                            db[tableName].core = table.core;
                        }
                    }
                });
            }

            function setApiOnPlace(db, objs, tableNames, dbschema) {
                tableNames.forEach(function (tableName) {
                    var schema = dbschema[tableName];
                    objs.forEach(function (obj) {
                        var propDesc = getPropertyDescriptor(obj, tableName);
                        if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                            if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                                setProp(obj, tableName, {
                                    get: function () { return this.table(tableName); },
                                    set: function (value) {
                                        defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });
                                    }
                                });
                            }
                            else {
                                obj[tableName] = new db.Table(tableName, schema);
                            }
                        }
                    });
                });
            }
            function removeTablesApi(db, objs) {
                objs.forEach(function (obj) {
                    for (var key in obj) {
                        if (obj[key] instanceof db.Table)
                            delete obj[key];
                    }
                });
            }
            function lowerVersionFirst(a, b) {
                return a._cfg.version - b._cfg.version;
            }
            function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
                var globalSchema = db._dbSchema;
                if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {
                    globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
                    db._storeNames.push('$meta');
                }
                var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
                trans.create(idbUpgradeTrans);
                trans._completion.catch(reject);
                var rejectTransaction = trans._reject.bind(trans);
                var transless = PSD.transless || PSD;
                newScope(function () {
                    PSD.trans = trans;
                    PSD.transless = transless;
                    if (oldVersion === 0) {
                        keys(globalSchema).forEach(function (tableName) {
                            createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                        });
                        generateMiddlewareStacks(db, idbUpgradeTrans);
                        DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);
                    }
                    else {
                        generateMiddlewareStacks(db, idbUpgradeTrans);
                        return getExistingVersion(db, trans, oldVersion)
                            .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })
                            .catch(rejectTransaction);
                    }
                });
            }
            function patchCurrentVersion(db, idbUpgradeTrans) {
                createMissingTables(db._dbSchema, idbUpgradeTrans);
                if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {
                    idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');
                }
                var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
                adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
                var diff = getSchemaDiff(globalSchema, db._dbSchema);
                var _loop_1 = function (tableChange) {
                    if (tableChange.change.length || tableChange.recreate) {
                        console.warn("Unable to patch indexes of table ".concat(tableChange.name, " because it has changes on the type of index or primary key."));
                        return { value: void 0 };
                    }
                    var store = idbUpgradeTrans.objectStore(tableChange.name);
                    tableChange.add.forEach(function (idx) {
                        if (debug)
                            console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange.name, ".").concat(idx.src));
                        addIndex(store, idx);
                    });
                };
                for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {
                    var tableChange = _a[_i];
                    var state_1 = _loop_1(tableChange);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            function getExistingVersion(db, trans, oldVersion) {
                if (trans.storeNames.includes('$meta')) {
                    return trans.table('$meta').get('version').then(function (metaVersion) {
                        return metaVersion != null ? metaVersion : oldVersion;
                    });
                }
                else {
                    return DexiePromise.resolve(oldVersion);
                }
            }
            function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
                var queue = [];
                var versions = db._versions;
                var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
                var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });
                if (versToRun.length === 0) {
                    return DexiePromise.resolve();
                }
                versToRun.forEach(function (version) {
                    queue.push(function () {
                        var oldSchema = globalSchema;
                        var newSchema = version._cfg.dbschema;
                        adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                        adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                        globalSchema = db._dbSchema = newSchema;
                        var diff = getSchemaDiff(oldSchema, newSchema);
                        diff.add.forEach(function (tuple) {
                            createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                        });
                        diff.change.forEach(function (change) {
                            if (change.recreate) {
                                throw new exceptions.Upgrade("Not yet support for changing primary key");
                            }
                            else {
                                var store_1 = idbUpgradeTrans.objectStore(change.name);
                                change.add.forEach(function (idx) { return addIndex(store_1, idx); });
                                change.change.forEach(function (idx) {
                                    store_1.deleteIndex(idx.name);
                                    addIndex(store_1, idx);
                                });
                                change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });
                            }
                        });
                        var contentUpgrade = version._cfg.contentUpgrade;
                        if (contentUpgrade && version._cfg.version > oldVersion) {
                            generateMiddlewareStacks(db, idbUpgradeTrans);
                            trans._memoizedTables = {};
                            var upgradeSchema_1 = shallowClone(newSchema);
                            diff.del.forEach(function (table) {
                                upgradeSchema_1[table] = oldSchema[table];
                            });
                            removeTablesApi(db, [db.Transaction.prototype]);
                            setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                            trans.schema = upgradeSchema_1;
                            var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                            if (contentUpgradeIsAsync_1) {
                                incrementExpectedAwaits();
                            }
                            var returnValue_1;
                            var promiseFollowed = DexiePromise.follow(function () {
                                returnValue_1 = contentUpgrade(trans);
                                if (returnValue_1) {
                                    if (contentUpgradeIsAsync_1) {
                                        var decrementor = decrementExpectedAwaits.bind(null, null);
                                        returnValue_1.then(decrementor, decrementor);
                                    }
                                }
                            });
                            return (returnValue_1 && typeof returnValue_1.then === 'function' ?
                                DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));
                        }
                    });
                    queue.push(function (idbtrans) {
                        var newSchema = version._cfg.dbschema;
                        deleteRemovedTables(newSchema, idbtrans);
                        removeTablesApi(db, [db.Transaction.prototype]);
                        setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                        trans.schema = db._dbSchema;
                    });
                    queue.push(function (idbtrans) {
                        if (db.idbdb.objectStoreNames.contains('$meta')) {
                            if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                                db.idbdb.deleteObjectStore('$meta');
                                delete db._dbSchema.$meta;
                                db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });
                            }
                            else {
                                idbtrans.objectStore('$meta').put(version._cfg.version, 'version');
                            }
                        }
                    });
                });
                function runQueue() {
                    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                        DexiePromise.resolve();
                }
                return runQueue().then(function () {
                    createMissingTables(globalSchema, idbUpgradeTrans);
                });
            }
            function getSchemaDiff(oldSchema, newSchema) {
                var diff = {
                    del: [],
                    add: [],
                    change: []
                };
                var table;
                for (table in oldSchema) {
                    if (!newSchema[table])
                        diff.del.push(table);
                }
                for (table in newSchema) {
                    var oldDef = oldSchema[table], newDef = newSchema[table];
                    if (!oldDef) {
                        diff.add.push([table, newDef]);
                    }
                    else {
                        var change = {
                            name: table,
                            def: newDef,
                            recreate: false,
                            del: [],
                            add: [],
                            change: []
                        };
                        if ((
                            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                            (oldDef.primKey.auto !== newDef.primKey.auto)) {
                            change.recreate = true;
                            diff.change.push(change);
                        }
                        else {
                            var oldIndexes = oldDef.idxByName;
                            var newIndexes = newDef.idxByName;
                            var idxName = void 0;
                            for (idxName in oldIndexes) {
                                if (!newIndexes[idxName])
                                    change.del.push(idxName);
                            }
                            for (idxName in newIndexes) {
                                var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                                if (!oldIdx)
                                    change.add.push(newIdx);
                                else if (oldIdx.src !== newIdx.src)
                                    change.change.push(newIdx);
                            }
                            if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                                diff.change.push(change);
                            }
                        }
                    }
                }
                return diff;
            }
            function createTable(idbtrans, tableName, primKey, indexes) {
                var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
                    { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
                    { autoIncrement: primKey.auto });
                indexes.forEach(function (idx) { return addIndex(store, idx); });
                return store;
            }
            function createMissingTables(newSchema, idbtrans) {
                keys(newSchema).forEach(function (tableName) {
                    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                        if (debug)
                            console.debug('Dexie: Creating missing table', tableName);
                        createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
                    }
                });
            }
            function deleteRemovedTables(newSchema, idbtrans) {
                [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {
                    return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
                });
            }
            function addIndex(store, idx) {
                store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
            }
            function buildGlobalSchema(db, idbdb, tmpTrans) {
                var globalSchema = {};
                var dbStoreNames = slice(idbdb.objectStoreNames, 0);
                dbStoreNames.forEach(function (storeName) {
                    var store = tmpTrans.objectStore(storeName);
                    var keyPath = store.keyPath;
                    var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
                    var indexes = [];
                    for (var j = 0; j < store.indexNames.length; ++j) {
                        var idbindex = store.index(store.indexNames[j]);
                        keyPath = idbindex.keyPath;
                        var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                        indexes.push(index);
                    }
                    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
                });
                return globalSchema;
            }
            function readGlobalSchema(db, idbdb, tmpTrans) {
                db.verno = idbdb.version / 10;
                var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
                db._storeNames = slice(idbdb.objectStoreNames, 0);
                setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
            }
            function verifyInstalledSchema(db, tmpTrans) {
                var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
                var diff = getSchemaDiff(installedSchema, db._dbSchema);
                return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));
            }
            function adjustToExistingIndexNames(db, schema, idbtrans) {
                var storeNames = idbtrans.db.objectStoreNames;
                for (var i = 0; i < storeNames.length; ++i) {
                    var storeName = storeNames[i];
                    var store = idbtrans.objectStore(storeName);
                    db._hasGetAll = 'getAll' in store;
                    for (var j = 0; j < store.indexNames.length; ++j) {
                        var indexName = store.indexNames[j];
                        var keyPath = store.index(indexName).keyPath;
                        var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                        if (schema[storeName]) {
                            var indexSpec = schema[storeName].idxByName[dexieName];
                            if (indexSpec) {
                                indexSpec.name = indexName;
                                delete schema[storeName].idxByName[dexieName];
                                schema[storeName].idxByName[indexName] = indexSpec;
                            }
                        }
                    }
                }
                if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                    !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                    _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
                    [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
                    db._hasGetAll = false;
                }
            }
            function parseIndexSyntax(primKeyAndIndexes) {
                return primKeyAndIndexes.split(',').map(function (index, indexNum) {
                    var _a;
                    var typeSplit = index.split(':');
                    var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();
                    index = typeSplit[0].trim();
                    var name = index.replace(/([&*]|\+\+)/g, "");
                    var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
                    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0, type);
                });
            }

            var Version = (function () {
                function Version() {
                }
                Version.prototype._createTableSchema = function (name, primKey, indexes) {
                    return createTableSchema(name, primKey, indexes);
                };
                Version.prototype._parseIndexSyntax = function (primKeyAndIndexes) {
                    return parseIndexSyntax(primKeyAndIndexes);
                };
                Version.prototype._parseStoresSpec = function (stores, outSchema) {
                    var _this = this;
                    keys(stores).forEach(function (tableName) {
                        if (stores[tableName] !== null) {
                            var indexes = _this._parseIndexSyntax(stores[tableName]);
                            var primKey = indexes.shift();
                            if (!primKey) {
                                throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);
                            }
                            primKey.unique = true;
                            if (primKey.multi)
                                throw new exceptions.Schema('Primary key cannot be multiEntry*');
                            indexes.forEach(function (idx) {
                                if (idx.auto)
                                    throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');
                                if (!idx.keyPath)
                                    throw new exceptions.Schema('Index must have a name and cannot be an empty string');
                            });
                            var tblSchema = _this._createTableSchema(tableName, primKey, indexes);
                            outSchema[tableName] = tblSchema;
                        }
                    });
                };
                Version.prototype.stores = function (stores) {
                    var db = this.db;
                    this._cfg.storesSource = this._cfg.storesSource
                        ? extend(this._cfg.storesSource, stores)
                        : stores;
                    var versions = db._versions;
                    var storesSpec = {};
                    var dbschema = {};
                    versions.forEach(function (version) {
                        extend(storesSpec, version._cfg.storesSource);
                        dbschema = version._cfg.dbschema = {};
                        version._parseStoresSpec(storesSpec, dbschema);
                    });
                    db._dbSchema = dbschema;
                    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
                    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
                    db._storeNames = keys(dbschema);
                    return this;
                };
                Version.prototype.upgrade = function (upgradeFunction) {
                    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
                    return this;
                };
                return Version;
            }());

            function createVersionConstructor(db) {
                return makeClassConstructor(Version.prototype, function Version(versionNumber) {
                    this.db = db;
                    this._cfg = {
                        version: versionNumber,
                        storesSource: null,
                        dbschema: {},
                        tables: {},
                        contentUpgrade: null
                    };
                });
            }

            function getDbNamesTable(indexedDB, IDBKeyRange) {
                var dbNamesDB = indexedDB["_dbNamesDB"];
                if (!dbNamesDB) {
                    dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                        addons: [],
                        indexedDB: indexedDB,
                        IDBKeyRange: IDBKeyRange,
                    });
                    dbNamesDB.version(1).stores({ dbnames: "name" });
                }
                return dbNamesDB.table("dbnames");
            }
            function hasDatabasesNative(indexedDB) {
                return indexedDB && typeof indexedDB.databases === "function";
            }
            function getDatabaseNames(_a) {
                var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
                return hasDatabasesNative(indexedDB)
                    ? Promise.resolve(indexedDB.databases()).then(function (infos) {
                        return infos
                            .map(function (info) { return info.name; })
                            .filter(function (name) { return name !== DBNAMES_DB; });
                    })
                    : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
            }
            function _onDatabaseCreated(_a, name) {
                var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
                !hasDatabasesNative(indexedDB) &&
                    name !== DBNAMES_DB &&
                    getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);
            }
            function _onDatabaseDeleted(_a, name) {
                var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
                !hasDatabasesNative(indexedDB) &&
                    name !== DBNAMES_DB &&
                    getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
            }

            function vip(fn) {
                return newScope(function () {
                    PSD.letThrough = true;
                    return fn();
                });
            }

            function idbReady() {
                var isSafari = !navigator.userAgentData &&
                    /Safari\//.test(navigator.userAgent) &&
                    !/Chrom(e|ium)\//.test(navigator.userAgent);
                if (!isSafari || !indexedDB.databases)
                    return Promise.resolve();
                var intervalId;
                return new Promise(function (resolve) {
                    var tryIdb = function () { return indexedDB.databases().finally(resolve); };
                    intervalId = setInterval(tryIdb, 100);
                    tryIdb();
                }).finally(function () { return clearInterval(intervalId); });
            }

            var _a;
            function isEmptyRange(node) {
                return !("from" in node);
            }
            var RangeSet = function (fromOrTree, to) {
                if (this) {
                    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
                }
                else {
                    var rv = new RangeSet();
                    if (fromOrTree && ("d" in fromOrTree)) {
                        extend(rv, fromOrTree);
                    }
                    return rv;
                }
            };
            props(RangeSet.prototype, (_a = {
                add: function (rangeSet) {
                    mergeRanges(this, rangeSet);
                    return this;
                },
                addKey: function (key) {
                    addRange(this, key, key);
                    return this;
                },
                addKeys: function (keys) {
                    var _this = this;
                    keys.forEach(function (key) { return addRange(_this, key, key); });
                    return this;
                },
                hasKey: function (key) {
                    var node = getRangeSetIterator(this).next(key).value;
                    return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;
                }
            },
                _a[iteratorSymbol] = function () {
                    return getRangeSetIterator(this);
                },
                _a));
            function addRange(target, from, to) {
                var diff = cmp(from, to);
                if (isNaN(diff))
                    return;
                if (diff > 0)
                    throw RangeError();
                if (isEmptyRange(target))
                    return extend(target, { from: from, to: to, d: 1 });
                var left = target.l;
                var right = target.r;
                if (cmp(to, target.from) < 0) {
                    left
                        ? addRange(left, from, to)
                        : (target.l = { from: from, to: to, d: 1, l: null, r: null });
                    return rebalance(target);
                }
                if (cmp(from, target.to) > 0) {
                    right
                        ? addRange(right, from, to)
                        : (target.r = { from: from, to: to, d: 1, l: null, r: null });
                    return rebalance(target);
                }
                if (cmp(from, target.from) < 0) {
                    target.from = from;
                    target.l = null;
                    target.d = right ? right.d + 1 : 1;
                }
                if (cmp(to, target.to) > 0) {
                    target.to = to;
                    target.r = null;
                    target.d = target.l ? target.l.d + 1 : 1;
                }
                var rightWasCutOff = !target.r;
                if (left && !target.l) {
                    mergeRanges(target, left);
                }
                if (right && rightWasCutOff) {
                    mergeRanges(target, right);
                }
            }
            function mergeRanges(target, newSet) {
                function _addRangeSet(target, _a) {
                    var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
                    addRange(target, from, to);
                    if (l)
                        _addRangeSet(target, l);
                    if (r)
                        _addRangeSet(target, r);
                }
                if (!isEmptyRange(newSet))
                    _addRangeSet(target, newSet);
            }
            function rangesOverlap(rangeSet1, rangeSet2) {
                var i1 = getRangeSetIterator(rangeSet2);
                var nextResult1 = i1.next();
                if (nextResult1.done)
                    return false;
                var a = nextResult1.value;
                var i2 = getRangeSetIterator(rangeSet1);
                var nextResult2 = i2.next(a.from);
                var b = nextResult2.value;
                while (!nextResult1.done && !nextResult2.done) {
                    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
                        return true;
                    cmp(a.from, b.from) < 0
                        ? (a = (nextResult1 = i1.next(b.from)).value)
                        : (b = (nextResult2 = i2.next(a.from)).value);
                }
                return false;
            }
            function getRangeSetIterator(node) {
                var state = isEmptyRange(node) ? null : { s: 0, n: node };
                return {
                    next: function (key) {
                        var keyProvided = arguments.length > 0;
                        while (state) {
                            switch (state.s) {
                                case 0:
                                    state.s = 1;
                                    if (keyProvided) {
                                        while (state.n.l && cmp(key, state.n.from) < 0)
                                            state = { up: state, n: state.n.l, s: 1 };
                                    }
                                    else {
                                        while (state.n.l)
                                            state = { up: state, n: state.n.l, s: 1 };
                                    }
                                case 1:
                                    state.s = 2;
                                    if (!keyProvided || cmp(key, state.n.to) <= 0)
                                        return { value: state.n, done: false };
                                case 2:
                                    if (state.n.r) {
                                        state.s = 3;
                                        state = { up: state, n: state.n.r, s: 0 };
                                        continue;
                                    }
                                case 3:
                                    state = state.up;
                            }
                        }
                        return { done: true };
                    },
                };
            }
            function rebalance(target) {
                var _a, _b;
                var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
                var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
                if (r) {
                    var l = r === "r" ? "l" : "r";
                    var rootClone = __assign({}, target);
                    var oldRootRight = target[r];
                    target.from = oldRootRight.from;
                    target.to = oldRootRight.to;
                    target[r] = oldRootRight[r];
                    rootClone[r] = oldRootRight[l];
                    target[l] = rootClone;
                    rootClone.d = computeDepth(rootClone);
                }
                target.d = computeDepth(target);
            }
            function computeDepth(_a) {
                var r = _a.r, l = _a.l;
                return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
            }

            function extendObservabilitySet(target, newSet) {
                keys(newSet).forEach(function (part) {
                    if (target[part])
                        mergeRanges(target[part], newSet[part]);
                    else
                        target[part] = cloneSimpleObjectTree(newSet[part]);
                });
                return target;
            }

            function obsSetsOverlap(os1, os2) {
                return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });
            }

            var cache = {};

            var unsignaledParts = {};
            var isTaskEnqueued = false;
            function signalSubscribersLazily(part, optimistic) {
                extendObservabilitySet(unsignaledParts, part);
                if (!isTaskEnqueued) {
                    isTaskEnqueued = true;
                    setTimeout(function () {
                        isTaskEnqueued = false;
                        var parts = unsignaledParts;
                        unsignaledParts = {};
                        signalSubscribersNow(parts, false);
                    }, 0);
                }
            }
            function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
                if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }
                var queriesToSignal = new Set();
                if (updatedParts.all) {
                    for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {
                        var tblCache = _a[_i];
                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
                    }
                }
                else {
                    for (var key in updatedParts) {
                        var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
                        if (parts) {
                            var dbName = parts[1], tableName = parts[2];
                            var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                            if (tblCache)
                                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
                        }
                    }
                }
                queriesToSignal.forEach(function (requery) { return requery(); });
            }
            function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
                var updatedEntryLists = [];
                for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {
                    var _b = _a[_i], indexName = _b[0], entries = _b[1];
                    var filteredEntries = [];
                    for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
                        var entry = entries_1[_c];
                        if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                            entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });
                        }
                        else if (deleteAffectedCacheEntries) {
                            filteredEntries.push(entry);
                        }
                    }
                    if (deleteAffectedCacheEntries)
                        updatedEntryLists.push([indexName, filteredEntries]);
                }
                if (deleteAffectedCacheEntries) {
                    for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
                        var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
                        tblCache.queries.query[indexName] = filteredEntries;
                    }
                }
            }

            function dexieOpen(db) {
                var state = db._state;
                var indexedDB = db._deps.indexedDB;
                if (state.isBeingOpened || db.idbdb)
                    return state.dbReadyPromise.then(function () {
                        return state.dbOpenError ?
                            rejection(state.dbOpenError) :
                            db;
                    });
                state.isBeingOpened = true;
                state.dbOpenError = null;
                state.openComplete = false;
                var openCanceller = state.openCanceller;
                var nativeVerToOpen = Math.round(db.verno * 10);
                var schemaPatchMode = false;
                function throwIfCancelled() {
                    if (state.openCanceller !== openCanceller)
                        throw new exceptions.DatabaseClosed('db.open() was cancelled');
                }
                var resolveDbReady = state.dbReadyResolve,
                    upgradeTransaction = null, wasCreated = false;
                var tryOpenDB = function () {
                    return new DexiePromise(function (resolve, reject) {
                        throwIfCancelled();
                        if (!indexedDB)
                            throw new exceptions.MissingAPI();
                        var dbName = db.name;
                        var req = state.autoSchema || !nativeVerToOpen ?
                            indexedDB.open(dbName) :
                            indexedDB.open(dbName, nativeVerToOpen);
                        if (!req)
                            throw new exceptions.MissingAPI();
                        req.onerror = eventRejectHandler(reject);
                        req.onblocked = wrap(db._fireOnBlocked);
                        req.onupgradeneeded = wrap(function (e) {
                            upgradeTransaction = req.transaction;
                            if (state.autoSchema && !db._options.allowEmptyDB) {
                                req.onerror = preventDefault;
                                upgradeTransaction.abort();
                                req.result.close();
                                var delreq = indexedDB.deleteDatabase(dbName);
                                delreq.onsuccess = delreq.onerror = wrap(function () {
                                    reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                                });
                            }
                            else {
                                upgradeTransaction.onerror = eventRejectHandler(reject);
                                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                                wasCreated = oldVer < 1;
                                db.idbdb = req.result;
                                if (schemaPatchMode) {
                                    patchCurrentVersion(db, upgradeTransaction);
                                }
                                runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                            }
                        }, reject);
                        req.onsuccess = wrap(function () {
                            upgradeTransaction = null;
                            var idbdb = db.idbdb = req.result;
                            var objectStoreNames = slice(idbdb.objectStoreNames);
                            if (objectStoreNames.length > 0)
                                try {
                                    var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                                    if (state.autoSchema)
                                        readGlobalSchema(db, idbdb, tmpTrans);
                                    else {
                                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                                        if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                                            console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                                            idbdb.close();
                                            nativeVerToOpen = idbdb.version + 1;
                                            schemaPatchMode = true;
                                            return resolve(tryOpenDB());
                                        }
                                    }
                                    generateMiddlewareStacks(db, tmpTrans);
                                }
                                catch (e) {
                                }
                            connections.push(db);
                            idbdb.onversionchange = wrap(function (ev) {
                                state.vcFired = true;
                                db.on("versionchange").fire(ev);
                            });
                            idbdb.onclose = wrap(function () {
                                db.close({ disableAutoOpen: false });
                            });
                            if (wasCreated)
                                _onDatabaseCreated(db._deps, dbName);
                            resolve();
                        }, reject);
                    }).catch(function (err) {
                        switch (err === null || err === void 0 ? void 0 : err.name) {
                            case "UnknownError":
                                if (state.PR1398_maxLoop > 0) {
                                    state.PR1398_maxLoop--;
                                    console.warn('Dexie: Workaround for Chrome UnknownError on open()');
                                    return tryOpenDB();
                                }
                                break;
                            case "VersionError":
                                if (nativeVerToOpen > 0) {
                                    nativeVerToOpen = 0;
                                    return tryOpenDB();
                                }
                                break;
                        }
                        return DexiePromise.reject(err);
                    });
                };
                return DexiePromise.race([
                    openCanceller,
                    (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
                ]).then(function () {
                    throwIfCancelled();
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {
                        if (state.onReadyBeingFired.length > 0) {
                            var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                            state.onReadyBeingFired = [];
                            return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);
                        }
                    });
                }).finally(function () {
                    if (state.openCanceller === openCanceller) {
                        state.onReadyBeingFired = null;
                        state.isBeingOpened = false;
                    }
                }).catch(function (err) {
                    state.dbOpenError = err;
                    try {
                        upgradeTransaction && upgradeTransaction.abort();
                    }
                    catch (_a) { }
                    if (openCanceller === state.openCanceller) {
                        db._close();
                    }
                    return rejection(err);
                }).finally(function () {
                    state.openComplete = true;
                    resolveDbReady();
                }).then(function () {
                    if (wasCreated) {
                        var everything_1 = {};
                        db.tables.forEach(function (table) {
                            table.schema.indexes.forEach(function (idx) {
                                if (idx.name)
                                    everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);
                            });
                            everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet(-Infinity, [[[]]]);
                        });
                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
                        signalSubscribersNow(everything_1, true);
                    }
                    return db;
                });
            }

            function awaitIterator(iterator) {
                var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);
                function step(getNext) {
                    return function (val) {
                        var next = getNext(val), value = next.value;
                        return next.done ? value :
                            (!value || typeof value.then !== 'function' ?
                                isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                                value.then(onSuccess, onError));
                    };
                }
                return step(callNext)();
            }

            function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
                var i = arguments.length;
                if (i < 2)
                    throw new exceptions.InvalidArgument("Too few arguments");
                var args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                scopeFunc = args.pop();
                var tables = flatten(args);
                return [mode, tables, scopeFunc];
            }
            function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
                return DexiePromise.resolve().then(function () {
                    var transless = PSD.transless || PSD;
                    var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
                    trans.explicit = true;
                    var zoneProps = {
                        trans: trans,
                        transless: transless
                    };
                    if (parentTransaction) {
                        trans.idbtrans = parentTransaction.idbtrans;
                    }
                    else {
                        try {
                            trans.create();
                            trans.idbtrans._explicit = true;
                            db._state.PR1398_maxLoop = 3;
                        }
                        catch (ex) {
                            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                                console.warn('Dexie: Need to reopen db');
                                db.close({ disableAutoOpen: false });
                                return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });
                            }
                            return rejection(ex);
                        }
                    }
                    var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
                    if (scopeFuncIsAsync) {
                        incrementExpectedAwaits();
                    }
                    var returnValue;
                    var promiseFollowed = DexiePromise.follow(function () {
                        returnValue = scopeFunc.call(trans, trans);
                        if (returnValue) {
                            if (scopeFuncIsAsync) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue.then(decrementor, decrementor);
                            }
                            else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                                returnValue = awaitIterator(returnValue);
                            }
                        }
                    }, zoneProps);
                    return (returnValue && typeof returnValue.then === 'function' ?
                        DexiePromise.resolve(returnValue).then(function (x) {
                            return trans.active ?
                                x
                                : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
                        })
                        : promiseFollowed.then(function () { return returnValue; })).then(function (x) {
                            if (parentTransaction)
                                trans._resolve();
                            return trans._completion.then(function () { return x; });
                        }).catch(function (e) {
                            trans._reject(e);
                            return rejection(e);
                        });
                });
            }

            function pad(a, value, count) {
                var result = isArray(a) ? a.slice() : [a];
                for (var i = 0; i < count; ++i)
                    result.push(value);
                return result;
            }
            function createVirtualIndexMiddleware(down) {
                return __assign(__assign({}, down), {
                    table: function (tableName) {
                        var table = down.table(tableName);
                        var schema = table.schema;
                        var indexLookup = {};
                        var allVirtualIndexes = [];
                        function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                            var keyPathAlias = getKeyPathAlias(keyPath);
                            var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                            var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                            var isVirtual = keyTail > 0;
                            var virtualIndex = __assign(__assign({}, lowLevelIndex), {
                                name: isVirtual
                                    ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")")
                                    : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique
                            });
                            indexList.push(virtualIndex);
                            if (!virtualIndex.isPrimaryKey) {
                                allVirtualIndexes.push(virtualIndex);
                            }
                            if (keyLength > 1) {
                                var virtualKeyPath = keyLength === 2 ?
                                    keyPath[0] :
                                    keyPath.slice(0, keyLength - 1);
                                addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                            }
                            indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });
                            return virtualIndex;
                        }
                        var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                        indexLookup[":id"] = [primaryKey];
                        for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
                            var index = _a[_i];
                            addVirtualIndexes(index.keyPath, 0, index);
                        }
                        function findBestIndex(keyPath) {
                            var result = indexLookup[getKeyPathAlias(keyPath)];
                            return result && result[0];
                        }
                        function translateRange(range, keyTail) {
                            return {
                                type: range.type === 1 ?
                                    2 :
                                    range.type,
                                lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                                lowerOpen: true,
                                upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                                upperOpen: true
                            };
                        }
                        function translateRequest(req) {
                            var index = req.query.index;
                            return index.isVirtual ? __assign(__assign({}, req), {
                                query: {
                                    index: index.lowLevelIndex,
                                    range: translateRange(req.query.range, index.keyTail)
                                }
                            }) : req;
                        }
                        var result = __assign(__assign({}, table), {
                            schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {
                                return table.count(translateRequest(req));
                            }, query: function (req) {
                                return table.query(translateRequest(req));
                            }, openCursor: function (req) {
                                var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                                if (!isVirtual)
                                    return table.openCursor(req);
                                function createVirtualCursor(cursor) {
                                    function _continue(key) {
                                        key != null ?
                                            cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                            req.unique ?
                                                cursor.continue(cursor.key.slice(0, keyLength)
                                                    .concat(req.reverse
                                                        ? down.MIN_KEY
                                                        : down.MAX_KEY, keyTail)) :
                                                cursor.continue();
                                    }
                                    var virtualCursor = Object.create(cursor, {
                                        continue: { value: _continue },
                                        continuePrimaryKey: {
                                            value: function (key, primaryKey) {
                                                cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                            }
                                        },
                                        primaryKey: {
                                            get: function () {
                                                return cursor.primaryKey;
                                            }
                                        },
                                        key: {
                                            get: function () {
                                                var key = cursor.key;
                                                return keyLength === 1 ?
                                                    key[0] :
                                                    key.slice(0, keyLength);
                                            }
                                        },
                                        value: {
                                            get: function () {
                                                return cursor.value;
                                            }
                                        }
                                    });
                                    return virtualCursor;
                                }
                                return table.openCursor(translateRequest(req))
                                    .then(function (cursor) { return cursor && createVirtualCursor(cursor); });
                            }
                        });
                        return result;
                    }
                });
            }
            var virtualIndexMiddleware = {
                stack: "dbcore",
                name: "VirtualIndexMiddleware",
                level: 1,
                create: createVirtualIndexMiddleware
            };

            function getObjectDiff(a, b, rv, prfx) {
                rv = rv || {};
                prfx = prfx || '';
                keys(a).forEach(function (prop) {
                    if (!hasOwn(b, prop)) {
                        rv[prfx + prop] = undefined;
                    }
                    else {
                        var ap = a[prop], bp = b[prop];
                        if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                            var apTypeName = toStringTag(ap);
                            var bpTypeName = toStringTag(bp);
                            if (apTypeName !== bpTypeName) {
                                rv[prfx + prop] = b[prop];
                            }
                            else if (apTypeName === 'Object') {
                                getObjectDiff(ap, bp, rv, prfx + prop + '.');
                            }
                            else if (ap !== bp) {
                                rv[prfx + prop] = b[prop];
                            }
                        }
                        else if (ap !== bp)
                            rv[prfx + prop] = b[prop];
                    }
                });
                keys(b).forEach(function (prop) {
                    if (!hasOwn(a, prop)) {
                        rv[prfx + prop] = b[prop];
                    }
                });
                return rv;
            }

            function getEffectiveKeys(primaryKey, req) {
                if (req.type === 'delete')
                    return req.keys;
                return req.keys || req.values.map(primaryKey.extractKey);
            }

            var hooksMiddleware = {
                stack: "dbcore",
                name: "HooksMiddleware",
                level: 2,
                create: function (downCore) {
                    return (__assign(__assign({}, downCore), {
                        table: function (tableName) {
                            var downTable = downCore.table(tableName);
                            var primaryKey = downTable.schema.primaryKey;
                            var tableMiddleware = __assign(__assign({}, downTable), {
                                mutate: function (req) {
                                    var dxTrans = PSD.trans;
                                    var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                                    switch (req.type) {
                                        case 'add':
                                            if (creating.fire === nop)
                                                break;
                                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                                        case 'put':
                                            if (creating.fire === nop && updating.fire === nop)
                                                break;
                                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                                        case 'delete':
                                            if (deleting.fire === nop)
                                                break;
                                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                                        case 'deleteRange':
                                            if (deleting.fire === nop)
                                                break;
                                            return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);
                                    }
                                    return downTable.mutate(req);
                                    function addPutOrDelete(req) {
                                        var dxTrans = PSD.trans;
                                        var keys = req.keys || getEffectiveKeys(primaryKey, req);
                                        if (!keys)
                                            throw new Error("Keys missing");
                                        req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);
                                        if (req.type !== 'delete')
                                            req.values = __spreadArray([], req.values, true);
                                        if (req.keys)
                                            req.keys = __spreadArray([], req.keys, true);
                                        return getExistingValues(downTable, req, keys).then(function (existingValues) {
                                            var contexts = keys.map(function (key, i) {
                                                var existingValue = existingValues[i];
                                                var ctx = { onerror: null, onsuccess: null };
                                                if (req.type === 'delete') {
                                                    deleting.fire.call(ctx, key, existingValue, dxTrans);
                                                }
                                                else if (req.type === 'add' || existingValue === undefined) {
                                                    var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                                    if (key == null && generatedPrimaryKey != null) {
                                                        key = generatedPrimaryKey;
                                                        req.keys[i] = key;
                                                        if (!primaryKey.outbound) {
                                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                                        }
                                                    }
                                                }
                                                else {
                                                    var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                                    var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                                    if (additionalChanges_1) {
                                                        var requestedValue_1 = req.values[i];
                                                        Object.keys(additionalChanges_1).forEach(function (keyPath) {
                                                            if (hasOwn(requestedValue_1, keyPath)) {
                                                                requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                            }
                                                            else {
                                                                setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                            }
                                                        });
                                                    }
                                                }
                                                return ctx;
                                            });
                                            return downTable.mutate(req).then(function (_a) {
                                                var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                                for (var i = 0; i < keys.length; ++i) {
                                                    var primKey = results ? results[i] : keys[i];
                                                    var ctx = contexts[i];
                                                    if (primKey == null) {
                                                        ctx.onerror && ctx.onerror(failures[i]);
                                                    }
                                                    else {
                                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                            req.values[i] :
                                                            primKey
                                                        );
                                                    }
                                                }
                                                return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };
                                            }).catch(function (error) {
                                                contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });
                                                return Promise.reject(error);
                                            });
                                        });
                                    }
                                    function deleteRange(req) {
                                        return deleteNextChunk(req.trans, req.range, 10000);
                                    }
                                    function deleteNextChunk(trans, range, limit) {
                                        return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })
                                            .then(function (_a) {
                                                var result = _a.result;
                                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {
                                                    if (res.numFailures > 0)
                                                        return Promise.reject(res.failures[0]);
                                                    if (result.length < limit) {
                                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                                    }
                                                    else {
                                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                                                    }
                                                });
                                            });
                                    }
                                }
                            });
                            return tableMiddleware;
                        }
                    }));
                }
            };
            function getExistingValues(table, req, effectiveKeys) {
                return req.type === "add"
                    ? Promise.resolve([])
                    : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
            }

            function getFromTransactionCache(keys, cache, clone) {
                try {
                    if (!cache)
                        return null;
                    if (cache.keys.length < keys.length)
                        return null;
                    var result = [];
                    for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
                        if (cmp(cache.keys[i], keys[j]) !== 0)
                            continue;
                        result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                        ++j;
                    }
                    return result.length === keys.length ? result : null;
                }
                catch (_a) {
                    return null;
                }
            }
            var cacheExistingValuesMiddleware = {
                stack: "dbcore",
                level: -1,
                create: function (core) {
                    return {
                        table: function (tableName) {
                            var table = core.table(tableName);
                            return __assign(__assign({}, table), {
                                getMany: function (req) {
                                    if (!req.cache) {
                                        return table.getMany(req);
                                    }
                                    var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                                    if (cachedResult) {
                                        return DexiePromise.resolve(cachedResult);
                                    }
                                    return table.getMany(req).then(function (res) {
                                        req.trans["_cache"] = {
                                            keys: req.keys,
                                            values: req.cache === "clone" ? deepClone(res) : res,
                                        };
                                        return res;
                                    });
                                }, mutate: function (req) {
                                    if (req.type !== "add")
                                        req.trans["_cache"] = null;
                                    return table.mutate(req);
                                }
                            });
                        },
                    };
                },
            };

            function isCachableContext(ctx, table) {
                return (ctx.trans.mode === 'readonly' &&
                    !!ctx.subscr &&
                    !ctx.trans.explicit &&
                    ctx.trans.db._options.cache !== 'disabled' &&
                    !table.schema.primaryKey.outbound);
            }

            function isCachableRequest(type, req) {
                switch (type) {
                    case 'query':
                        return req.values && !req.unique;
                    case 'get':
                        return false;
                    case 'getMany':
                        return false;
                    case 'count':
                        return false;
                    case 'openCursor':
                        return false;
                }
            }

            var observabilityMiddleware = {
                stack: "dbcore",
                level: 0,
                name: "Observability",
                create: function (core) {
                    var dbName = core.schema.name;
                    var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
                    return __assign(__assign({}, core), {
                        transaction: function (stores, mode, options) {
                            if (PSD.subscr && mode !== 'readonly') {
                                throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
                            }
                            return core.transaction(stores, mode, options);
                        }, table: function (tableName) {
                            var table = core.table(tableName);
                            var schema = table.schema;
                            var primaryKey = schema.primaryKey, indexes = schema.indexes;
                            var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                            var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });
                            var tableClone = __assign(__assign({}, table), {
                                mutate: function (req) {
                                    var _a, _b;
                                    var trans = req.trans;
                                    var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                                    var getRangeSet = function (indexName) {
                                        var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                        return (mutatedParts[part] ||
                                            (mutatedParts[part] = new RangeSet()));
                                    };
                                    var pkRangeSet = getRangeSet("");
                                    var delsRangeSet = getRangeSet(":dels");
                                    var type = req.type;
                                    var _c = req.type === "deleteRange"
                                        ? [req.range]
                                        : req.type === "delete"
                                            ? [req.keys]
                                            : req.values.length < 50
                                                ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]
                                                : [], keys = _c[0], newObjs = _c[1];
                                    var oldCache = req.trans["_cache"];
                                    if (isArray(keys)) {
                                        pkRangeSet.addKeys(keys);
                                        var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;
                                        if (!oldObjs) {
                                            delsRangeSet.addKeys(keys);
                                        }
                                        if (oldObjs || newObjs) {
                                            trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                        }
                                    }
                                    else if (keys) {
                                        var range = {
                                            from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,
                                            to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                                        };
                                        delsRangeSet.add(range);
                                        pkRangeSet.add(range);
                                    }
                                    else {
                                        pkRangeSet.add(FULL_RANGE);
                                        delsRangeSet.add(FULL_RANGE);
                                        schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });
                                    }
                                    return table.mutate(req).then(function (res) {
                                        if (keys && (req.type === 'add' || req.type === 'put')) {
                                            pkRangeSet.addKeys(res.results);
                                            if (indexesWithAutoIncPK) {
                                                indexesWithAutoIncPK.forEach(function (idx) {
                                                    var idxVals = req.values.map(function (v) { return idx.extractKey(v); });
                                                    var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });
                                                    for (var i = 0, len = res.results.length; i < len; ++i) {
                                                        idxVals[i][pkPos] = res.results[i];
                                                    }
                                                    getRangeSet(idx.name).addKeys(idxVals);
                                                });
                                            }
                                        }
                                        trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                                        return res;
                                    });
                                }
                            });
                            var getRange = function (_a) {
                                var _b, _c;
                                var _d = _a.query, index = _d.index, range = _d.range;
                                return [
                                    index,
                                    new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),
                                ];
                            };
                            var readSubscribers = {
                                get: function (req) { return [primaryKey, new RangeSet(req.key)]; },
                                getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },
                                count: getRange,
                                query: getRange,
                                openCursor: getRange,
                            };
                            keys(readSubscribers).forEach(function (method) {
                                tableClone[method] = function (req) {
                                    var subscr = PSD.subscr;
                                    var isLiveQuery = !!subscr;
                                    var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                                    var obsSet = cachable
                                        ? req.obsSet = {}
                                        : subscr;
                                    if (isLiveQuery) {
                                        var getRangeSet = function (indexName) {
                                            var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                            return (obsSet[part] ||
                                                (obsSet[part] = new RangeSet()));
                                        };
                                        var pkRangeSet_1 = getRangeSet("");
                                        var delsRangeSet_1 = getRangeSet(":dels");
                                        var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                                        if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {
                                            delsRangeSet_1.add(queriedRanges);
                                        }
                                        else {
                                            getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                        }
                                        if (!queriedIndex.isPrimaryKey) {
                                            if (method === "count") {
                                                delsRangeSet_1.add(FULL_RANGE);
                                            }
                                            else {
                                                var keysPromise_1 = method === "query" &&
                                                    outbound &&
                                                    req.values &&
                                                    table.query(__assign(__assign({}, req), { values: false }));
                                                return table[method].apply(this, arguments).then(function (res) {
                                                    if (method === "query") {
                                                        if (outbound && req.values) {
                                                            return keysPromise_1.then(function (_a) {
                                                                var resultingKeys = _a.result;
                                                                pkRangeSet_1.addKeys(resultingKeys);
                                                                return res;
                                                            });
                                                        }
                                                        var pKeys = req.values
                                                            ? res.result.map(extractKey)
                                                            : res.result;
                                                        if (req.values) {
                                                            pkRangeSet_1.addKeys(pKeys);
                                                        }
                                                        else {
                                                            delsRangeSet_1.addKeys(pKeys);
                                                        }
                                                    }
                                                    else if (method === "openCursor") {
                                                        var cursor_1 = res;
                                                        var wantValues_1 = req.values;
                                                        return (cursor_1 &&
                                                            Object.create(cursor_1, {
                                                                key: {
                                                                    get: function () {
                                                                        delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                                        return cursor_1.key;
                                                                    },
                                                                },
                                                                primaryKey: {
                                                                    get: function () {
                                                                        var pkey = cursor_1.primaryKey;
                                                                        delsRangeSet_1.addKey(pkey);
                                                                        return pkey;
                                                                    },
                                                                },
                                                                value: {
                                                                    get: function () {
                                                                        wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                                        return cursor_1.value;
                                                                    },
                                                                },
                                                            }));
                                                    }
                                                    return res;
                                                });
                                            }
                                        }
                                    }
                                    return table[method].apply(this, arguments);
                                };
                            });
                            return tableClone;
                        }
                    });
                },
            };
            function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
                function addAffectedIndex(ix) {
                    var rangeSet = getRangeSet(ix.name || "");
                    function extractKey(obj) {
                        return obj != null ? ix.extractKey(obj) : null;
                    }
                    var addKeyOrKeys = function (key) {
                        return ix.multiEntry && isArray(key)
                            ? key.forEach(function (key) { return rangeSet.addKey(key); })
                            : rangeSet.addKey(key);
                    };
                    (oldObjs || newObjs).forEach(function (_, i) {
                        var oldKey = oldObjs && extractKey(oldObjs[i]);
                        var newKey = newObjs && extractKey(newObjs[i]);
                        if (cmp(oldKey, newKey) !== 0) {
                            if (oldKey != null)
                                addKeyOrKeys(oldKey);
                            if (newKey != null)
                                addKeyOrKeys(newKey);
                        }
                    });
                }
                schema.indexes.forEach(addAffectedIndex);
            }

            function adjustOptimisticFromFailures(tblCache, req, res) {
                if (res.numFailures === 0)
                    return req;
                if (req.type === 'deleteRange') {
                    return null;
                }
                var numBulkOps = req.keys
                    ? req.keys.length
                    : 'values' in req && req.values
                        ? req.values.length
                        : 1;
                if (res.numFailures === numBulkOps) {
                    return null;
                }
                var clone = __assign({}, req);
                if (isArray(clone.keys)) {
                    clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });
                }
                if ('values' in clone && isArray(clone.values)) {
                    clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });
                }
                return clone;
            }

            function isAboveLower(key, range) {
                return range.lower === undefined
                    ? true
                    : range.lowerOpen
                        ? cmp(key, range.lower) > 0
                        : cmp(key, range.lower) >= 0;
            }
            function isBelowUpper(key, range) {
                return range.upper === undefined
                    ? true
                    : range.upperOpen
                        ? cmp(key, range.upper) < 0
                        : cmp(key, range.upper) <= 0;
            }
            function isWithinRange(key, range) {
                return isAboveLower(key, range) && isBelowUpper(key, range);
            }

            function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
                if (!ops || ops.length === 0)
                    return result;
                var index = req.query.index;
                var multiEntry = index.multiEntry;
                var queryRange = req.query.range;
                var primaryKey = table.schema.primaryKey;
                var extractPrimKey = primaryKey.extractKey;
                var extractIndex = index.extractKey;
                var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
                var finalResult = ops.reduce(function (result, op) {
                    var modifedResult = result;
                    var includedValues = [];
                    if (op.type === 'add' || op.type === 'put') {
                        var includedPKs = new RangeSet();
                        for (var i = op.values.length - 1; i >= 0; --i) {
                            var value = op.values[i];
                            var pk = extractPrimKey(value);
                            if (includedPKs.hasKey(pk))
                                continue;
                            var key = extractIndex(value);
                            if (multiEntry && isArray(key)
                                ? key.some(function (k) { return isWithinRange(k, queryRange); })
                                : isWithinRange(key, queryRange)) {
                                includedPKs.addKey(pk);
                                includedValues.push(value);
                            }
                        }
                    }
                    switch (op.type) {
                        case 'add': {
                            var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);
                            modifedResult = result.concat(req.values
                                ? includedValues.filter(function (v) {
                                    var key = extractPrimKey(v);
                                    if (existingKeys_1.hasKey(key))
                                        return false;
                                    existingKeys_1.addKey(key);
                                    return true;
                                })
                                : includedValues
                                    .map(function (v) { return extractPrimKey(v); })
                                    .filter(function (k) {
                                        if (existingKeys_1.hasKey(k))
                                            return false;
                                        existingKeys_1.addKey(k);
                                        return true;
                                    }));
                            break;
                        }
                        case 'put': {
                            var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));
                            modifedResult = result
                                .filter(
                                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })
                                .concat(
                                    req.values
                                        ? includedValues
                                        : includedValues.map(function (v) { return extractPrimKey(v); }));
                            break;
                        }
                        case 'delete':
                            var keysToDelete_1 = new RangeSet().addKeys(op.keys);
                            modifedResult = result.filter(function (item) {
                                return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                            });
                            break;
                        case 'deleteRange':
                            var range_1 = op.range;
                            modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });
                            break;
                    }
                    return modifedResult;
                }, result);
                if (finalResult === result)
                    return result;
                finalResult.sort(function (a, b) {
                    return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||
                        cmp(extractPrimKey(a), extractPrimKey(b));
                });
                if (req.limit && req.limit < Infinity) {
                    if (finalResult.length > req.limit) {
                        finalResult.length = req.limit;
                    }
                    else if (result.length === req.limit && finalResult.length < req.limit) {
                        cacheEntry.dirty = true;
                    }
                }
                return immutable ? Object.freeze(finalResult) : finalResult;
            }

            function areRangesEqual(r1, r2) {
                return (cmp(r1.lower, r2.lower) === 0 &&
                    cmp(r1.upper, r2.upper) === 0 &&
                    !!r1.lowerOpen === !!r2.lowerOpen &&
                    !!r1.upperOpen === !!r2.upperOpen);
            }

            function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
                if (lower1 === undefined)
                    return lower2 !== undefined ? -1 : 0;
                if (lower2 === undefined)
                    return 1;
                var c = cmp(lower1, lower2);
                if (c === 0) {
                    if (lowerOpen1 && lowerOpen2)
                        return 0;
                    if (lowerOpen1)
                        return 1;
                    if (lowerOpen2)
                        return -1;
                }
                return c;
            }
            function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
                if (upper1 === undefined)
                    return upper2 !== undefined ? 1 : 0;
                if (upper2 === undefined)
                    return -1;
                var c = cmp(upper1, upper2);
                if (c === 0) {
                    if (upperOpen1 && upperOpen2)
                        return 0;
                    if (upperOpen1)
                        return -1;
                    if (upperOpen2)
                        return 1;
                }
                return c;
            }
            function isSuperRange(r1, r2) {
                return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&
                    compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);
            }

            function findCompatibleQuery(dbName, tableName, type, req) {
                var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                if (!tblCache)
                    return [];
                var queries = tblCache.queries[type];
                if (!queries)
                    return [null, false, tblCache, null];
                var indexName = req.query ? req.query.index.name : null;
                var entries = queries[indexName || ''];
                if (!entries)
                    return [null, false, tblCache, null];
                switch (type) {
                    case 'query':
                        var equalEntry = entries.find(function (entry) {
                            return entry.req.limit === req.limit &&
                                entry.req.values === req.values &&
                                areRangesEqual(entry.req.query.range, req.query.range);
                        });
                        if (equalEntry)
                            return [
                                equalEntry,
                                true,
                                tblCache,
                                entries,
                            ];
                        var superEntry = entries.find(function (entry) {
                            var limit = 'limit' in entry.req ? entry.req.limit : Infinity;
                            return (limit >= req.limit &&
                                (req.values ? entry.req.values : true) &&
                                isSuperRange(entry.req.query.range, req.query.range));
                        });
                        return [superEntry, false, tblCache, entries];
                    case 'count':
                        var countQuery = entries.find(function (entry) {
                            return areRangesEqual(entry.req.query.range, req.query.range);
                        });
                        return [countQuery, !!countQuery, tblCache, entries];
                }
            }

            function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
                cacheEntry.subscribers.add(requery);
                signal.addEventListener("abort", function () {
                    cacheEntry.subscribers.delete(requery);
                    if (cacheEntry.subscribers.size === 0) {
                        enqueForDeletion(cacheEntry, container);
                    }
                });
            }
            function enqueForDeletion(cacheEntry, container) {
                setTimeout(function () {
                    if (cacheEntry.subscribers.size === 0) {
                        delArrayItem(container, cacheEntry);
                    }
                }, 3000);
            }

            var cacheMiddleware = {
                stack: 'dbcore',
                level: 0,
                name: 'Cache',
                create: function (core) {
                    var dbName = core.schema.name;
                    var coreMW = __assign(__assign({}, core), {
                        transaction: function (stores, mode, options) {
                            var idbtrans = core.transaction(stores, mode, options);
                            if (mode === 'readwrite') {
                                var ac_1 = new AbortController();
                                var signal = ac_1.signal;
                                var endTransaction = function (wasCommitted) {
                                    return function () {
                                        ac_1.abort();
                                        if (mode === 'readwrite') {
                                            var affectedSubscribers_1 = new Set();
                                            for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                                                var storeName = stores_1[_i];
                                                var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                                                if (tblCache) {
                                                    var table = core.table(storeName);
                                                    var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });
                                                    if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                                                        for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {
                                                            var entries = _b[_a];
                                                            for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                                                var entry = _d[_c];
                                                                if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                                                    delArrayItem(entries, entry);
                                                                    entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else if (ops.length > 0) {
                                                        tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });
                                                        for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                                                            var entries = _f[_e];
                                                            for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                                                var entry = _h[_g];
                                                                if (entry.res != null &&
                                                                    idbtrans.mutatedParts
                                                                ) {
                                                                    if (wasCommitted && !entry.dirty) {
                                                                        var freezeResults = Object.isFrozen(entry.res);
                                                                        var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                                                        if (entry.dirty) {
                                                                            delArrayItem(entries, entry);
                                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                                        }
                                                                        else if (modRes !== entry.res) {
                                                                            entry.res = modRes;
                                                                            entry.promise = DexiePromise.resolve({ result: modRes });
                                                                        }
                                                                    }
                                                                    else {
                                                                        if (entry.dirty) {
                                                                            delArrayItem(entries, entry);
                                                                        }
                                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            affectedSubscribers_1.forEach(function (requery) { return requery(); });
                                        }
                                    };
                                };
                                idbtrans.addEventListener('abort', endTransaction(false), {
                                    signal: signal,
                                });
                                idbtrans.addEventListener('error', endTransaction(false), {
                                    signal: signal,
                                });
                                idbtrans.addEventListener('complete', endTransaction(true), {
                                    signal: signal,
                                });
                            }
                            return idbtrans;
                        }, table: function (tableName) {
                            var downTable = core.table(tableName);
                            var primKey = downTable.schema.primaryKey;
                            var tableMW = __assign(__assign({}, downTable), {
                                mutate: function (req) {
                                    var trans = PSD.trans;
                                    if (primKey.outbound ||
                                        trans.db._options.cache === 'disabled' ||
                                        trans.explicit ||
                                        trans.idbtrans.mode !== 'readwrite'
                                    ) {
                                        return downTable.mutate(req);
                                    }
                                    var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                                    if (!tblCache)
                                        return downTable.mutate(req);
                                    var promise = downTable.mutate(req);
                                    if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {
                                        promise.then(function (res) {
                                            var reqWithResolvedKeys = __assign(__assign({}, req), {
                                                values: req.values.map(function (value, i) {
                                                    var _a;
                                                    if (res.failures[i])
                                                        return value;
                                                    var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))
                                                        ? deepClone(value)
                                                        : __assign({}, value);
                                                    setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                                                    return valueWithKey;
                                                })
                                            });
                                            var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                                            tblCache.optimisticOps.push(adjustedReq);
                                            queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });
                                        });
                                    }
                                    else {
                                        tblCache.optimisticOps.push(req);
                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                        promise.then(function (res) {
                                            if (res.numFailures > 0) {
                                                delArrayItem(tblCache.optimisticOps, req);
                                                var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                                                if (adjustedReq) {
                                                    tblCache.optimisticOps.push(adjustedReq);
                                                }
                                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                            }
                                        });
                                        promise.catch(function () {
                                            delArrayItem(tblCache.optimisticOps, req);
                                            req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                        });
                                    }
                                    return promise;
                                }, query: function (req) {
                                    var _a;
                                    if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                                        return downTable.query(req);
                                    var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';
                                    var _b = PSD, requery = _b.requery, signal = _b.signal;
                                    var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                                    if (cacheEntry && exactMatch) {
                                        cacheEntry.obsSet = req.obsSet;
                                    }
                                    else {
                                        var promise = downTable.query(req).then(function (res) {
                                            var result = res.result;
                                            if (cacheEntry)
                                                cacheEntry.res = result;
                                            if (freezeResults) {
                                                for (var i = 0, l = result.length; i < l; ++i) {
                                                    Object.freeze(result[i]);
                                                }
                                                Object.freeze(result);
                                            }
                                            else {
                                                res.result = deepClone(result);
                                            }
                                            return res;
                                        }).catch(function (error) {
                                            if (container && cacheEntry)
                                                delArrayItem(container, cacheEntry);
                                            return Promise.reject(error);
                                        });
                                        cacheEntry = {
                                            obsSet: req.obsSet,
                                            promise: promise,
                                            subscribers: new Set(),
                                            type: 'query',
                                            req: req,
                                            dirty: false,
                                        };
                                        if (container) {
                                            container.push(cacheEntry);
                                        }
                                        else {
                                            container = [cacheEntry];
                                            if (!tblCache) {
                                                tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                                                    queries: {
                                                        query: {},
                                                        count: {},
                                                    },
                                                    objs: new Map(),
                                                    optimisticOps: [],
                                                    unsignaledParts: {}
                                                };
                                            }
                                            tblCache.queries.query[req.query.index.name || ''] = container;
                                        }
                                    }
                                    subscribeToCacheEntry(cacheEntry, container, requery, signal);
                                    return cacheEntry.promise.then(function (res) {
                                        return {
                                            result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),
                                        };
                                    });
                                }
                            });
                            return tableMW;
                        }
                    });
                    return coreMW;
                },
            };

            function vipify(target, vipDb) {
                return new Proxy(target, {
                    get: function (target, prop, receiver) {
                        if (prop === 'db')
                            return vipDb;
                        return Reflect.get(target, prop, receiver);
                    }
                });
            }

            var Dexie$1 = (function () {
                function Dexie(name, options) {
                    var _this = this;
                    this._middlewares = {};
                    this.verno = 0;
                    var deps = Dexie.dependencies;
                    this._options = options = __assign({
                        addons: Dexie.addons, autoOpen: true,
                        indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned'
                    }, options);
                    this._deps = {
                        indexedDB: options.indexedDB,
                        IDBKeyRange: options.IDBKeyRange
                    };
                    var addons = options.addons;
                    this._dbSchema = {};
                    this._versions = [];
                    this._storeNames = [];
                    this._allTables = {};
                    this.idbdb = null;
                    this._novip = this;
                    var state = {
                        dbOpenError: null,
                        isBeingOpened: false,
                        onReadyBeingFired: null,
                        openComplete: false,
                        dbReadyResolve: nop,
                        dbReadyPromise: null,
                        cancelOpen: nop,
                        openCanceller: null,
                        autoSchema: true,
                        PR1398_maxLoop: 3,
                        autoOpen: options.autoOpen,
                    };
                    state.dbReadyPromise = new DexiePromise(function (resolve) {
                        state.dbReadyResolve = resolve;
                    });
                    state.openCanceller = new DexiePromise(function (_, reject) {
                        state.cancelOpen = reject;
                    });
                    this._state = state;
                    this.name = name;
                    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
                    this.once = function (event, callback) {
                        var fn = function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            _this.on(event).unsubscribe(fn);
                            callback.apply(_this, args);
                        };
                        return _this.on(event, fn);
                    };
                    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
                        return function (subscriber, bSticky) {
                            Dexie.vip(function () {
                                var state = _this._state;
                                if (state.openComplete) {
                                    if (!state.dbOpenError)
                                        DexiePromise.resolve().then(subscriber);
                                    if (bSticky)
                                        subscribe(subscriber);
                                }
                                else if (state.onReadyBeingFired) {
                                    state.onReadyBeingFired.push(subscriber);
                                    if (bSticky)
                                        subscribe(subscriber);
                                }
                                else {
                                    subscribe(subscriber);
                                    var db_1 = _this;
                                    if (!bSticky)
                                        subscribe(function unsubscribe() {
                                            db_1.on.ready.unsubscribe(subscriber);
                                            db_1.on.ready.unsubscribe(unsubscribe);
                                        });
                                }
                            });
                        };
                    });
                    this.Collection = createCollectionConstructor(this);
                    this.Table = createTableConstructor(this);
                    this.Transaction = createTransactionConstructor(this);
                    this.Version = createVersionConstructor(this);
                    this.WhereClause = createWhereClauseConstructor(this);
                    this.on("versionchange", function (ev) {
                        if (ev.newVersion > 0)
                            console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
                        else
                            console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
                        _this.close({ disableAutoOpen: false });
                    });
                    this.on("blocked", function (ev) {
                        if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                            console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
                        else
                            console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
                    });
                    this._maxKey = getMaxKey(options.IDBKeyRange);
                    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };
                    this._fireOnBlocked = function (ev) {
                        _this.on("blocked").fire(ev);
                        connections
                            .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })
                            .map(function (c) { return c.on("versionchange").fire(ev); });
                    };
                    this.use(cacheExistingValuesMiddleware);
                    this.use(cacheMiddleware);
                    this.use(observabilityMiddleware);
                    this.use(virtualIndexMiddleware);
                    this.use(hooksMiddleware);
                    var vipDB = new Proxy(this, {
                        get: function (_, prop, receiver) {
                            if (prop === '_vip')
                                return true;
                            if (prop === 'table')
                                return function (tableName) { return vipify(_this.table(tableName), vipDB); };
                            var rv = Reflect.get(_, prop, receiver);
                            if (rv instanceof Table)
                                return vipify(rv, vipDB);
                            if (prop === 'tables')
                                return rv.map(function (t) { return vipify(t, vipDB); });
                            if (prop === '_createTransaction')
                                return function () {
                                    var tx = rv.apply(this, arguments);
                                    return vipify(tx, vipDB);
                                };
                            return rv;
                        }
                    });
                    this.vip = vipDB;
                    addons.forEach(function (addon) { return addon(_this); });
                }
                Dexie.prototype.version = function (versionNumber) {
                    if (isNaN(versionNumber) || versionNumber < 0.1)
                        throw new exceptions.Type("Given version is not a positive number");
                    versionNumber = Math.round(versionNumber * 10) / 10;
                    if (this.idbdb || this._state.isBeingOpened)
                        throw new exceptions.Schema("Cannot add version when database is open");
                    this.verno = Math.max(this.verno, versionNumber);
                    var versions = this._versions;
                    var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];
                    if (versionInstance)
                        return versionInstance;
                    versionInstance = new this.Version(versionNumber);
                    versions.push(versionInstance);
                    versions.sort(lowerVersionFirst);
                    versionInstance.stores({});
                    this._state.autoSchema = false;
                    return versionInstance;
                };
                Dexie.prototype._whenReady = function (fn) {
                    var _this = this;
                    return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {
                        if (_this._state.openComplete) {
                            return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
                        }
                        if (!_this._state.isBeingOpened) {
                            if (!_this._state.autoOpen) {
                                reject(new exceptions.DatabaseClosed());
                                return;
                            }
                            _this.open().catch(nop);
                        }
                        _this._state.dbReadyPromise.then(resolve, reject);
                    }).then(fn);
                };
                Dexie.prototype.use = function (_a) {
                    var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
                    if (name)
                        this.unuse({ stack: stack, name: name });
                    var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
                    middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });
                    middlewares.sort(function (a, b) { return a.level - b.level; });
                    return this;
                };
                Dexie.prototype.unuse = function (_a) {
                    var stack = _a.stack, name = _a.name, create = _a.create;
                    if (stack && this._middlewares[stack]) {
                        this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
                            return create ? mw.create !== create :
                                name ? mw.name !== name :
                                    false;
                        });
                    }
                    return this;
                };
                Dexie.prototype.open = function () {
                    var _this = this;
                    return usePSD(globalPSD,
                        function () { return dexieOpen(_this); });
                };
                Dexie.prototype._close = function () {
                    this.on.close.fire(new CustomEvent('close'));
                    var state = this._state;
                    var idx = connections.indexOf(this);
                    if (idx >= 0)
                        connections.splice(idx, 1);
                    if (this.idbdb) {
                        try {
                            this.idbdb.close();
                        }
                        catch (e) { }
                        this.idbdb = null;
                    }
                    if (!state.isBeingOpened) {
                        state.dbReadyPromise = new DexiePromise(function (resolve) {
                            state.dbReadyResolve = resolve;
                        });
                        state.openCanceller = new DexiePromise(function (_, reject) {
                            state.cancelOpen = reject;
                        });
                    }
                };
                Dexie.prototype.close = function (_a) {
                    var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;
                    var state = this._state;
                    if (disableAutoOpen) {
                        if (state.isBeingOpened) {
                            state.cancelOpen(new exceptions.DatabaseClosed());
                        }
                        this._close();
                        state.autoOpen = false;
                        state.dbOpenError = new exceptions.DatabaseClosed();
                    }
                    else {
                        this._close();
                        state.autoOpen = this._options.autoOpen ||
                            state.isBeingOpened;
                        state.openComplete = false;
                        state.dbOpenError = null;
                    }
                };
                Dexie.prototype.delete = function (closeOptions) {
                    var _this = this;
                    if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }
                    var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';
                    var state = this._state;
                    return new DexiePromise(function (resolve, reject) {
                        var doDelete = function () {
                            _this.close(closeOptions);
                            var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                            req.onsuccess = wrap(function () {
                                _onDatabaseDeleted(_this._deps, _this.name);
                                resolve();
                            });
                            req.onerror = eventRejectHandler(reject);
                            req.onblocked = _this._fireOnBlocked;
                        };
                        if (hasInvalidArguments)
                            throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
                        if (state.isBeingOpened) {
                            state.dbReadyPromise.then(doDelete);
                        }
                        else {
                            doDelete();
                        }
                    });
                };
                Dexie.prototype.backendDB = function () {
                    return this.idbdb;
                };
                Dexie.prototype.isOpen = function () {
                    return this.idbdb !== null;
                };
                Dexie.prototype.hasBeenClosed = function () {
                    var dbOpenError = this._state.dbOpenError;
                    return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
                };
                Dexie.prototype.hasFailed = function () {
                    return this._state.dbOpenError !== null;
                };
                Dexie.prototype.dynamicallyOpened = function () {
                    return this._state.autoSchema;
                };
                Object.defineProperty(Dexie.prototype, "tables", {
                    get: function () {
                        var _this = this;
                        return keys(this._allTables).map(function (name) { return _this._allTables[name]; });
                    },
                    enumerable: false,
                    configurable: true
                });
                Dexie.prototype.transaction = function () {
                    var args = extractTransactionArgs.apply(this, arguments);
                    return this._transaction.apply(this, args);
                };
                Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
                    var _this = this;
                    var parentTransaction = PSD.trans;
                    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                        parentTransaction = null;
                    var onlyIfCompatible = mode.indexOf('?') !== -1;
                    mode = mode.replace('!', '').replace('?', '');
                    var idbMode, storeNames;
                    try {
                        storeNames = tables.map(function (table) {
                            var storeName = table instanceof _this.Table ? table.name : table;
                            if (typeof storeName !== 'string')
                                throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                            return storeName;
                        });
                        if (mode == "r" || mode === READONLY)
                            idbMode = READONLY;
                        else if (mode == "rw" || mode == READWRITE)
                            idbMode = READWRITE;
                        else
                            throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                        if (parentTransaction) {
                            if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                            }
                            if (parentTransaction) {
                                storeNames.forEach(function (storeName) {
                                    if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                        if (onlyIfCompatible) {
                                            parentTransaction = null;
                                        }
                                        else
                                            throw new exceptions.SubTransaction("Table " + storeName +
                                                " not included in parent transaction.");
                                    }
                                });
                            }
                            if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                                parentTransaction = null;
                            }
                        }
                    }
                    catch (e) {
                        return parentTransaction ?
                            parentTransaction._promise(null, function (_, reject) { reject(e); }) :
                            rejection(e);
                    }
                    var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
                    return (parentTransaction ?
                        parentTransaction._promise(idbMode, enterTransaction, "lock") :
                        PSD.trans ?
                            usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :
                            this._whenReady(enterTransaction));
                };
                Dexie.prototype.table = function (tableName) {
                    if (!hasOwn(this._allTables, tableName)) {
                        throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
                    }
                    return this._allTables[tableName];
                };
                return Dexie;
            }());

            var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
                ? Symbol.observable
                : "@@observable";
            var Observable = (function () {
                function Observable(subscribe) {
                    this._subscribe = subscribe;
                }
                Observable.prototype.subscribe = function (x, error, complete) {
                    return this._subscribe(!x || typeof x === "function" ? { next: x, error: error, complete: complete } : x);
                };
                Observable.prototype[symbolObservable] = function () {
                    return this;
                };
                return Observable;
            }());

            var domDeps;
            try {
                domDeps = {
                    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
                    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
                };
            }
            catch (e) {
                domDeps = { indexedDB: null, IDBKeyRange: null };
            }

            function liveQuery(querier) {
                var hasValue = false;
                var currentValue;
                var observable = new Observable(function (observer) {
                    var scopeFuncIsAsync = isAsyncFunction(querier);
                    function execute(ctx) {
                        var wasRootExec = beginMicroTickScope();
                        try {
                            if (scopeFuncIsAsync) {
                                incrementExpectedAwaits();
                            }
                            var rv = newScope(querier, ctx);
                            if (scopeFuncIsAsync) {
                                rv = rv.finally(decrementExpectedAwaits);
                            }
                            return rv;
                        }
                        finally {
                            wasRootExec && endMicroTickScope();
                        }
                    }
                    var closed = false;
                    var abortController;
                    var accumMuts = {};
                    var currentObs = {};
                    var subscription = {
                        get closed() {
                            return closed;
                        },
                        unsubscribe: function () {
                            if (closed)
                                return;
                            closed = true;
                            if (abortController)
                                abortController.abort();
                            if (startedListening)
                                globalEvents.storagemutated.unsubscribe(mutationListener);
                        },
                    };
                    observer.start && observer.start(subscription);
                    var startedListening = false;
                    var doQuery = function () { return execInGlobalContext(_doQuery); };
                    function shouldNotify() {
                        return obsSetsOverlap(currentObs, accumMuts);
                    }
                    var mutationListener = function (parts) {
                        extendObservabilitySet(accumMuts, parts);
                        if (shouldNotify()) {
                            doQuery();
                        }
                    };
                    var _doQuery = function () {
                        if (closed ||
                            !domDeps.indexedDB) {
                            return;
                        }
                        accumMuts = {};
                        var subscr = {};
                        if (abortController)
                            abortController.abort();
                        abortController = new AbortController();
                        var ctx = {
                            subscr: subscr,
                            signal: abortController.signal,
                            requery: doQuery,
                            querier: querier,
                            trans: null
                        };
                        var ret = execute(ctx);
                        Promise.resolve(ret).then(function (result) {
                            hasValue = true;
                            currentValue = result;
                            if (closed || ctx.signal.aborted) {
                                return;
                            }
                            accumMuts = {};
                            currentObs = subscr;
                            if (!objectIsEmpty(currentObs) && !startedListening) {
                                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                                startedListening = true;
                            }
                            execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });
                        }, function (err) {
                            hasValue = false;
                            if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {
                                if (!closed)
                                    execInGlobalContext(function () {
                                        if (closed)
                                            return;
                                        observer.error && observer.error(err);
                                    });
                            }
                        });
                    };
                    setTimeout(doQuery, 0);
                    return subscription;
                });
                observable.hasValue = function () { return hasValue; };
                observable.getValue = function () { return currentValue; };
                return observable;
            }

            var Dexie = Dexie$1;
            props(Dexie, __assign(__assign({}, fullNameExceptions), {
                delete: function (databaseName) {
                    var db = new Dexie(databaseName, { addons: [] });
                    return db.delete();
                },
                exists: function (name) {
                    return new Dexie(name, { addons: [] }).open().then(function (db) {
                        db.close();
                        return true;
                    }).catch('NoSuchDatabaseError', function () { return false; });
                },
                getDatabaseNames: function (cb) {
                    try {
                        return getDatabaseNames(Dexie.dependencies).then(cb);
                    }
                    catch (_a) {
                        return rejection(new exceptions.MissingAPI());
                    }
                },
                defineClass: function () {
                    function Class(content) {
                        extend(this, content);
                    }
                    return Class;
                }, ignoreTransaction: function (scopeFunc) {
                    return PSD.trans ?
                        usePSD(PSD.transless, scopeFunc) :
                        scopeFunc();
                }, vip: vip, async: function (generatorFn) {
                    return function () {
                        try {
                            var rv = awaitIterator(generatorFn.apply(this, arguments));
                            if (!rv || typeof rv.then !== 'function')
                                return DexiePromise.resolve(rv);
                            return rv;
                        }
                        catch (e) {
                            return rejection(e);
                        }
                    };
                }, spawn: function (generatorFn, args, thiz) {
                    try {
                        var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                        if (!rv || typeof rv.then !== 'function')
                            return DexiePromise.resolve(rv);
                        return rv;
                    }
                    catch (e) {
                        return rejection(e);
                    }
                },
                currentTransaction: {
                    get: function () { return PSD.trans || null; }
                }, waitFor: function (promiseOrFunction, optionalTimeout) {
                    var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                        Dexie.ignoreTransaction(promiseOrFunction) :
                        promiseOrFunction)
                        .timeout(optionalTimeout || 60000);
                    return PSD.trans ?
                        PSD.trans.waitFor(promise) :
                        promise;
                },
                Promise: DexiePromise,
                debug: {
                    get: function () { return debug; },
                    set: function (value) {
                        setDebug(value);
                    }
                },
                derive: derive, extend: extend, props: props, override: override,
                Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,
                getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,
                minKey: minKey,
                addons: [],
                connections: connections,
                errnames: errnames,
                dependencies: domDeps, cache: cache,
                semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')
                    .map(function (n) { return parseInt(n); })
                    .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); })
            }));
            Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

            if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {
                    if (!propagatingLocally) {
                        var event_1;
                        event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                            detail: updatedParts
                        });
                        propagatingLocally = true;
                        dispatchEvent(event_1);
                        propagatingLocally = false;
                    }
                });
                addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {
                    var detail = _a.detail;
                    if (!propagatingLocally) {
                        propagateLocally(detail);
                    }
                });
            }
            function propagateLocally(updateParts) {
                var wasMe = propagatingLocally;
                try {
                    propagatingLocally = true;
                    globalEvents.storagemutated.fire(updateParts);
                    signalSubscribersNow(updateParts, true);
                }
                finally {
                    propagatingLocally = wasMe;
                }
            }
            var propagatingLocally = false;

            var bc;
            var createBC = function () { };
            if (typeof BroadcastChannel !== 'undefined') {
                createBC = function () {
                    bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
                    bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };
                };
                createBC();
                if (typeof bc.unref === 'function') {
                    bc.unref();
                }
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
                    if (!propagatingLocally) {
                        bc.postMessage(changedParts);
                    }
                });
            }

            if (typeof addEventListener !== 'undefined') {
                addEventListener('pagehide', function (event) {
                    if (!Dexie$1.disableBfCache && event.persisted) {
                        if (debug)
                            console.debug('Dexie: handling persisted pagehide');
                        bc === null || bc === void 0 ? void 0 : bc.close();
                        for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
                            var db = connections_1[_i];
                            db.close({ disableAutoOpen: false });
                        }
                    }
                });
                addEventListener('pageshow', function (event) {
                    if (!Dexie$1.disableBfCache && event.persisted) {
                        if (debug)
                            console.debug('Dexie: handling persisted pageshow');
                        createBC();
                        propagateLocally({ all: new RangeSet(-Infinity, [[]]) });
                    }
                });
            }

            function add(value) {
                return new PropModification({ add: value });
            }

            function remove(value) {
                return new PropModification({ remove: value });
            }

            function replacePrefix(a, b) {
                return new PropModification({ replacePrefix: [a, b] });
            }

            DexiePromise.rejectionMapper = mapError;
            setDebug(debug);

            var namedExports = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Dexie: Dexie$1,
                Entity: Entity,
                PropModification: PropModification,
                RangeSet: RangeSet,
                add: add,
                cmp: cmp,
                default: Dexie$1,
                liveQuery: liveQuery,
                mergeRanges: mergeRanges,
                rangesOverlap: rangesOverlap,
                remove: remove,
                replacePrefix: replacePrefix
            });

            __assign(Dexie$1, namedExports, { default: Dexie$1 });

            return Dexie$1;

        }));
        //# sourceMappingURL=dexie.js.map

    </script>


    <!-- Подключаем Chart.js для графиков -->

    <script>
        function drawExpensesPie(categoriesMap) {
            const canvas = document.getElementById('expenses-chart');
            const noData = document.getElementById('chart-no-data');
            const ctx = canvas.getContext('2d');

            const entries = Array.from(categoriesMap.entries())
                .filter(([_, v]) => v > 0);

            if (entries.length === 0) {
                canvas.style.display = 'none';
                noData.style.display = 'block';
                return;
            }

            canvas.style.display = 'block';
            noData.style.display = 'none';
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const total = entries.reduce((s, [, v]) => s + v, 0);
            let angle = -Math.PI / 2;

            entries.forEach(([label, value], i) => {
                const slice = (value / total) * Math.PI * 2;

                ctx.beginPath();
                ctx.moveTo(150, 150);
                ctx.arc(150, 150, 120, angle, angle + slice);
                ctx.closePath();
                ctx.fillStyle = pieColor(i);
                ctx.fill();

                angle += slice;
            });

            drawLegend(ctx, entries);
        }

        function pieColor(i) {
            const colors = [
                '#e74c3c', '#3498db', '#f1c40f',
                '#2ecc71', '#9b59b6', '#e67e22',
                '#1abc9c', '#34495e'
            ];
            return colors[i % colors.length];
        }

        function drawLegend(ctx, entries) {
            ctx.font = '12px sans-serif';
            entries.forEach(([label], i) => {
                ctx.fillStyle = pieColor(i);
                ctx.fillRect(10, 10 + i * 18, 12, 12);
                ctx.fillStyle = '#333';
                ctx.fillText(label, 28, 20 + i * 18);
            });
        }
    </script>

    <!-- Наши скрипты -->



    <!-- Встроенный JavaScript -->
    <script>
        // ========== НАЧАЛО db.js ==========
        // Инициализация базы данных IndexedDB через Dexie
        const db = new Dexie('FinanceDB');

        // В db.js заменяем текущую версию на версию 6
        db.version(7).stores({
            accounts: '++id, name, balance, type, color, isVisible',
            categories: '++id, name, parentId, type',
            transactions: '++id, type, accountId, toAccountId, categoryId, amount, date, comment',
            monthlyPlans: '++id, month, plannedIncome',
            limits: '++id, categoryId, limitType, limitValue, order'
        }).upgrade(tx => {
            // Устанавливаем начальный порядок для существующих лимитов
            return tx.limits.toCollection().modify((limit, idx) => {
                limit.order = idx; // Порядок по умолчанию
            });
        });
        // Даем глобальный доступ для отладки
        window.db = db;

        // Функция для заполнения начальными данными
        async function initSampleData() {
            // Проверяем, есть ли уже категории
            const categoriesCount = await db.categories.count();
            if (categoriesCount === 0) {
                // Добавляем стандартные категории расходов и доходов
                await db.categories.bulkAdd([
                    // Основные категории расходов
                    { name: 'Еда', parentId: 0, type: 'expense' },
                    { name: 'Дом', parentId: 0, type: 'expense' },
                    { name: 'Транспорт', parentId: 0, type: 'expense' },
                    { name: 'Здоровье', parentId: 0, type: 'expense' },
                    { name: 'Веселье', parentId: 0, type: 'expense' },
                    { name: 'Одежда', parentId: 0, type: 'expense' },

                    // Подкатегории для Еды
                    { name: 'Продукты', parentId: 1, type: 'expense' },
                    { name: 'Кафе', parentId: 1, type: 'expense' },
                    { name: 'Энергетики', parentId: 1, type: 'expense' },

                    // Подкатегории для Дома
                    { name: 'Коммуналка', parentId: 2, type: 'expense' },
                    { name: 'Ремонт', parentId: 2, type: 'expense' },

                    // Категории доходов
                    { name: 'Зарплата', parentId: 0, type: 'income' },
                    { name: 'Фриланс', parentId: 0, type: 'income' },
                    { name: 'Инвестиции', parentId: 0, type: 'income' }
                ]);

                console.log('Категории добавлены!');
            }

            // Проверяем, есть ли уже счета
            const accountsCount = await db.accounts.count();
            if (accountsCount === 0) {
                // Добавляем стандартные счета
                await db.accounts.bulkAdd([
                    { name: 'Наличные', balance: 0, type: 'cash', color: '#27ae60' },
                    { name: 'Карта', balance: 0, type: 'card', color: '#3498db' }
                ]);

                console.log('Счета добавлены!');
            }

            // Проверяем, есть ли планируемый доход на текущий месяц
            const currentMonth = new Date().toISOString().slice(0, 7);
            const monthlyPlanCount = await db.monthlyPlans.where('month').equals(currentMonth).count();
            if (monthlyPlanCount === 0) {
                await db.monthlyPlans.add({ month: currentMonth, plannedIncome: 100000 });
                console.log('Планируемый доход добавлен!');
            }

            console.log('Инициализация завершена!');
        }

        // Инициализация базы при загрузке
        window.addEventListener('DOMContentLoaded', () => {
            initSampleData().catch(err => console.error("Ошибка инициализации:", err));
        });
        // ========== КОНЕЦ db.js ==========

        // ========== НАЧАЛО app.js ==========
        // Ждем загрузки DOM
        document.addEventListener('DOMContentLoaded', async function () {

            // 1. Переключение между страницами
            const navLinks = document.querySelectorAll('.nav-link');
            const pages = document.querySelectorAll('.page');

            navLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const pageId = this.getAttribute('data-page');

                    // Обновляем активную ссылку в навигации
                    navLinks.forEach(l => l.classList.remove('active'));
                    this.classList.add('active');

                    // Показываем нужную страницу
                    pages.forEach(page => {
                        page.classList.remove('active');
                        if (page.id === `page-${pageId}`) {
                            page.classList.add('active');
                        }
                    });

                    // В зависимости от страницы загружаем соответствующие данные
                    switch (pageId) {
                        case 'main':
                            loadMainPage();
                            break;
                        case 'accounts':
                            loadAccountsPage();
                            break;
                        case 'categories':
                            loadCategoriesPage();
                            break;
                        case 'limits':
                            loadLimitsPage();
                            break;
                        case 'report':
                            loadReportPage();
                            break;
                        // ДОБАВЛЯЕМ:
                        case 'export':
                            loadExportPage();
                            break;
                        case 'import':
                            loadImportPage();
                            break;
                    }
                });
            });

            // 2. Первоначальная загрузка главной страницы
            await loadMainPage();

            // 3. Обновляем общий баланс в футере
            await updateTotalBalance();
        });

        // Функция загрузки главной страницы
        async function loadMainPage() {
            const mainPage = document.getElementById('page-main');

            // Создаем содержимое главной страницы
            mainPage.innerHTML = `
        <div class="main-page-container">
            <!-- Форма для добавления операции -->
            <div class="add-transaction-card">
                <h3><i class="fas fa-plus-circle"></i> Новая операция</h3>
                <form id="add-transaction-form">
                    <div class="form-group">
                        <label>Тип операции:</label>
                        <select id="transaction-type" class="form-control">
                            <option value="expense">Расход</option>
                            <option value="income">Доход</option>
                            <option value="transfer">Перевод между счетами</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Сумма (₽):</label>
                        <input type="number" id="transaction-amount" class="form-control" step="0.01" min="0" required>
                    </div>
                    
                    <div class="form-group">
                        <label>Счет:</label>
                        <select id="transaction-account" class="form-control"></select>
                    </div>
                    <div class="form-group" id="to-account-group" style="display: none;">
                        <label>На счет:</label>
                        <select id="transaction-to-account" class="form-control"></select>
                    </div>

                    <div class="form-group">
                        <label>Категория:</label>
                        <select id="transaction-category" class="form-control"></select>
                    </div>
                    
                    <div class="form-group" id="subcategory-group" style="display: none;">
                        <label>Подкатегория (опционально):</label>
                        <select id="transaction-subcategory" class="form-control">
                            <option value="">Не выбрано</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Дата:</label>
                        <input type="date" id="transaction-date" class="form-control" value="${new Date().toISOString().split('T')[0]}">
                    </div>
                    
                    <div class="form-group">
                        <label>Комментарий:</label>
                        <input type="text" id="transaction-comment" class="form-control" placeholder="На что?">
                    </div>
                    
                    <button type="submit" class="btn btn-primary">
                        <i class="fas fa-save"></i> Добавить операцию
                    </button>
                </form>
            </div>
            
            <!-- Список операций с фильтром -->
            <div class="recent-transactions">
                <div class="transactions-header">
                    <h3><i class="fas fa-history"></i> Операции</h3>
                    <div class="date-filter">
                        <div class="filter-row">
                            <div class="filter-group">
                                <label>С:</label>
                                <input type="date" id="transactions-filter-date-from" class="form-control-sm" 
                                    value="${new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0]}">
                            </div>
                            <div class="filter-group">
                                <label>По:</label>
                                <input type="date" id="transactions-filter-date-to" class="form-control-sm" 
                                    value="${new Date().toISOString().split('T')[0]}">
                            </div>
                        </div>
                        <div class="filter-buttons">
                            <button class="btn btn-sm btn-outline" id="filter-transactions">
                                <i class="fas fa-filter"></i> Фильтр
                            </button>
                            <button class="btn btn-sm btn-outline" id="show-all-transactions">
                                <i class="fas fa-eye"></i> Все
                            </button>
                        </div>
                    </div>
                </div>
                <div id="transactions-list">
                    <p class="text-muted">Операций пока нет.</p>
                </div>
            </div>
`;

            // Заполняем выпадающие списки
            await populateAccountSelect();
            await populateCategorySelect();

            // Вешаем обработчики
            document.getElementById('add-transaction-form').addEventListener('submit', handleAddTransaction);
            document.getElementById('transaction-type').addEventListener('change', async function () {
                const type = this.value;
                const categoryGroup = document.getElementById('transaction-category').closest('.form-group');
                const subcategoryGroup = document.getElementById('subcategory-group');
                const toAccountGroup = document.getElementById('to-account-group');

                if (type === 'transfer') {
                    // Для переводов скрываем категории, показываем счет-получатель
                    categoryGroup.style.display = 'none';
                    subcategoryGroup.style.display = 'none';
                    toAccountGroup.style.display = 'block';
                    await populateToAccountSelect();
                } else {
                    // Для доходов/расходов показываем категории, скрываем счет-получатель
                    categoryGroup.style.display = 'block';
                    toAccountGroup.style.display = 'none';
                    await populateCategorySelect();
                }
            });
            document.getElementById('transaction-category').addEventListener('change', async function () {
                await showSubcategorySelect(this.value);
            });

            document.getElementById('transaction-type').addEventListener('change', async function () {
                const type = this.value;
                const categoryGroup = document.getElementById('category-group');
                const subcategoryGroup = document.getElementById('subcategory-group');
                const toAccountGroup = document.getElementById('to-account-group');

                if (type === 'transfer') {
                    // Для переводов
                    categoryGroup.style.display = 'none';
                    subcategoryGroup.style.display = 'none';
                    toAccountGroup.style.display = 'block';
                    // СБРАСЫВАЕМ ВЫБОР СЧЕТА-ПОЛУЧАТЕЛЯ ПРИ ПЕРЕКЛЮЧЕНИИ НА ПЕРЕВОД
                    document.getElementById('transaction-to-account').selectedIndex = 0;
                    await populateToAccountSelect();
                } else {
                    // Для доходов/расходов
                    categoryGroup.style.display = 'block';
                    toAccountGroup.style.display = 'none';
                    await populateCategorySelect();
                }
            });

            // Также обновляем обработчик смены счета-отправителя
            document.getElementById('transaction-account').addEventListener('change', async function () {
                const type = document.getElementById('transaction-type').value;

                // Если выбран тип "перевод", обновляем список счетов-получателей
                if (type === 'transfer') {
                    await populateToAccountSelect();
                }
            });

            // Дополнительно: добавляем валидацию при отправке формы
            document.getElementById('add-transaction-form').addEventListener('submit', function (e) {
                const type = document.getElementById('transaction-type').value;
                const fromAccount = document.getElementById('transaction-account').value;

                if (type === 'transfer') {
                    const toAccount = document.getElementById('transaction-to-account').value;

                    // Проверяем, что выбраны разные счета
                    if (!fromAccount || !toAccount) {
                        e.preventDefault();
                        alert('Для перевода необходимо выбрать оба счета!');
                        return;
                    }

                    if (fromAccount === toAccount) {
                        e.preventDefault();
                        alert('Нельзя перевести деньги на тот же самый счет!');
                        return;
                    }
                } else {
                    // Для доходов/расходов проверяем только счет
                    if (!fromAccount) {
                        e.preventDefault();
                        alert('Выберите счет для операции!');
                        return;
                    }
                }
            });

            async function populateToAccountSelect() {
                const fromAccountSelect = document.getElementById('transaction-account');
                const toAccountSelect = document.getElementById('transaction-to-account');
                const fromAccountId = parseInt(fromAccountSelect.value);
                const accounts = await db.accounts.toArray();

                // Исключаем выбранный счет-отправитель
                const availableAccounts = accounts.filter(acc => acc.id !== fromAccountId);

                toAccountSelect.innerHTML = availableAccounts.map(acc =>
                    `<option value="${acc.id}">${acc.name} (${acc.balance.toFixed(2)} ₽)</option>`
                ).join('');
            }

            // Обработчики фильтра
            document.getElementById('filter-transactions').addEventListener('click', async () => {
                const dateFrom = document.getElementById('transactions-filter-date-from').value;
                const dateTo = document.getElementById('transactions-filter-date-to').value;

                if (!dateFrom || !dateTo) {
                    alert('Заполните обе даты для фильтрации');
                    return;
                }

                if (dateFrom > dateTo) {
                    alert('Дата "С" должна быть раньше или равна дате "По"');
                    return;
                }

                await loadRecentTransactions(dateFrom, dateTo);
            });

            document.getElementById('show-all-transactions').addEventListener('click', async () => {
                document.getElementById('transactions-filter-date-from').value =
                    new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0];
                document.getElementById('transactions-filter-date-to').value =
                    new Date().toISOString().split('T')[0];
                await loadRecentTransactions(null, null);
            });

            // Загружаем последние операции (все)
            await loadRecentTransactions(null);
        }

        // Функция загрузки страницы счетов
        async function loadAccountsPage() {
            const page = document.getElementById('page-accounts');

            // Получаем все счета из базы
            const accounts = await db.accounts.toArray();

            page.innerHTML = `
        <div class="accounts-container">
            <div class="accounts-header">
                <h3><i class="fas fa-credit-card"></i> Управление счетами</h3>
                <button class="btn btn-primary" id="add-account-btn">
                    <i class="fas fa-plus"></i> Добавить счет
                </button>
            </div>
            
            <!-- Форма добавления счета (скрыта по умолчанию) -->
            <div class="add-account-form" id="add-account-form" style="display: none;">
                <h4>Новый счет</h4>
                <form id="account-form">
                    <div class="form-group">
                        <label>Название счета:</label>
                        <input type="text" id="account-name" class="form-control" placeholder="Название" required>
                    </div>
                    
                    <div class="form-group">
                        <label>Начальный баланс:</label>
                        <input type="number" id="account-balance" class="form-control" step="0.01" value="0">
                    </div>
                    
                    <div class="form-group">
                        <label>Тип счета:</label>
                        <select id="account-type" class="form-control">
                            <option value="cash">Наличные</option>
                            <option value="card">Банковская карта</option>
                            <option value="deposit">Депозит</option>
                            <option value="other">Другое</option>
                        </select>
                    </div>
                    
                    <div class="form-buttons">
                        <button type="submit" class="btn btn-primary">
                            <i class="fas fa-save"></i> Сохранить
                        </button>
                        <button type="button" class="btn btn-secondary" id="cancel-account-btn">
                            <i class="fas fa-times"></i> Отмена
                        </button>
                    </div>
                </form>
            </div>
            
            <!-- Список счетов -->
            <div class="accounts-list">
                ${accounts.length === 0 ?
                    '<p class="text-muted">Счетов пока нет. Добавьте первый счет.</p>' :
                    accounts.map(account => `
                        <div class="account-item ${account.isVisible === false ? 'hidden' : ''}" data-id="${account.id}">
                            <div class="account-info">
                                <div class="account-name" style="color: ${account.color || '#4a6fa5'}">
                                    <i class="fas ${account.type === 'cash' ? 'fa-money-bill' : account.type === 'card' ? 'fa-credit-card' : 'fa-university'}"></i>
                                    ${account.name}
                                </div>
                                <div class="account-balance">${account.balance.toFixed(2)} ₽</div>
                            </div>
                           <div class="account-actions">
                                <!-- Глазок -->
                                <button class="eye-toggle ${account.isVisible === false ? '' : 'active'}" 
                                        title="${account.isVisible === false ? 'Показать в балансе' : 'Скрыть из баланса'}">
                                    <i class="fas fa-eye${account.isVisible === false ? '-slash' : ''}"></i>
                                </button>
                                <!-- Кнопки редактирования и удаления -->
                                <button class="btn-icon edit-account" title="Редактировать">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn-icon delete-account" title="Удалить">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')
                }
            </div>
        </div>
    `;

            // Обработчики для кнопок
            document.getElementById('add-account-btn').addEventListener('click', () => {
                document.getElementById('add-account-form').style.display = 'block';
            });

            document.getElementById('cancel-account-btn').addEventListener('click', () => {
                document.getElementById('add-account-form').style.display = 'none';
            });

            // Обработчик формы добавления счета
            document.getElementById('account-form').addEventListener('submit', handleAddAccount);

            // Обработчики для редактирования и удаления счетов
            document.querySelectorAll('.edit-account').forEach(btn => {
                btn.addEventListener('click', function () {
                    const accountId = this.closest('.account-item').dataset.id;
                    editAccount(accountId);
                });
            });

            document.querySelectorAll('.delete-account').forEach(btn => {
                btn.addEventListener('click', function () {
                    const accountId = this.closest('.account-item').dataset.id;
                    deleteAccount(accountId);
                });
            });

            // Обработчики для глазка (показать/скрыть счет)
            document.querySelectorAll('.eye-toggle').forEach(btn => {
                btn.addEventListener('click', async function (e) {
                    e.stopPropagation(); // Останавливаем всплытие

                    const accountItem = this.closest('.account-item');
                    const accountId = parseInt(accountItem.dataset.id);
                    const isCurrentlyVisible = this.classList.contains('active');

                    try {
                        // Обновляем в базе
                        await db.accounts.update(accountId, { isVisible: !isCurrentlyVisible });

                        // Обновляем интерфейс
                        if (isCurrentlyVisible) {
                            // Стало скрытым
                            this.classList.remove('active');
                            this.innerHTML = '<i class="fas fa-eye-slash"></i>';
                            this.title = 'Показать в балансе';
                            accountItem.classList.add('hidden');
                        } else {
                            // Стало видимым
                            this.classList.add('active');
                            this.innerHTML = '<i class="fas fa-eye"></i>';
                            this.title = 'Скрыть из баланса';
                            accountItem.classList.remove('hidden');
                        }

                        // Обновляем общий баланс
                        await updateTotalBalance();

                    } catch (error) {
                        console.error('Ошибка обновления видимости счета:', error);
                        alert('Ошибка: ' + error.message);
                    }
                });
            });

        }

        // Функция загрузки страницы категорий
        async function loadCategoriesPage() {
            const page = document.getElementById('page-categories');

            // Получаем все категории
            const categories = await db.categories.toArray();
            const incomeCategories = categories.filter(c => c.type === 'income' && c.parentId === 0);
            const expenseCategories = categories.filter(c => c.type === 'expense' && c.parentId === 0);

            page.innerHTML = `
        <div class="categories-container">
            <div class="categories-header">
                <h3><i class="fas fa-tags"></i> Управление категориями</h3>
                <div>
                    <button class="btn btn-primary" id="add-main-category-btn">
                        <i class="fas fa-plus"></i> Основная категория
                    </button>
                    <button class="btn btn-secondary" id="add-subcategory-btn">
                        <i class="fas fa-plus-circle"></i> Подкатегория
                    </button>
                </div>
            </div>
            
            <!-- Формы для добавления категорий -->
            <div class="category-forms">
                <!-- ФОРМА ДЛЯ ОСНОВНОЙ КАТЕГОРИИ (ДОБАВЛЯЕМ ОБРАТНО) -->
                <div class="add-category-form" id="add-main-category-form" style="display: none;">
                    <h4>Новая основная категория</h4>
                    <form id="main-category-form">
                        <div class="form-group">
                            <label>Тип:</label>
                            <select id="main-category-type" class="form-control">
                                <option value="expense">Расход</option>
                                <option value="income">Доход</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Название категории:</label>
                            <input type="text" id="main-category-name" class="form-control" required>
                        </div>
                        
                        <div class="form-buttons">
                            <button type="submit" class="btn btn-primary">Добавить</button>
                            <button type="button" class="btn btn-secondary cancel-category-btn">Отмена</button>
                        </div>
                    </form>
                </div>
                
                <!-- ФОРМА ДЛЯ ПОДКАТЕГОРИЙ -->
                <div class="add-category-form" id="add-subcategory-form" style="display: none;">
                    <h4><i class="fas fa-layer-group"></i> Добавление подкатегорий</h4>
                    <form id="subcategory-form">
                        <div class="form-group">
                            <label>Тип:</label>
                            <select id="subcategory-type" class="form-control">
                                <option value="expense">Расход</option>
                                <option value="income">Доход</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Основная категория:</label>
                            <select id="parent-category" class="form-control"></select>
                        </div>
                        
                        <!-- Контейнер для динамических полей -->
                        <div class="subcategory-fields-container">
                            <div class="form-group">
                                <label>Подкатегории:</label>
                                <div class="subcategory-fields" id="subcategory-fields">
                                    <!-- Первое поле будет здесь -->
                                    <div class="subcategory-field-group first-field">
                                        <div class="input-with-button">
                                            <input type="text" class="form-control subcategory-name-input" 
                                                placeholder="Название подкатегории" required>
                                            <button type="button" class="btn btn-success add-field-btn" title="Добавить еще поле">
                                                <i class="fas fa-plus"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <small class="text-muted">Можно добавить несколько подкатегорий за раз</small>
                            </div>
                        </div>
                        
                        <div class="form-buttons">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Сохранить все
                            </button>
                            <button type="button" class="btn btn-secondary cancel-category-btn">
                                <i class="fas fa-times"></i> Отмена
                            </button>
                        </div>
                    </form>
                </div>
            </div>
            
            <!-- Разделитель категорий доходов и расходов -->
            <div class="categories-section">
                <h4 class="section-title income-title"><i class="fas fa-arrow-up"></i> Категории доходов</h4>
                <div class="categories-list income-categories">
                    ${incomeCategories.length === 0 ?
                    '<p class="text-muted">Категорий доходов пока нет.</p>' :
                    incomeCategories.map(category => renderCategoryItem(category, categories)).join('')
                }
                </div>
            </div>
            
            <div class="categories-section">
                <h4 class="section-title expense-title"><i class="fas fa-arrow-down"></i> Категории расходов</h4>
                <div class="categories-list expense-categories">
                    ${expenseCategories.length === 0 ?
                    '<p class="text-muted">Категорий расходов пока нет.</p>' :
                    expenseCategories.map(category => renderCategoryItem(category, categories)).join('')
                }
                </div>
            </div>
        </div>
    `;

            // Заполняем список основных категорий для подкатегорий ПРИ ЗАГРУЗКЕ
            await populateParentCategorySelectForForm();

            // Обработчики кнопок
            document.getElementById('add-main-category-btn').addEventListener('click', () => {
                document.getElementById('add-main-category-form').style.display = 'block';
                document.getElementById('add-subcategory-form').style.display = 'none';
                document.getElementById('main-category-form').reset();
            });

            document.getElementById('add-subcategory-btn').addEventListener('click', async () => {
                document.getElementById('add-subcategory-form').style.display = 'block';
                document.getElementById('add-main-category-form').style.display = 'none';
                document.getElementById('subcategory-form').reset();

                // Заполняем список категорий при открытии формы
                await populateParentCategorySelectForForm();

                // Очищаем динамические поля
                const fieldsContainer = document.getElementById('subcategory-fields');
                const firstField = fieldsContainer.querySelector('.first-field');
                fieldsContainer.innerHTML = '';
                fieldsContainer.appendChild(firstField);
                firstField.querySelector('.subcategory-name-input').value = '';
            });

            document.querySelectorAll('.cancel-category-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.getElementById('add-main-category-form').style.display = 'none';
                    document.getElementById('add-subcategory-form').style.display = 'none';
                });
            });

            // Обработчики форм
            document.getElementById('main-category-form').addEventListener('submit', handleAddMainCategory);
            document.getElementById('subcategory-form').addEventListener('submit', handleAddSubcategory);

            // Обработчик изменения типа для подкатегорий
            document.getElementById('subcategory-type').addEventListener('change', async function () {
                await populateParentCategorySelectForForm();
            });

            // Добавляем обработчики для раскрытия/скрытия подкатегорий
            document.querySelectorAll('.toggle-subcategories').forEach(btn => {
                btn.addEventListener('click', function () {
                    const categoryId = this.dataset.id;
                    const subcategoriesList = document.querySelector(`.subcategories-list[data-parent="${categoryId}"]`);
                    const icon = this.querySelector('i');

                    if (subcategoriesList.style.display === 'none' || !subcategoriesList.style.display) {
                        subcategoriesList.style.display = 'block';
                        icon.className = 'fas fa-chevron-up';
                    } else {
                        subcategoriesList.style.display = 'none';
                        icon.className = 'fas fa-chevron-down';
                    }
                });
            });

            // Обработчики для динамического добавления полей подкатегорий
            document.addEventListener('click', async function (e) {
                // Кнопка "Добавить еще поле"
                if (e.target.closest('.add-field-btn')) {
                    const fieldsContainer = document.getElementById('subcategory-fields');
                    const fieldGroup = document.createElement('div');
                    fieldGroup.className = 'subcategory-field-group';
                    fieldGroup.innerHTML = `
                <div class="input-with-button">
                    <input type="text" class="form-control subcategory-name-input" 
                        placeholder="Название подкатегории" required>
                    <button type="button" class="btn btn-danger remove-field-btn" title="Удалить это поле">
                        <i class="fas fa-minus"></i>
                    </button>
                </div>
            `;
                    fieldsContainer.appendChild(fieldGroup);

                    // Фокусируемся на новом поле
                    fieldGroup.querySelector('.subcategory-name-input').focus();
                }

                // Кнопка "Удалить поле"
                if (e.target.closest('.remove-field-btn')) {
                    const fieldGroup = e.target.closest('.subcategory-field-group');
                    // Не удаляем первое поле
                    if (!fieldGroup.classList.contains('first-field')) {
                        fieldGroup.remove();
                    }
                }
            });

            // Обработчики удаления категорий
            document.querySelectorAll('.delete-category').forEach(btn => {
                btn.addEventListener('click', function () {
                    const categoryId = this.closest('.category-item').dataset.id;
                    deleteCategory(categoryId);
                });
            });
        }

        // Заполняем список основных категорий для формы подкатегорий
        async function populateParentCategorySelectForForm() {
            const typeSelect = document.getElementById('subcategory-type');
            const parentSelect = document.getElementById('parent-category');

            if (!typeSelect || !parentSelect) return;

            const type = typeSelect.value || 'expense';

            // Получаем только основные категории (parentId === 0) нужного типа
            const mainCategories = await db.categories
                .where('type')
                .equals(type)
                .and(cat => cat.parentId === 0)
                .toArray();

            parentSelect.innerHTML = mainCategories.length === 0
                ? '<option value="">Нет доступных категорий</option>'
                : '<option value="">Выберите основную категорию</option>' +
                mainCategories.map(cat => `<option value="${cat.id}">${cat.name}</option>`).join('');
        }

        // Рендеринг элемента категории
        function renderCategoryItem(category, allCategories) {
            const subcategories = allCategories.filter(c => c.parentId === category.id);

            return `
        <div class="category-item main-category" data-id="${category.id}">
            <div class="category-header">
                <div class="category-name">
                    <i class="fas fa-folder"></i>
                    ${category.name}
                </div>
                <div class="category-actions">
                    <button class="btn-icon toggle-subcategories" data-id="${category.id}" title="Показать/скрыть подкатегории">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                    <button class="btn-icon delete-category" title="Удалить">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
            
            ${subcategories.length > 0 ? `
                <div class="subcategories-list" data-parent="${category.id}" style="display: none;">
                    ${subcategories.map(sub => `
                        <div class="category-item subcategory" data-id="${sub.id}">
                            <div class="category-name">
                                <i class="fas fa-folder-open"></i>
                                ${sub.name}
                            </div>
                            <div class="category-actions">
                                <button class="btn-icon delete-category" title="Удалить">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            ` : ''}
        </div>
    `;
        }

        // Заполняем список основных категорий для формы подкатегорий
        async function populateParentCategorySelectForForm() {
            const typeSelect = document.getElementById('subcategory-type');
            const parentSelect = document.getElementById('parent-category');

            if (!typeSelect || !parentSelect) return;

            const type = typeSelect.value || 'expense';

            // Получаем только основные категории (parentId === 0) нужного типа
            const mainCategories = await db.categories
                .where('type')
                .equals(type)
                .and(cat => cat.parentId === 0)
                .toArray();

            parentSelect.innerHTML = mainCategories.length === 0
                ? '<option value="">Нет доступных категорий</option>'
                : '<option value="">Выберите основную категорию</option>' +
                mainCategories.map(cat => `<option value="${cat.id}">${cat.name}</option>`).join('');
        }


        // Функция загрузки страницы лимитов (ОБНОВЛЕННАЯ ВЕРСИЯ)
        async function loadLimitsPage() {
            const page = document.getElementById('page-limits');

            // Получаем данные: запланированный доход, категории расходов, текущие лимиты
            const currentMonth = new Date().toISOString().slice(0, 7);
            let monthlyPlan = await db.monthlyPlans.where('month').equals(currentMonth).first();

            if (!monthlyPlan) {
                monthlyPlan = { plannedIncome: 0 };
            }

            // Получаем все категории расходов
            const expenseCategories = await db.categories.where('type').equals('expense').toArray();
            const limits = await db.limits.toArray();

            // Рассчитываем расходы за текущий месяц по категориям
            const firstDayOfMonth = currentMonth + '-01';
            const lastDayOfMonth = new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0)
                .toISOString().split('T')[0];

            const monthTransactions = await db.transactions
                .where('date')
                .between(firstDayOfMonth, lastDayOfMonth)
                .toArray();

            // Создаем Map для быстрого поиска категорий
            const categoriesMap = new Map();
            expenseCategories.forEach(c => categoriesMap.set(c.id, c));

            // Группируем расходы по категориям
            const categoryExpenses = new Map();
            monthTransactions
                .filter(t => t.type === 'expense')
                .forEach(t => {
                    let categoryId = t.categoryId;
                    let category = categoriesMap.get(categoryId);

                    // Если это подкатегория, находим родительскую категорию
                    while (category && category.parentId !== 0) {
                        categoryId = category.parentId;
                        category = categoriesMap.get(categoryId);
                    }

                    // Если категория найдена, добавляем расход
                    if (category) {
                        const current = categoryExpenses.get(categoryId) || 0;
                        categoryExpenses.set(categoryId, current + t.amount);
                    }
                });

            // РАСЧЕТ ПРОЦЕНТОВ ДОБАВЛЯЕМ ЗДЕСЬ
            const totalPercent = limits.reduce((sum, limit) => sum + limit.limitValue, 0);
            const availablePercent = 100 - totalPercent;

            page.innerHTML = `
        <div class="limits-container">
            <div class="limits-header">
                <h3><i class="fas fa-chart-pie"></i> Лимиты на месяц</h3>
            </div>
            
            <!-- ИНДИКАТОР ИСПОЛЬЗОВАНИЯ ПРОЦЕНТОВ -->
            <div class="percentage-indicator-card">
                <h4><i class="fas fa-percentage"></i> Распределение лимитов</h4>
                <div class="percentage-info">
                    <div class="percentage-row">
                        <div class="percentage-label">Использовано:</div>
                        <div class="percentage-value ${totalPercent > 100 ? 'exceeded' : ''}">
                            ${totalPercent}% / 100%
                        </div>
                    </div>
                    <div class="percentage-row">
                        <div class="percentage-label">Свободно для распределения:</div>
                        <div class="percentage-value ${availablePercent < 0 ? 'negative' : ''}">
                            ${availablePercent}%
                        </div>
                    </div>
                    <div class="percentage-progress">
                        <div class="progress-bar-bg">
                            <div class="progress-bar-used" style="width: ${Math.min(totalPercent, 100)}%; 
                                background-color: ${totalPercent > 100 ? '#ff3b30' : '#4cd964'};">
                            </div>
                            ${totalPercent > 100 ?
                    `<div class="progress-bar-exceeded" style="width: ${totalPercent - 100}%;"></div>` : ''}
                        </div>
                        <div class="percentage-markers">
                            <span class="marker">0%</span>
                            <span class="marker">50%</span>
                            <span class="marker">100%</span>
                        </div>
                    </div>
                    ${totalPercent > 100 ?
                    '<div class="percentage-warning"><i class="fas fa-exclamation-triangle"></i> Внимание: общая сумма лимитов превышает 100%</div>' : ''}
                </div>
            </div>
            
            <!-- Планируемый доход -->
            <div class="planned-income-card">
                <h4><i class="fas fa-money-bill-wave"></i> Планируемый доход</h4>
                <div class="form-group">
                    <label>Сумма дохода на этот месяц (₽):</label>
                    <div class="input-with-button">
                        <input type="number" id="planned-income" class="form-control" 
                               value="${monthlyPlan.plannedIncome}" step="1000" min="0">
                        <button class="btn btn-primary" id="save-planned-income">
                            <i class="fas fa-save"></i> Сохранить
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Настройка лимитов -->
            <div class="limits-setup">
                <div class="limits-header-row">
                    <h4><i class="fas fa-sliders-h"></i> Настройка лимитов</h4>
                    <button class="btn btn-primary" id="add-limit-btn">
                        <i class="fas fa-plus"></i> Добавить лимит
                    </button>
                </div>
                
                <!-- Форма добавления лимита -->
                <div class="add-limit-form" id="add-limit-form" style="display: none;">
                    <h5>Добавить лимит для категории</h5>
                    <form id="new-limit-form">
                        <div class="form-group">
                            <label>Категория:</label>
                            <select id="limit-category" class="form-control">
                                <option value="">Выберите категорию</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Лимит (% от дохода):</label>
                            <input type="number" id="limit-percentage" class="form-control" 
                                   min="0" max="100" step="1" placeholder="20">
                        </div>
                        
                        <div class="form-buttons">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-plus"></i> Добавить
                            </button>
                            <button type="button" class="btn btn-secondary" id="cancel-limit-btn">
                                <i class="fas fa-times"></i> Отмена
                            </button>
                        </div>
                    </form>
                </div>
                
                <!-- Список лимитов -->
                <div class="limits-list" id="limits-list">
                    ${limits.length === 0 ?
                    '<p class="text-muted">Лимиты не установлены. Добавьте первый лимит.</p>' :
                    await renderLimitsList(limits, expenseCategories, monthlyPlan.plannedIncome, categoryExpenses)
                }
                </div>
            </div>
        </div>
    `;

            // Заполняем выпадающий список категорий
            await populateLimitCategorySelect();

            // Обработчик сохранения планируемого дохода
            document.getElementById('save-planned-income').addEventListener('click', async () => {
                const plannedIncome = parseFloat(document.getElementById('planned-income').value);

                if (plannedIncome < 0) {
                    alert('Доход не может быть отрицательным!');
                    return;
                }

                try {
                    // Сохраняем или обновляем
                    if (monthlyPlan.id) {
                        await db.monthlyPlans.update(monthlyPlan.id, { plannedIncome: plannedIncome });
                    } else {
                        await db.monthlyPlans.add({
                            month: currentMonth,
                            plannedIncome: plannedIncome
                        });
                    }

                    alert('Планируемый доход сохранен!');
                    await loadLimitsPage();
                } catch (error) {
                    alert('Ошибка: ' + error.message);
                }
            });

            // Обработчики для добавления лимитов
            document.getElementById('add-limit-btn').addEventListener('click', () => {
                document.getElementById('add-limit-form').style.display = 'block';
            });

            document.getElementById('cancel-limit-btn').addEventListener('click', () => {
                document.getElementById('add-limit-form').style.display = 'none';
                document.getElementById('new-limit-form').reset();
            });

            // Обработчик формы добавления лимита
            document.getElementById('new-limit-form').addEventListener('submit', handleAddLimit);

            // Обработчики для кнопок редактирования и удаления лимитов
            setTimeout(() => {
                // Сохранение лимита при изменении инпута (потере фокуса)
                document.querySelectorAll('.limit-percentage-input').forEach(input => {
                    input.addEventListener('change', async function () {
                        const limitItem = this.closest('.limit-item');
                        const limitId = parseInt(limitItem.dataset.id);
                        const newValue = parseInt(this.value);

                        if (newValue < 0 || newValue > 100) {
                            alert('Введите значение от 0 до 100%');
                            this.value = this.defaultValue;
                            return;
                        }

                        // Получаем текущие лимиты
                        const limits = await db.limits.toArray();
                        const currentLimit = limits.find(l => l.id === limitId);
                        const currentTotal = limits.reduce((sum, l) => sum + l.limitValue, 0);
                        const newTotal = currentTotal - currentLimit.limitValue + newValue;

                        // Проверяем превышение
                        if (newTotal > 100) {
                            const availablePercent = 100 - (currentTotal - currentLimit.limitValue);
                            const message = 'Общая сумма лимитов превысит 100%\n\n' +
                                'Текущая сумма: ' + currentTotal + '%\n' +
                                'После изменения: ' + newTotal + '% (превышение на ' + (newTotal - 100) + '%)\n\n' +
                                'Максимально можно установить: ' + availablePercent + '%\n\n' +
                                'Хотите продолжить?';

                            if (!confirm(message)) {
                                this.value = currentLimit.limitValue;
                                return;
                            }
                        }

                        try {
                            await db.limits.update(limitId, { limitValue: newValue });
                            await loadLimitsPage();
                        } catch (error) {
                            alert('Ошибка при обновлении: ' + error.message);
                            this.value = currentLimit.limitValue;
                        }
                    });
                });

                document.querySelectorAll('.delete-limit').forEach(btn => {
                    btn.addEventListener('click', async function () {
                        const limitItem = this.closest('.limit-item');
                        const limitId = parseInt(limitItem.dataset.id);

                        if (confirm('Удалить этот лимит?')) {
                            try {
                                await db.limits.delete(limitId);
                                await loadLimitsPage();
                            } catch (error) {
                                alert('Ошибка при удалении: ' + error.message);
                            }
                        }
                    });
                });

                // ИНИЦИАЛИЗИРУЕМ ПЕРЕТАСКИВАНИЕ
                setTimeout(initDragAndDrop, 100);
            }, 100);
        }

        // Функция рендеринга списка лимитов
        async function renderLimitsList(limits, expenseCategories, plannedIncome, categoryExpenses) {
            let html = '';

            for (const limit of limits) {
                const category = expenseCategories.find(c => c.id === limit.categoryId);
                if (!category) continue;

                // Находим родительскую категорию для подкатегорий
                let categoryName = category.name;
                if (category.parentId !== 0) {
                    const parentCategory = expenseCategories.find(c => c.id === category.parentId);
                    categoryName = `${parentCategory ? parentCategory.name : 'Неизвестно'} → ${category.name}`;
                }

                // Сумма лимита в деньгах
                const limitAmount = plannedIncome * (limit.limitValue / 100);

                // Расходы по этой категории
                const spent = categoryExpenses.get(category.id) || 0;

                // Процент использования лимита
                const usagePercentage = limitAmount > 0 ? (spent / limitAmount) * 100 : 0;

                // Превышение лимита
                const overspend = spent - limitAmount;

                // Определяем цвет индикатора
                let indicatorColor = '#4cd964'; // зеленый
                if (usagePercentage > 80 && usagePercentage <= 100) {
                    indicatorColor = '#ff9500'; // оранжевый
                } else if (usagePercentage > 100) {
                    indicatorColor = '#ff3b30'; // красный
                }

                html += `
            <div class="limit-item" data-id="${limit.id}" data-category-id="${category.id}" draggable="true">
                <div class="limit-header">
                    <div class="limit-category-info">
                        <!-- Рукоятка для перетаскивания -->
                        <span class="drag-handle" title="Перетащите для изменения порядка">
                            <i class="fas fa-grip-vertical drag-icon"></i>
                        </span>
                        <div class="limit-category-name">${categoryName}</div>
                        <button class="btn-icon delete-limit" title="Удалить">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
                
                <div class="limit-details">
                    <div class="limit-setting">
                        <div class="limit-input-group">
                            <label>Лимит:</label>
                            <div class="limit-input-with-button">
                                <input type="number" class="limit-percentage-input form-control-sm" 
                                       value="${limit.limitValue}" min="0" max="100" step="1">
                                <span class="limit-percentage-suffix">%</span>
                            </div>
                        </div>
                        <div class="limit-amount">
                            ${limitAmount.toFixed(2)} ₽
                        </div>
                    </div>
                    
                    <div class="limit-progress">
                        <div class="progress-info">
                            <div class="spent-amount">
                                <span class="spent-label">Потрачено:</span>
                                <span class="spent-value">${spent.toFixed(2)} ₽</span>
                            </div>
                            <div class="progress-percentage">
                                ${usagePercentage.toFixed(1)}%
                            </div>
                        </div>
                        
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${Math.min(usagePercentage, 100)}%; background-color: ${indicatorColor};"></div>
                        </div>
                        
                        ${overspend > 0 ? `
                            <div class="overspend-warning">
                                <i class="fas fa-exclamation-triangle"></i>
                                Превышение на ${overspend.toFixed(2)} ₽
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
        `;
            }

            return html;
        }

        // Заполняем выпадающий список категорий для лимитов
        async function populateLimitCategorySelect() {
            const select = document.getElementById('limit-category');

            // Получаем все категории расходов
            const expenseCategories = await db.categories.where('type').equals('expense').toArray();
            const limits = await db.limits
                .orderBy('order') // Сортируем по порядку
                .toArray();

            // Фильтруем категории, для которых уже есть лимиты
            const categoriesWithLimits = limits.map(l => l.categoryId);
            const availableCategories = expenseCategories.filter(c => !categoriesWithLimits.includes(c.id));

            if (availableCategories.length === 0) {
                select.innerHTML = '<option value="">Нет доступных категорий</option>';
                return;
            }

            // Создаем опции с группировкой по родительским категориям
            const mainCategories = availableCategories.filter(c => c.parentId === 0);
            let optionsHTML = '<option value="">Выберите категорию</option>';

            for (const mainCat of mainCategories) {
                // Основная категория
                optionsHTML += `<option value="${mainCat.id}">${mainCat.name}</option>`;

                // Подкатегории
                const subcategories = availableCategories.filter(c => c.parentId === mainCat.id);
                for (const subCat of subcategories) {
                    optionsHTML += `<option value="${subCat.id}">&nbsp;&nbsp;↳ ${subCat.name}</option>`;
                }
            }

            select.innerHTML = optionsHTML;
        }

        // Обработчик добавления лимита 
        async function handleAddLimit(e) {
            e.preventDefault();

            const categoryId = parseInt(document.getElementById('limit-category').value);
            const limitValue = parseInt(document.getElementById('limit-percentage').value);

            if (!categoryId || !limitValue) {
                alert('Заполните все поля!');
                return;
            }

            if (limitValue <= 0 || limitValue > 100) {
                alert('Лимит должен быть от 1 до 100%');
                return;
            }

            try {
                // Получаем текущие лимиты
                const limits = await db.limits.toArray();

                // Считаем сумму текущих процентов
                const currentTotalPercent = limits.reduce((sum, limit) => sum + limit.limitValue, 0);
                const newTotalPercent = currentTotalPercent + limitValue;

                // Проверяем превышение
                if (newTotalPercent > 100) {
                    const availablePercent = 100 - currentTotalPercent;
                    const message = 'Общая сумма лимитов превысит 100%\n\n' +
                        'Текущие лимиты: ' + currentTotalPercent + '%\n' +
                        'Добавляемый лимит: ' + limitValue + '%\n' +
                        'Будет: ' + newTotalPercent + '% (превышение на ' + (newTotalPercent - 100) + '%)\n\n' +
                        'Свободно для распределения: ' + availablePercent + '%\n\n' +
                        'Хотите продолжить?';

                    if (!confirm(message)) {
                        return;
                    }
                }

                await db.limits.add({
                    categoryId: categoryId,
                    limitType: 'percentage',
                    limitValue: limitValue,
                    order: limits.length // Новый лимит в конец
                });

                alert('Лимит добавлен!');
                document.getElementById('add-limit-form').style.display = 'none';
                e.target.reset();
                await loadLimitsPage();

            } catch (error) {
                alert('Ошибка: ' + error.message);
            }
        }

        // Инициализация перетаскивания для лимитов
        function initDragAndDrop() {
            const limitsList = document.getElementById('limits-list');
            if (!limitsList) return;

            const limitItems = limitsList.querySelectorAll('.limit-item');
            let draggedItem = null;

            limitItems.forEach(item => {
                // Начало перетаскивания
                item.addEventListener('dragstart', function (e) {
                    draggedItem = this;
                    setTimeout(() => this.classList.add('dragging'), 0);
                    e.dataTransfer.effectAllowed = 'move';

                    // Устанавливаем данные для перетаскивания
                    e.dataTransfer.setData('text/plain', this.dataset.id);
                });

                // Конец перетаскивания
                item.addEventListener('dragend', function () {
                    this.classList.remove('dragging');
                    draggedItem = null;

                    // Убираем все drag-over классы
                    limitItems.forEach(item => item.classList.remove('drag-over'));

                    // Сохраняем новый порядок
                    saveLimitsOrder();
                });

                // Над элементом
                item.addEventListener('dragover', function (e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    if (draggedItem !== this) {
                        // Определяем положение курсора
                        const rect = this.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;

                        if (e.clientY < midpoint) {
                            this.classList.add('drag-over');
                            this.style.borderTop = '3px solid #3498db';
                            this.style.borderBottom = 'none';
                        } else {
                            this.classList.add('drag-over');
                            this.style.borderBottom = '3px solid #3498db';
                            this.style.borderTop = 'none';
                        }
                    }
                });

                // Покинули элемент
                item.addEventListener('dragleave', function () {
                    this.classList.remove('drag-over');
                    this.style.borderTop = 'none';
                    this.style.borderBottom = 'none';
                });

                // Бросили на элемент
                item.addEventListener('drop', function (e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');
                    this.style.borderTop = 'none';
                    this.style.borderBottom = 'none';

                    if (draggedItem !== this) {
                        // Определяем, куда вставить
                        const rect = this.getBoundingClientRect();
                        const midpoint = rect.top + rect.height / 2;

                        if (e.clientY < midpoint) {
                            // Вставляем перед текущим элементом
                            this.parentNode.insertBefore(draggedItem, this);
                        } else {
                            // Вставляем после текущего элемента
                            if (this.nextSibling) {
                                this.parentNode.insertBefore(draggedItem, this.nextSibling);
                            } else {
                                this.parentNode.appendChild(draggedItem);
                            }
                        }
                    }
                });
            });

            // Добавляем подсказку о перетаскивании
            if (limitItems.length > 0) {
                const dragHint = document.createElement('div');
                dragHint.className = 'drag-hint';
                dragHint.innerHTML = '<i class="fas fa-info-circle"></i> Перетащите лимиты для изменения порядка';
                limitsList.appendChild(dragHint);
            }
        }

        // Сохранение порядка лимитов в базе данных
        async function saveLimitsOrder() {
            const limitsList = document.getElementById('limits-list');
            if (!limitsList) return;

            const limitItems = Array.from(limitsList.querySelectorAll('.limit-item:not(.drag-hint)'));

            try {
                // Обновляем порядок в базе данных
                for (let i = 0; i < limitItems.length; i++) {
                    const limitId = parseInt(limitItems[i].dataset.id);
                    await db.limits.update(limitId, { order: i });
                }

                // Показываем временное уведомление
                showTempNotification('Порядок лимитов сохранен!', 'success');

            } catch (error) {
                console.error('Ошибка сохранения порядка лимитов:', error);
                showTempNotification('Ошибка сохранения порядка: ' + error.message, 'error');
            }
        }

        // Вспомогательная функция для временных уведомлений
        function showTempNotification(message, type = 'info') {
            // Создаем элемент уведомления
            const notification = document.createElement('div');
            notification.className = `temp-notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 10px 20px;
        background-color: ${type === 'success' ? '#d4edda' : type === 'error' ? '#f8d7da' : '#d1ecf1'};
        color: ${type === 'success' ? '#155724' : type === 'error' ? '#721c24' : '#0c5460'};
        border: 1px solid ${type === 'success' ? '#c3e6cb' : type === 'error' ? '#f5c6cb' : '#bee5eb'};
        border-radius: 5px;
        z-index: 10000;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        animation: fadeInOut 3s ease;
    `;

            // Добавляем стили для анимации
            const style = document.createElement('style');
            style.textContent = `
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
    `;
            document.head.appendChild(style);

            document.body.appendChild(notification);

            // Удаляем через 3 секунды
            setTimeout(() => {
                notification.remove();
                style.remove();
            }, 3000);
        }


        // Функция загрузки страницы сводки
        async function loadReportPage() {
            const page = document.getElementById('page-report');

            page.innerHTML = `
        <div class="report-container">
            <div class="report-header">
                <h3><i class="fas fa-chart-bar"></i> Сводка и графики</h3>
                
                <!-- Фильтры по датам -->
                <div class="date-filters">
                    <div class="filter-row">
                        <div class="form-group">
                            <label>С:</label>
                            <input type="date" id="report-date-from" class="form-control" 
                                   value="${new Date(new Date().getFullYear(), new Date().getMonth(), 1).toISOString().split('T')[0]}">
                        </div>
                        
                        <div class="form-group">
                            <label>По:</label>
                            <input type="date" id="report-date-to" class="form-control" 
                                   value="${new Date().toISOString().split('T')[0]}">
                        </div>
                    </div>
                    
                    <!-- Кнопки переключения доходов/расходов -->
                    <div class="report-type-switcher">
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-outline active" id="show-expenses-btn">
                                <i class="fas fa-arrow-down"></i> Расходы
                            </button>
                            <button type="button" class="btn btn-outline" id="show-incomes-btn">
                                <i class="fas fa-arrow-up"></i> Доходы
                            </button>
                        </div>
                        <button class="btn btn-primary" id="apply-report-filter">
                            <i class="fas fa-filter"></i> Применить
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Общая статистика -->
            <div class="report-stats">
                <div class="stat-card income">
                    <div class="stat-icon">
                        <i class="fas fa-arrow-up"></i>
                    </div>
                    <div class="stat-info">
                        <div class="stat-label">Всего доходов</div>
                        <div class="stat-value" id="total-income">0 ₽</div>
                    </div>
                </div>
                
                <div class="stat-card expense">
                    <div class="stat-icon">
                        <i class="fas fa-arrow-down"></i>
                    </div>
                    <div class="stat-info">
                        <div class="stat-label">Всего расходов</div>
                        <div class="stat-value" id="total-expense">0 ₽</div>
                    </div>
                </div>
                
                <div class="stat-card balance">
                    <div class="stat-icon">
                        <i class="fas fa-balance-scale"></i>
                    </div>
                    <div class="stat-info">
                        <div class="stat-label">Остаток</div>
                        <div class="stat-value" id="total-balance-report">0 ₽</div>
                    </div>
                </div>
            </div>
            
            <!-- График и таблица -->
            <div class="report-content">
                <div class="chart-container">
                    <h4><i class="fas fa-chart-pie"></i> Распределение <span id="chart-type-label">расходов</span></h4>
                    <div class="chart-wrapper">
                        <canvas id="expenses-chart" width="300" height="300"></canvas>
                    </div>
                    <p class="text-muted" id="chart-no-data" style="display: none;">Нет данных для отображения графика</p>
                </div>
                
                <div class="report-table-container">
                    <h4><i class="fas fa-table"></i> Детализация по категориям</h4>
                    <div class="table-controls">
                        <button class="btn btn-sm btn-outline active" id="show-categories-btn">Только категории</button>
                        <button class="btn btn-sm btn-outline" id="show-subcategories-btn">С подкатегориями</button>
                    </div>
                    <div class="table-wrapper" id="report-table-wrapper">
                        <div id="report-table">
                            <p class="text-muted">Выберите период для отображения данных</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;

            // Обработчик фильтра
            document.getElementById('apply-report-filter').addEventListener('click', () => {
                updateReport();
            });

            // Обработчики переключения доходов/расходов
            document.getElementById('show-expenses-btn').addEventListener('click', function () {
                document.getElementById('show-expenses-btn').classList.add('active');
                document.getElementById('show-incomes-btn').classList.remove('active');
                window.currentReportType = 'expense';
                updateReport();
            });

            document.getElementById('show-incomes-btn').addEventListener('click', function () {
                document.getElementById('show-incomes-btn').classList.add('active');
                document.getElementById('show-expenses-btn').classList.remove('active');
                window.currentReportType = 'income';
                updateReport();
            });

            // Инициализируем тип отчета по умолчанию
            window.currentReportType = 'expense';

            // Первоначальная загрузка отчета
            await updateReport();
        }

        // Функция загрузки страницы экспорта
        async function loadExportPage() {
            const page = document.getElementById('page-export');

            page.innerHTML = `
        <div class="export-container">
            <h3><i class="fas fa-file-export"></i> Экспорт данных</h3>
            
            <div class="export-info">
                <p>Создайте полную резервную копию всех ваших финансовых данных.</p>
                <ul>
                    <li><strong>Счета</strong> (балансы, названия)</li>
                    <li><strong>Категории</strong> (доходы/расходы, иерархия)</li>
                    <li><strong>Операции</strong> (все транзакции с комментариями)</li>
                    <li><strong>Лимиты</strong> (бюджеты по категориям)</li>
                    <li><strong>Планы</strong> (планируемые доходы по месяцам)</li>
                </ul>
                <p class="warning-note">
                    <i class="fas fa-exclamation-triangle"></i>
                    Файл содержит конфиденциальную информацию. Храните его в безопасном месте.
                </p>
            </div>
            
            <div class="export-actions">
                <button class="btn btn-primary" id="export-data-btn">
                    <i class="fas fa-download"></i> Создать резервную копию
                </button>
                <button class="btn btn-secondary" id="export-view-btn">
                    <i class="fas fa-eye"></i> Показать данные (JSON)
                </button>
            </div>
            
            <div class="export-result" id="export-result">
                <!-- Здесь появится информация об экспорте -->
            </div>
            
            <div class="export-preview" id="export-preview" style="display: none;">
                <h4>Предпросмотр данных</h4>
                <div class="json-preview" id="json-preview"></div>
                <button class="btn btn-sm" id="close-preview">
                    <i class="fas fa-times"></i> Закрыть просмотр
                </button>
            </div>
        </div>
    `;

            // Обработчик кнопки "Создать резервную копию"
            document.getElementById('export-data-btn').addEventListener('click', exportData);

            // Обработчик кнопки "Показать данные"
            document.getElementById('export-view-btn').addEventListener('click', showDataPreview);

            // Обработчик закрытия предпросмотра
            document.getElementById('close-preview').addEventListener('click', () => {
                document.getElementById('export-preview').style.display = 'none';
            });
        }

        // Функция загрузки страницы импорта
        async function loadImportPage() {
            const page = document.getElementById('page-import');

            page.innerHTML = `
        <div class="import-container">
            <h3><i class="fas fa-file-import"></i> Импорт данных</h3>
            
            <div class="import-info">
                <p>Восстановите данные из резервной копии.</p>
                <div class="warning-box">
                    <i class="fas fa-exclamation-triangle"></i>
                    <div>
                        <strong>Внимание!</strong>
                        <p>Текущие данные будут полностью заменены на данные из файла.</p>
                        <p>Рекомендуется создать резервную копию перед импортом.</p>
                    </div>
                </div>
                
                <div class="file-upload-area" id="file-drop-area">
                    <div class="upload-icon">
                        <i class="fas fa-cloud-upload-alt"></i>
                    </div>
                    <p>Перетащите файл сюда или нажмите для выбора</p>
                    <input type="file" id="import-file-input" accept=".json, .finance" style="display: none;">
                    <button class="btn btn-outline" id="select-file-btn">
                        <i class="fas fa-folder-open"></i> Выбрать файл
                    </button>
                    <p class="file-hint">Поддерживаются файлы JSON (.json) или .finance</p>
                </div>
                
                <div class="import-preview" id="import-preview" style="display: none;">
                    <h4>Информация о файле</h4>
                    <div class="file-info-summary">
                        <div class="info-row">
                            <span class="label">Имя файла:</span>
                            <span id="file-name"></span>
                        </div>
                        <div class="info-row">
                            <span class="label">Размер:</span>
                            <span id="file-size"></span>
                        </div>
                        <div class="info-row">
                            <span class="label">Дата создания:</span>
                            <span id="file-date"></span>
                        </div>
                        <div class="info-row">
                            <span class="label">Версия:</span>
                            <span id="file-version"></span>
                        </div>
                        <div class="info-row">
                            <span class="label">Записей:</span>
                            <span id="file-records"></span>
                        </div>
                    </div>
                    
                    <div class="import-actions">
                        <button class="btn btn-primary" id="confirm-import-btn">
                            <i class="fas fa-check"></i> Начать импорт
                        </button>
                        <button class="btn btn-secondary" id="cancel-import-btn">
                            <i class="fas fa-times"></i> Отмена
                        </button>
                    </div>
                </div>
                
                <div class="import-result" id="import-result">
                    <!-- Здесь появится результат импорта -->
                </div>
            </div>
        </div>
    `;

            // Элементы
            const fileInput = document.getElementById('import-file-input');
            const selectBtn = document.getElementById('select-file-btn');
            const dropArea = document.getElementById('file-drop-area');
            const previewDiv = document.getElementById('import-preview');
            const resultDiv = document.getElementById('import-result');

            let importData = null;

            // Кнопка выбора файла
            selectBtn.addEventListener('click', () => fileInput.click());

            // Обработчик выбора файла
            fileInput.addEventListener('change', handleFileSelect);

            // Drag and drop
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.classList.add('dragover');
            });

            dropArea.addEventListener('dragleave', () => {
                dropArea.classList.remove('dragover');
            });

            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    handleFile(e.dataTransfer.files[0]);
                }
            });

            // Клик на область загрузки
            dropArea.addEventListener('click', () => fileInput.click());

            // Кнопки импорта/отмены
            document.getElementById('confirm-import-btn').addEventListener('click', confirmImport);
            document.getElementById('cancel-import-btn').addEventListener('click', cancelImport);

            // Обработчик выбора файла
            function handleFileSelect(e) {
                if (e.target.files.length) {
                    handleFile(e.target.files[0]);
                }
            }

            // Обработка файла
            async function handleFile(file) {
                resultDiv.innerHTML = '';

                // Проверка типа файла
                if (!file.name.match(/\.(json|finance)$/i)) {
                    showError('Неверный формат файла. Выберите файл .json или .finance');
                    return;
                }

                // Проверка размера (макс 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    showError('Файл слишком большой (максимум 10 МБ)');
                    return;
                }

                try {
                    // Чтение файла
                    const text = await file.text();
                    importData = JSON.parse(text);

                    // Проверка структуры
                    if (!importData.meta || !importData.meta.appName) {
                        showError('Неверный формат файла. Это не резервная копия "Мои Финансы"');
                        return;
                    }

                    // Показать информацию о файле
                    showFileInfo(file, importData);

                } catch (error) {
                    console.error('Ошибка чтения файла:', error);
                    showError('Ошибка при чтении файла: ' + error.message);
                }
            }

            // Показать информацию о файле
            function showFileInfo(file, data) {
                // Заполняем информацию
                document.getElementById('file-name').textContent = file.name;
                document.getElementById('file-size').textContent = formatFileSize(file.size);
                document.getElementById('file-date').textContent = data.meta.exportDate ?
                    new Date(data.meta.exportDate).toLocaleString() : 'Неизвестно';
                document.getElementById('file-version').textContent = data.meta.version || '1.0';

                // Считаем записи
                const counts = {
                    accounts: data.accounts ? data.accounts.length : 0,
                    categories: data.categories ? data.categories.length : 0,
                    transactions: data.transactions ? data.transactions.length : 0,
                    limits: data.limits ? data.limits.length : 0,
                    plans: data.monthlyPlans ? data.monthlyPlans.length : 0
                };

                document.getElementById('file-records').textContent =
                    `Счета: ${counts.accounts}, Категории: ${counts.categories}, Операции: ${counts.transactions}`;

                // Показываем превью
                previewDiv.style.display = 'block';

                // Прокручиваем к превью
                previewDiv.scrollIntoView({ behavior: 'smooth' });
            }

            // Подтверждение импорта
            async function confirmImport() {
                if (!importData) {
                    showError('Нет данных для импорта');
                    return;
                }

                const resultDiv = document.getElementById('import-result');
                resultDiv.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Импорт данных...</p>';

                try {
                    // Начинаем транзакцию
                    await db.transaction('rw',
                        db.accounts,
                        db.categories,
                        db.transactions,
                        db.monthlyPlans,
                        db.limits,
                        async () => {
                            // Очищаем все таблицы
                            await Promise.all([
                                db.accounts.clear(),
                                db.categories.clear(),
                                db.transactions.clear(),
                                db.monthlyPlans.clear(),
                                db.limits.clear()
                            ]);

                            // Импортируем данные
                            if (importData.accounts && importData.accounts.length) {
                                await db.accounts.bulkAdd(importData.accounts);
                            }

                            if (importData.categories && importData.categories.length) {
                                await db.categories.bulkAdd(importData.categories);
                            }

                            if (importData.transactions && importData.transactions.length) {
                                await db.transactions.bulkAdd(importData.transactions);
                            }

                            if (importData.monthlyPlans && importData.monthlyPlans.length) {
                                await db.monthlyPlans.bulkAdd(importData.monthlyPlans);
                            }

                            if (importData.limits && importData.limits.length) {
                                await db.limits.bulkAdd(importData.limits);
                            }
                        }
                    );

                    // Показываем успех
                    resultDiv.innerHTML = `
                <div class="success-message">
                    <i class="fas fa-check-circle"></i>
                    <div>
                        <strong>Импорт успешно завершен!</strong>
                        <p>Данные восстановлены из резервной копии.</p>
                        <p><strong>Импортировано:</strong></p>
                        <ul>
                            ${importData.accounts ? `<li>Счетов: ${importData.accounts.length}</li>` : ''}
                            ${importData.categories ? `<li>Категорий: ${importData.categories.length}</li>` : ''}
                            ${importData.transactions ? `<li>Операций: ${importData.transactions.length}</li>` : ''}
                        </ul>
                        <p>Перезагрузите страницу или перейдите на главную.</p>
                    </div>
                </div>
            `;

                    // Обновляем баланс
                    setTimeout(() => {
                        updateTotalBalance();
                    }, 1000);

                } catch (error) {
                    console.error('Ошибка импорта:', error);
                    resultDiv.innerHTML = `
                <div class="error-message">
                    <i class="fas fa-exclamation-circle"></i>
                    <div>
                        <strong>Ошибка при импорте!</strong>
                        <p>${error.message}</p>
                        <p>Попробуйте создать новую резервную копию и повторить.</p>
                    </div>
                </div>
            `;
                }
            }

            // Отмена импорта
            function cancelImport() {
                document.getElementById('import-preview').style.display = 'none';
                document.getElementById('import-file-input').value = '';
                importData = null;
            }

            // Показать ошибку
            function showError(message) {
                const resultDiv = document.getElementById('import-result');
                resultDiv.innerHTML = `
            <div class="error-message">
                <i class="fas fa-exclamation-circle"></i>
                <div>
                    <strong>Ошибка!</strong>
                    <p>${message}</p>
                </div>
            </div>
        `;
            }

            // Форматирование размера файла
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Б';
                const k = 1024;
                const sizes = ['Б', 'КБ', 'МБ', 'ГБ'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
        }


        // Функция экспорта всех данных в файл
        async function exportData() {
            const resultDiv = document.getElementById('export-result');
            resultDiv.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Подготовка данных...</p>';

            try {
                // Собираем все данные из базы
                const data = {
                    // Метаинформация
                    meta: {
                        appName: "Мои Финансы",
                        exportDate: new Date().toISOString(),
                        version: "1.0",
                        dbVersion: 4
                    },

                    // Данные таблиц
                    accounts: await db.accounts.toArray(),
                    categories: await db.categories.toArray(),
                    transactions: await db.transactions.toArray(),
                    monthlyPlans: await db.monthlyPlans.toArray(),
                    limits: await db.limits.toArray()
                };

                // Преобразуем в JSON
                const jsonData = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Создаем имя файла с датой
                const dateStr = new Date().toISOString().split('T')[0];
                const fileName = `мои_финансы_${dateStr}.json`;

                // Создаем ссылку для скачивания
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Освобождаем память
                URL.revokeObjectURL(url);

                // Показываем результат
                resultDiv.innerHTML = `
            <div class="success-message">
                <i class="fas fa-check-circle"></i>
                <div>
                    <strong>Экспорт успешно завершен!</strong>
                    <p>Файл "${fileName}" скачан на ваше устройство.</p>
                    <p class="file-info">
                        <i class="fas fa-info-circle"></i>
                        Размер файла: ${Math.round(blob.size / 1024)} КБ
                    </p>
                </div>
            </div>
        `;

            } catch (error) {
                console.error('Ошибка экспорта:', error);
                resultDiv.innerHTML = `
            <div class="error-message">
                <i class="fas fa-exclamation-circle"></i>
                <div>
                    <strong>Ошибка при экспорте!</strong>
                    <p>${error.message}</p>
                </div>
            </div>
        `;
            }
        }

        // Функция предпросмотра данных
        async function showDataPreview() {
            const previewDiv = document.getElementById('export-preview');
            const jsonPreview = document.getElementById('json-preview');

            jsonPreview.innerHTML = '<p><i class="fas fa-spinner fa-spin"></i> Загрузка данных...</p>';
            previewDiv.style.display = 'block';

            try {
                // Получаем краткую статистику
                const accountsCount = await db.accounts.count();
                const categoriesCount = await db.categories.count();
                const transactionsCount = await db.transactions.count();
                const limitsCount = await db.limits.count();
                const plansCount = await db.monthlyPlans.count();

                // Собираем только метаданные для предпросмотра
                const previewData = {
                    meta: {
                        appName: "Мои Финансы",
                        exportDate: new Date().toISOString(),
                        statistics: {
                            accounts: accountsCount,
                            categories: categoriesCount,
                            transactions: transactionsCount,
                            limits: limitsCount,
                            monthlyPlans: plansCount
                        }
                    },
                    // Примеры первых записей
                    sample: {
                        accounts: await db.accounts.limit(2).toArray(),
                        categories: await db.categories.where('parentId').equals(0).limit(3).toArray(),
                        recentTransactions: await db.transactions.orderBy('date').reverse().limit(3).toArray()
                    }
                };

                // Форматируем JSON с подсветкой
                const jsonStr = JSON.stringify(previewData, null, 2);
                jsonPreview.innerHTML = `<pre>${escapeHtml(jsonStr)}</pre>`;

            } catch (error) {
                jsonPreview.innerHTML = `<p class="error">Ошибка: ${error.message}</p>`;
            }
        }

        // Вспомогательная функция для экранирования HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Заполняем список счетов в форме
        async function populateAccountSelect() {
            const select = document.getElementById('transaction-account');
            const accounts = await db.accounts.toArray();

            // ДОБАВЛЯЕМ ОПЦИЮ "НЕ ВЫБРАНО" ПЕРВОЙ В СПИСКЕ
            select.innerHTML = '<option value="">Не выбрано</option>' +
                accounts.map(acc =>
                    `<option value="${acc.id}">${acc.name} (${acc.balance.toFixed(2)} ₽)</option>`
                ).join('');
        }

        // Заполняем список счетов-получателей - ОБНОВЛЕНО
        async function populateToAccountSelect() {
            const fromAccountSelect = document.getElementById('transaction-account');
            const toAccountSelect = document.getElementById('transaction-to-account');

            if (!fromAccountSelect || !toAccountSelect) return;

            const fromAccountId = parseInt(fromAccountSelect.value);
            const accounts = await db.accounts.toArray();

            // ДОБАВЛЯЕМ ОПЦИЮ "НЕ ВЫБРАНО" ПЕРВОЙ В СПИСКЕ
            toAccountSelect.innerHTML = '<option value="">Не выбрано</option>';

            // Фильтруем счета: исключаем выбранный счет-отправитель
            // Но только если счет-отправитель действительно выбран
            const availableAccounts = fromAccountId
                ? accounts.filter(acc => acc.id !== fromAccountId)
                : accounts;

            // Добавляем остальные счета
            toAccountSelect.innerHTML += availableAccounts.map(acc =>
                `<option value="${acc.id}">${acc.name} (${acc.balance.toFixed(2)} ₽)</option>`
            ).join('');
        }


        // Заполняем список категорий в зависимости от типа операции
        async function populateCategorySelect() {
            const typeSelect = document.getElementById('transaction-type');
            const categorySelect = document.getElementById('transaction-category');

            if (!typeSelect || !categorySelect) return;

            const type = typeSelect.value;

            // Получаем категории соответствующего типа (только основные)
            const categories = await db.categories
                .where('type')
                .equals(type)
                .and(cat => cat.parentId === 0)
                .toArray();

            categorySelect.innerHTML = categories.map(cat =>
                `<option value="${cat.id}">${cat.name}</option>`
            ).join('');

            // Показываем/скрываем подкатегории для первой категории в списке
            if (categories.length > 0) {
                await showSubcategorySelect(categories[0].id);
            } else {
                const subcategoryGroup = document.getElementById('subcategory-group');
                if (subcategoryGroup) {
                    subcategoryGroup.style.display = 'none';
                }
            }
        }

        // Показываем подкатегории для выбранной категории
        async function showSubcategorySelect(categoryId) {
            const subcategoryGroup = document.getElementById('subcategory-group');
            const subcategorySelect = document.getElementById('transaction-subcategory');

            if (!subcategoryGroup || !subcategorySelect) return;

            // Получаем подкатегории для выбранной категории
            const subcategories = await db.categories
                .where('parentId')
                .equals(parseInt(categoryId))
                .toArray();

            if (subcategories.length > 0) {
                subcategoryGroup.style.display = 'block';
                subcategorySelect.innerHTML = `
            <option value="">Не выбрано</option>
            ${subcategories.map(sub => `<option value="${sub.id}">${sub.name}</option>`).join('')}
        `;
            } else {
                subcategoryGroup.style.display = 'none';
            }
        }

        // Обработчик добавления новой операции
        async function handleAddTransaction(e) {
            e.preventDefault();

            const type = document.getElementById('transaction-type').value;
            const amount = parseFloat(document.getElementById('transaction-amount').value);
            const accountId = parseInt(document.getElementById('transaction-account').value);
            const date = document.getElementById('transaction-date').value;
            const comment = document.getElementById('transaction-comment').value;

            // Для переводов получаем счет-получатель
            let toAccountId = null;
            if (type === 'transfer') {
                toAccountId = parseInt(document.getElementById('transaction-to-account').value);
            }

            // Для доходов/расходов получаем категорию
            let categoryId = null;
            let subcategoryId = null;
            if (type !== 'transfer') {
                categoryId = parseInt(document.getElementById('transaction-category').value);
                subcategoryId = document.getElementById('transaction-subcategory').value;
            }

            // Используем подкатегорию, если выбрана, иначе основную категорию
            const finalCategoryId = subcategoryId ? parseInt(subcategoryId) : categoryId;

            const transaction = {
                type: type,
                amount: amount,
                accountId: accountId,
                date: date,
                comment: comment
            };

            // Добавляем дополнительные поля в зависимости от типа
            if (type === 'transfer') {
                transaction.toAccountId = toAccountId;
                transaction.categoryId = null;
            } else {
                const finalCategoryId = subcategoryId ? parseInt(subcategoryId) : categoryId;
                transaction.categoryId = finalCategoryId;
                transaction.toAccountId = null;
            }

            try {
                // 1. Добавляем транзакцию в базу
                const id = await db.transactions.add(transaction);
                console.log('Транзакция добавлена с ID:', id);

                // 2. Обновляем баланс счета
                if (type === 'transfer') {
                    // Для переводов обновляем два счета
                    const fromAccount = await db.accounts.get(accountId);
                    const toAccount = await db.accounts.get(toAccountId);

                    // Снимаем с одного счета
                    await db.accounts.update(accountId, {
                        balance: fromAccount.balance - amount
                    });

                    // Добавляем на другой счет
                    await db.accounts.update(toAccountId, {
                        balance: toAccount.balance + amount
                    });
                } else {
                    // Для доходов/расходов обновляем один счет
                    const account = await db.accounts.get(accountId);
                    const newBalance = type === 'income'
                        ? account.balance + amount
                        : account.balance - amount;

                    await db.accounts.update(accountId, { balance: newBalance });
                }

                // 3. Обновляем интерфейс
                await loadRecentTransactions();
                await updateTotalBalance();
                await populateAccountSelect();

                // 4. Сбрасываем форму
                e.target.reset();
                document.getElementById('transaction-date').value = new Date().toISOString().split('T')[0];
                document.getElementById('transaction-type').dispatchEvent(new Event('change'));

                alert('Операция успешно добавлена!');

            } catch (error) {
                console.error('Ошибка при добавлении операции:', error);
                alert('Ошибка: ' + error.message);
            }
        }

        // Загружаем операции (с фильтром по дате)
        async function loadRecentTransactions(filterDateFrom = null, filterDateTo = null) {
            const container = document.getElementById('transactions-list');

            let transactions;

            if (filterDateFrom && filterDateTo) {
                // Фильтруем по диапазону дат
                transactions = await db.transactions
                    .where('date')
                    .between(filterDateFrom, filterDateTo)
                    .reverse()
                    .toArray();
            } else {
                // Без фильтра - показываем последние 50 операций
                transactions = await db.transactions
                    .orderBy('date')
                    .reverse()
                    .limit(50)
                    .toArray();
            }

            if (transactions.length === 0) {
                container.innerHTML = '<p class="text-muted">Операций нет.</p>';
                return;
            }

            // Для каждой транзакции получим названия счета и категории
            const enrichedTransactions = await Promise.all(
                transactions.map(async (t) => {
                    const account = await db.accounts.get(t.accountId);

                    if (t.type === 'transfer') {
                        // Для переводов получаем оба счета
                        const toAccount = await db.accounts.get(t.toAccountId);
                        return {
                            ...t,
                            accountName: account?.name || 'Неизвестно',
                            toAccountName: toAccount?.name || 'Неизвестно',
                            categoryName: 'Перевод между счетами'
                        };
                    } else {
                        // Для доходов/расходов получаем категорию
                        const category = await db.categories.get(t.categoryId);
                        let categoryName = category?.name || 'Неизвестно';

                        // Если это подкатегория, получаем имя родительской категории
                        if (category && category.parentId !== 0) {
                            const parentCategory = await db.categories.get(category.parentId);
                            categoryName = `${parentCategory?.name || 'Неизвестно'} → ${categoryName}`;
                        }

                        return {
                            ...t,
                            accountName: account?.name || 'Неизвестно',
                            categoryName: categoryName
                        };
                    }
                })
            );

            container.innerHTML = enrichedTransactions.map(t => {
                if (t.type === 'transfer') {
                    return `
                <div class="transaction-item transfer" data-id="${t.id}">
                    <div class="transaction-header">
                        <span class="transaction-category">
                            <i class="fas fa-exchange-alt transfer-icon"></i>
                            Перевод между счетами
                        </span>
                        <span class="transaction-amount transfer">
                            -${t.amount.toFixed(2)} ₽
                        </span>
                    </div>
                    <div class="transfer-details">
                        <span><i class="fas fa-sign-out-alt"></i> ${t.accountName}</span>
                        <i class="fas fa-arrow-right transfer-arrow"></i>
                        <span><i class="fas fa-sign-in-alt"></i> ${t.toAccountName}</span>
                    </div>
                    <div class="transaction-details">
                        <span class="transaction-date">${t.date}</span>
                        ${t.comment ? `<span class="transaction-comment">${t.comment}</span>` : ''}
                    </div>
                    <div class="transaction-actions">
                        <button class="btn-icon edit-transaction" title="Редактировать">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn-icon delete-transaction" title="Удалить">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
                } else {
                    return `
                <div class="transaction-item ${t.type}" data-id="${t.id}">
                    <div class="transaction-header">
                        <span class="transaction-category">${t.categoryName}</span>
                        <span class="transaction-amount ${t.type}">
                            ${t.type === 'income' ? '+' : '-'}${t.amount.toFixed(2)} ₽
                        </span>
                    </div>
                    <div class="transaction-details">
                        <span class="transaction-account"><i class="fas fa-wallet"></i> ${t.accountName}</span>
                        <span class="transaction-date">${t.date}</span>
                        ${t.comment ? `<span class="transaction-comment">${t.comment}</span>` : ''}
                    </div>
                    <div class="transaction-actions">
                        <button class="btn-icon edit-transaction" title="Редактировать">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn-icon delete-transaction" title="Удалить">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
                }
            }).join('');

            // Добавляем обработчики для кнопок редактирования и удаления
            document.querySelectorAll('.edit-transaction').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const transactionId = this.closest('.transaction-item').dataset.id;
                    await editTransaction(transactionId);
                });
            });

            document.querySelectorAll('.delete-transaction').forEach(btn => {
                btn.addEventListener('click', async function () {
                    const transactionId = this.closest('.transaction-item').dataset.id;
                    await deleteTransaction(transactionId);
                });
            });
        }

        // Редактирование операции
        async function editTransaction(transactionId) {
            const transaction = await db.transactions.get(parseInt(transactionId));
            if (!transaction) return;

            // Находим категорию
            const category = await db.categories.get(transaction.categoryId);
            let parentCategoryId = category?.parentId || 0;
            if (parentCategoryId === 0) parentCategoryId = category?.id;

            // Создаем модальное окно
            const modalHTML = `
        <div class="modal-overlay" id="edit-transaction-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-edit"></i> Редактировать операцию</h3>
                    <button class="modal-close">&times;</button>
                </div>
                
                <div class="modal-body">
                    <form id="edit-transaction-form">
                        <div class="form-group">
                            <label>Тип операции:</label>
                                <select id="edit-transaction-type" class="form-control">
                                    <option value="expense" ${transaction.type === 'expense' ? 'selected' : ''}>Расход</option>
                                    <option value="income" ${transaction.type === 'income' ? 'selected' : ''}>Доход</option>
                                    <option value="transfer" ${transaction.type === 'transfer' ? 'selected' : ''}>Перевод</option>
                                </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Сумма (₽):</label>
                            <input type="number" id="edit-transaction-amount" class="form-control" 
                                   value="${transaction.amount}" step="0.01" min="0" required>
                        </div>
                        
                        <div class="form-group">
                            <label>Счет:</label>
                            <select id="edit-transaction-account" class="form-control"></select>
                        </div>

                        <div class="form-group" id="edit-to-account-group" style="${transaction.type === 'transfer' ? '' : 'display: none;'}">
                            <label>На счет:</label>
                            <select id="edit-transaction-to-account" class="form-control"></select>
                        </div>
                        
                        <div class="form-group">
                            <label>Категория:</label>
                            <select id="edit-transaction-category" class="form-control"></select>
                        </div>
                        
                        <div class="form-group" id="edit-subcategory-group" style="display: none;">
                            <label>Подкатегория:</label>
                            <select id="edit-transaction-subcategory" class="form-control"></select>
                        </div>
                        
                        <div class="form-group">
                            <label>Дата:</label>
                            <input type="date" id="edit-transaction-date" class="form-control" 
                                   value="${transaction.date}">
                        </div>
                        
                        <div class="form-group">
                            <label>Комментарий:</label>
                            <input type="text" id="edit-transaction-comment" class="form-control" 
                                   value="${transaction.comment || ''}" placeholder="На что?">
                        </div>
                        
                        <div class="modal-buttons">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Сохранить
                            </button>
                            <button type="button" class="btn btn-secondary" id="cancel-edit-transaction">
                                Отмена
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    `;

            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer.firstElementChild);

            const modal = document.getElementById('edit-transaction-modal');

            // Заполняем выпадающие списки
            await populateEditAccountSelect(transaction.accountId);
            await populateEditCategorySelect(transaction.type, parentCategoryId);
            await showEditSubcategorySelect(parentCategoryId, transaction.categoryId);

            // Обработчики
            modal.querySelector('.modal-close').addEventListener('click', () => modal.remove());
            modal.querySelector('#cancel-edit-transaction').addEventListener('click', () => modal.remove());

            modal.querySelector('#edit-transaction-type').addEventListener('change', async function () {
                await populateEditCategorySelect(this.value, null);
            });

            modal.querySelector('#edit-transaction-category').addEventListener('change', async function () {
                await showEditSubcategorySelect(this.value, null);
            });

            modal.querySelector('#edit-transaction-form').addEventListener('submit', async (e) => {
                e.preventDefault();

                const oldTransaction = transaction;
                const oldAccountId = oldTransaction.accountId;
                const oldAmount = oldTransaction.amount;
                const oldType = oldTransaction.type;

                const type = document.getElementById('edit-transaction-type').value;
                const amount = parseFloat(document.getElementById('edit-transaction-amount').value);
                const accountId = parseInt(document.getElementById('edit-transaction-account').value);
                const categoryId = parseInt(document.getElementById('edit-transaction-category').value);
                const subcategoryId = document.getElementById('edit-transaction-subcategory').value;
                const date = document.getElementById('edit-transaction-date').value;
                const comment = document.getElementById('edit-transaction-comment').value;

                // Используем подкатегорию, если выбрана, иначе основную категорию
                const finalCategoryId = subcategoryId ? parseInt(subcategoryId) : categoryId;

                const updatedTransaction = {
                    type: type,
                    amount: amount,
                    accountId: accountId,
                    categoryId: finalCategoryId,
                    date: date,
                    comment: comment
                };

                try {
                    // Обновляем транзакцию
                    await db.transactions.update(parseInt(transactionId), updatedTransaction);

                    // Корректируем балансы счетов
                    // Возвращаем старые деньги на старый счет
                    const oldAccount = await db.accounts.get(oldAccountId);
                    const oldAccountNewBalance = oldType === 'income'
                        ? oldAccount.balance - oldAmount
                        : oldAccount.balance + oldAmount;

                    await db.accounts.update(oldAccountId, { balance: oldAccountNewBalance });

                    // Добавляем новые деньги на новый счет
                    const newAccount = await db.accounts.get(accountId);
                    const newAccountNewBalance = type === 'income'
                        ? newAccount.balance + amount
                        : newAccount.balance - amount;

                    await db.accounts.update(accountId, { balance: newAccountNewBalance });

                    alert('Операция обновлена!');
                    modal.remove();
                    await loadRecentTransactions();
                    await updateTotalBalance();
                    await populateAccountSelect();

                } catch (error) {
                    alert('Ошибка: ' + error.message);
                }
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        // Удаление операции
        async function deleteTransaction(transactionId) {
            if (!confirm('Удалить эту операцию?')) return;

            try {
                const transaction = await db.transactions.get(parseInt(transactionId));
                if (!transaction) return;

                // Получаем счет
                const account = await db.accounts.get(transaction.accountId);

                // Если счет существует, обновляем баланс
                if (account) {
                    const newBalance = transaction.type === 'income'
                        ? account.balance - transaction.amount
                        : account.balance + transaction.amount;

                    await db.accounts.update(transaction.accountId, { balance: newBalance });
                } else {
                    console.warn(`Счет с ID ${transaction.accountId} не найден. Баланс не обновлен.`);
                }

                // Удаляем транзакцию
                await db.transactions.delete(parseInt(transactionId));

                await loadRecentTransactions();
                await updateTotalBalance();
                await populateAccountSelect();

                alert('Операция удалена!');

            } catch (error) {
                console.error('Ошибка при удалении операции:', error);
                alert('Ошибка: ' + error.message);
            }
        }

        // Вспомогательные функции для редактирования
        async function populateEditAccountSelect(selectedId) {
            const select = document.getElementById('edit-transaction-account');
            const accounts = await db.accounts.toArray();

            select.innerHTML = accounts.map(acc =>
                `<option value="${acc.id}" ${acc.id === selectedId ? 'selected' : ''}>
            ${acc.name} (${acc.balance.toFixed(2)} ₽)
        </option>`
            ).join('');
        }

        async function populateEditCategorySelect(type, selectedId) {
            const select = document.getElementById('edit-transaction-category');
            const categories = await db.categories
                .where('type')
                .equals(type)
                .and(cat => cat.parentId === 0)
                .toArray();

            select.innerHTML = categories.map(cat =>
                `<option value="${cat.id}" ${cat.id === selectedId ? 'selected' : ''}>
            ${cat.name}
        </option>`
            ).join('');

            if (categories.length > 0 && selectedId) {
                await showEditSubcategorySelect(selectedId, null);
            }
        }

        async function showEditSubcategorySelect(categoryId, selectedId) {
            const subcategoryGroup = document.getElementById('edit-subcategory-group');
            const subcategorySelect = document.getElementById('edit-transaction-subcategory');

            if (!subcategoryGroup || !subcategorySelect) return;

            // Получаем подкатегории для выбранной категории
            const subcategories = await db.categories
                .where('parentId')
                .equals(parseInt(categoryId))
                .toArray();

            if (subcategories.length > 0) {
                subcategoryGroup.style.display = 'block';
                subcategorySelect.innerHTML = `
            <option value="">Не выбрано</option>
            ${subcategories.map(sub => `<option value="${sub.id}" ${sub.id === selectedId ? 'selected' : ''}>${sub.name}</option>`).join('')}
        `;
            } else {
                subcategoryGroup.style.display = 'none';
            }
        }

        // Обновляем общий баланс (сумма по всем ВИДИМЫМ счетам)
        async function updateTotalBalance() {
            const accounts = await db.accounts.toArray();

            // Фильтруем только видимые счета (isVisible не равен false)
            const visibleAccounts = accounts.filter(acc => acc.isVisible !== false);
            const total = visibleAccounts.reduce((sum, acc) => sum + acc.balance, 0);

            document.getElementById('total-balance').textContent = `${total.toFixed(2)} ₽`;
        }

        // Обработчик добавления нового счета
        async function handleAddAccount(e) {
            e.preventDefault();

            const account = {
                name: document.getElementById('account-name').value,
                balance: parseFloat(document.getElementById('account-balance').value) || 0,
                type: document.getElementById('account-type').value,
                color: getRandomColor(),
                isVisible: true // По умолчанию новый счет видимый
            };

            try {
                await db.accounts.add(account);
                alert('Счет добавлен!');
                document.getElementById('add-account-form').style.display = 'none';
                e.target.reset();
                await loadAccountsPage();
                await populateAccountSelect();
            } catch (error) {
                alert('Ошибка: ' + error.message);
            }
        }

        // Редактирование счета
        async function editAccount(accountId) {
            const account = await db.accounts.get(parseInt(accountId));

            // Создаем модальное окно для редактирования
            const modalHTML = `
        <div class="modal-overlay" id="edit-account-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-edit"></i> Редактировать счет</h3>
                    <button class="modal-close">&times;</button>
                </div>
                
                <div class="modal-body">
                    <form id="edit-account-form">
                        <div class="form-group">
                            <label>Название счета:</label>
                            <input type="text" id="edit-account-name" class="form-control" 
                                   value="${account.name}" required>
                        </div>
                        
                        <div class="form-group">
                            <label>Текущий баланс:</label>
                            <input type="number" id="edit-account-balance" class="form-control" 
                                   value="${account.balance}" step="0.01">
                        </div>
                        
                        <div class="form-group">
                            <label>Тип счета:</label>
                            <select id="edit-account-type" class="form-control">
                                <option value="cash" ${account.type === 'cash' ? 'selected' : ''}>Наличные</option>
                                <option value="card" ${account.type === 'card' ? 'selected' : ''}>Банковская карта</option>
                                <option value="deposit" ${account.type === 'deposit' ? 'selected' : ''}>Депозит</option>
                                <option value="other" ${account.type === 'other' ? 'selected' : ''}>Другое</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>Цвет (для отображения):</label>
                            <input type="color" id="edit-account-color" class="form-control" 
                                   value="${account.color || '#4a6fa5'}">
                        </div>
                        
                        <!-- ДОБАВЛЯЕМ ПЕРЕКЛЮЧАТЕЛЬ ГЛАЗКА -->
                        <div class="form-group">
                            <div class="checkbox-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="edit-account-visible" 
                                           ${account.isVisible === false ? '' : 'checked'}>
                                    <span class="checkmark"></span>
                                    Учитывать в общем балансе (глазок)
                                </label>
                                <small class="text-muted">Если выключено, счет не будет учитываться в общей сумме</small>
                            </div>
                        </div>
                        
                        <div class="modal-buttons">
                            <button type="submit" class="btn btn-primary">
                                <i class="fas fa-save"></i> Сохранить
                            </button>
                            <button type="button" class="btn btn-secondary" id="cancel-edit-account">
                                Отмена
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    `;

            // Добавляем модальное окно в документ
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer.firstElementChild);

            const modal = document.getElementById('edit-account-modal');

            // Обработчики для модального окна
            modal.querySelector('.modal-close').addEventListener('click', () => {
                modal.remove();
            });

            modal.querySelector('#cancel-edit-account').addEventListener('click', () => {
                modal.remove();
            });

            modal.querySelector('#edit-account-form').addEventListener('submit', async (e) => {
                e.preventDefault();

                const updatedAccount = {
                    name: document.getElementById('edit-account-name').value,
                    balance: parseFloat(document.getElementById('edit-account-balance').value) || 0,
                    type: document.getElementById('edit-account-type').value,
                    color: document.getElementById('edit-account-color').value,
                    isVisible: document.getElementById('edit-account-visible').checked // ДОБАВЛЯЕМ
                };

                try {
                    await db.accounts.update(parseInt(accountId), updatedAccount);
                    alert('Счет обновлен!');
                    modal.remove();
                    await loadAccountsPage();
                    await populateAccountSelect();
                    await updateTotalBalance();
                } catch (error) {
                    alert('Ошибка: ' + error.message);
                }
            });

            // Закрытие по клику вне модального окна
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // Удаление счета
        async function deleteAccount(accountId) {
            if (confirm('Удалить этот счет? ВНИМАНИЕ: Все операции по этому счету будут перемещены на счет "Наличные".')) {
                try {
                    const account = await db.accounts.get(parseInt(accountId));
                    if (!account) return;

                    // Находим счет "Наличные" или создаем его
                    let cashAccount = await db.accounts.where('name').equals('Наличные').first();
                    if (!cashAccount) {
                        cashAccount = { name: 'Наличные', balance: 0, type: 'cash', color: '#27ae60' };
                        cashAccount.id = await db.accounts.add(cashAccount);
                    }

                    // Обновляем баланс наличных
                    await db.accounts.update(cashAccount.id, {
                        balance: cashAccount.balance + account.balance
                    });

                    // Переносим все операции на счет "Наличные"
                    await db.transactions
                        .where('accountId')
                        .equals(parseInt(accountId))
                        .modify({ accountId: cashAccount.id });

                    // Удаляем счет
                    await db.accounts.delete(parseInt(accountId));

                    await loadAccountsPage();
                    await populateAccountSelect();
                    await updateTotalBalance();

                    alert('Счет удален. Все операции перенесены на счет "Наличные".');
                } catch (error) {
                    console.error('Ошибка при удалении:', error);
                    alert('Ошибка при удалении: ' + error.message);
                }
            }
        }

        // Заполняем список основных категорий для подкатегорий
        async function populateParentCategorySelect() {
            const type = document.getElementById('subcategory-type').value || 'expense';
            await populateParentCategorySelectByType(type);
        }

        // Обработчик добавления основной категории
        async function handleAddMainCategory(e) {
            e.preventDefault();

            const category = {
                name: document.getElementById('main-category-name').value,
                type: document.getElementById('main-category-type').value,
                parentId: 0
            };

            try {
                await db.categories.add(category);
                document.getElementById('add-main-category-form').style.display = 'none';
                e.target.reset();
                await loadCategoriesPage();
            } catch (error) {
                alert('Ошибка: ' + error.message);
            }
        }

        // Обработчик добавления подкатегорий (МНОЖЕСТВЕННОЕ добавление)
        async function handleAddSubcategory(e) {
            e.preventDefault();

            const parentId = parseInt(document.getElementById('parent-category').value);

            if (!parentId) {
                alert('Выберите основную категорию!');
                return;
            }

            const parentCategory = await db.categories.get(parentId);

            if (!parentCategory) {
                alert('Основная категория не найдена!');
                return;
            }

            // Собираем все названия подкатегорий из всех полей
            const nameInputs = document.querySelectorAll('.subcategory-name-input');
            const subcategoryNames = Array.from(nameInputs)
                .map(input => input.value.trim())
                .filter(name => name.length > 0); // Отфильтровываем пустые

            if (subcategoryNames.length === 0) {
                alert('Введите хотя бы одно название подкатегории!');
                return;
            }

            // Проверяем на дубликаты
            const uniqueNames = [...new Set(subcategoryNames)];
            if (uniqueNames.length !== subcategoryNames.length) {
                if (!confirm('Обнаружены повторяющиеся названия. Продолжить?')) {
                    return;
                }
            }

            try {
                // Создаем массив подкатегорий для добавления
                const subcategories = uniqueNames.map(name => ({
                    name: name,
                    type: parentCategory.type,
                    parentId: parentId
                }));

                // Добавляем все подкатегории одним запросом
                await db.categories.bulkAdd(subcategories);

                // Показываем уведомление
                alert(`Успешно добавлено ${subcategories.length} подкатегорий!`);

                // Закрываем форму и сбрасываем
                document.getElementById('add-subcategory-form').style.display = 'none';
                document.getElementById('subcategory-form').reset();

                // Очищаем динамические поля (оставляем только первое)
                const fieldsContainer = document.getElementById('subcategory-fields');
                const firstField = fieldsContainer.querySelector('.first-field');
                fieldsContainer.innerHTML = '';
                fieldsContainer.appendChild(firstField);
                firstField.querySelector('.subcategory-name-input').value = '';

                // Обновляем страницу
                await loadCategoriesPage();

            } catch (error) {
                console.error('Ошибка добавления подкатегорий:', error);
                alert('Ошибка: ' + error.message);
            }
        }

        // Удаление категории
        async function deleteCategory(categoryId) {
            if (confirm('Удалить эту категорию? Все подкатегории и операции в этой категории будут удалены.')) {
                try {
                    // Удаляем категорию и все подкатегории
                    await db.categories.delete(parseInt(categoryId));
                    await db.categories.where('parentId').equals(parseInt(categoryId)).delete();

                    // Удаляем операции в этой категории
                    await db.transactions.where('categoryId').equals(parseInt(categoryId)).delete();

                    await loadCategoriesPage();
                    await populateCategorySelect();
                } catch (error) {
                    alert('Ошибка при удалении: ' + error.message);
                }
            }
        }

        // Обновление отчета
        async function updateReport() {
            const dateFrom = document.getElementById('report-date-from').value;
            const dateTo = document.getElementById('report-date-to').value;

            if (!dateFrom || !dateTo) {
                alert('Заполните обе даты для фильтрации');
                return;
            }

            if (dateFrom > dateTo) {
                alert('Дата "С" должна быть раньше или равна дате "По"');
                return;
            }

            // Получаем все операции за период
            const allTransactions = await db.transactions
                .where('date')
                .between(dateFrom, dateTo)
                .toArray();

            // Расчет общей статистики
            const totalIncome = allTransactions
                .filter(t => t.type === 'income')
                .reduce((sum, t) => sum + t.amount, 0);

            const totalExpense = allTransactions
                .filter(t => t.type === 'expense')
                .reduce((sum, t) => sum + t.amount, 0);

            const balance = totalIncome - totalExpense;

            // Обновляем статистику
            document.getElementById('total-income').textContent = totalIncome.toFixed(2) + ' ₽';
            document.getElementById('total-expense').textContent = totalExpense.toFixed(2) + ' ₽';
            document.getElementById('total-balance-report').textContent = balance.toFixed(2) + ' ₽';

            // Определяем тип отчета (доходы или расходы)
            const reportType = window.currentReportType || 'expense';
            document.getElementById('chart-type-label').textContent = reportType === 'expense' ? 'расходов' : 'доходов';

            // Фильтруем транзакции по типу
            const filteredTransactions = allTransactions.filter(t => t.type === reportType);

            // Группируем по категориям и подкатегориям
            const categoriesMap = new Map(); // Для категорий
            const subcategoriesMap = new Map(); // Для подкатегорий

            for (const transaction of filteredTransactions) {
                const category = await db.categories.get(transaction.categoryId);
                if (category) {
                    // Для основной категории
                    const parentCategory = category.parentId === 0
                        ? category
                        : await db.categories.get(category.parentId);

                    const categoryName = parentCategory.name;
                    if (categoriesMap.has(categoryName)) {
                        categoriesMap.set(categoryName, categoriesMap.get(categoryName) + transaction.amount);
                    } else {
                        categoriesMap.set(categoryName, transaction.amount);
                    }

                    // Для подкатегории
                    if (category.parentId !== 0) {
                        const subcategoryName = `${parentCategory.name} → ${category.name}`;
                        if (subcategoriesMap.has(subcategoryName)) {
                            subcategoriesMap.set(subcategoryName, subcategoriesMap.get(subcategoryName) + transaction.amount);
                        } else {
                            subcategoriesMap.set(subcategoryName, transaction.amount);
                        }
                    }
                }
            }

            // Создаем график
            drawExpensesPie(categoriesMap);

            // Создаем таблицу с детализацией
            createReportTable(categoriesMap, subcategoriesMap, filteredTransactions, reportType);
        }

        // Создаем график
        function createExpensesChart(categoriesMap, reportType) {
            const chartCanvas = document.getElementById('expenses-chart');
            const noDataMessage = document.getElementById('chart-no-data');
            const chartWrapper = document.querySelector('.chart-wrapper');

            if (categoriesMap.size === 0) {
                chartCanvas.style.display = 'none';
                noDataMessage.style.display = 'block';
                chartWrapper.style.height = 'auto';
                return;
            }

            chartCanvas.style.display = 'block';
            noDataMessage.style.display = 'none';

            // Фиксируем высоту контейнера графика
            chartWrapper.style.height = '300px';

            // Подготавливаем данные для графика
            const labels = Array.from(categoriesMap.keys());
            const data = Array.from(categoriesMap.values());
            const colors = generateColors(labels.length);

            // Определяем заголовок в зависимости от типа
            const chartLabel = reportType === 'expense' ? 'Расходы' : 'Доходы';

            // Если уже есть график, уничтожаем его
            if (window.expensesChart) {
                window.expensesChart.destroy();
            }

            const ctx = chartCanvas.getContext('2d');
            window.expensesChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                padding: 20,
                                usePointStyle: true,
                                pointStyle: 'circle',
                                boxWidth: 10
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    const value = context.raw;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    label += value.toFixed(2) + ' ₽ (' + percentage + '%)';
                                    return label;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartLabel,
                            font: {
                                size: 14
                            }
                        }
                    }
                }
            });
        }

        // Создаем таблицу отчета
        function createReportTable(categoriesMap, subcategoriesMap, filteredTransactions, reportType) {
            const tableContainer = document.getElementById('report-table');
            const tableWrapper = document.getElementById('report-table-wrapper');

            if (categoriesMap.size === 0) {
                tableContainer.innerHTML = '<p class="text-muted">Нет данных за выбранный период</p>';
                tableWrapper.style.height = 'auto';
                return;
            }

            // Фиксируем высоту контейнера таблицы
            tableWrapper.style.height = '300px';
            tableWrapper.style.overflowY = 'auto';

            let tableHTML = `
        <div class="report-table-content">
            <!-- Таблица категорий -->
            <table class="report-table" id="categories-table">
                <thead>
                    <tr>
                        <th>Категория</th>
                        <th>Сумма</th>
                        <th>% от ${reportType === 'expense' ? 'расходов' : 'доходов'}</th>
                    </tr>
                </thead>
                <tbody>
    `;

            // Общая сумма для расчета процентов
            const totalAmount = filteredTransactions.reduce((sum, t) => sum + t.amount, 0);

            // Сортируем по убыванию суммы
            const sortedCategories = Array.from(categoriesMap.entries())
                .sort((a, b) => b[1] - a[1]);

            for (const [category, amount] of sortedCategories) {
                const percentage = totalAmount > 0 ? ((amount / totalAmount) * 100).toFixed(1) : 0;

                tableHTML += `
            <tr>
                <td>
                    <i class="fas fa-folder"></i> ${category}
                    <button class="btn-icon-sm expand-category" data-category="${category}">
                        <i class="fas fa-chevron-down"></i>
                    </button>
                </td>
                <td>${amount.toFixed(2)} ₽</td>
                <td>${percentage}%</td>
            </tr>
        `;

                // Добавляем подкатегории для этой категории
                const subcategoriesForCategory = Array.from(subcategoriesMap.entries())
                    .filter(([name]) => name.startsWith(category + ' →'))
                    .sort((a, b) => b[1] - a[1]);

                for (const [subcategoryName, subAmount] of subcategoriesForCategory) {
                    const subPercentage = totalAmount > 0 ? ((subAmount / totalAmount) * 100).toFixed(1) : 0;

                    tableHTML += `
                <tr class="subcategory-row" data-parent="${category}" style="display: none;">
                    <td style="padding-left: 40px;">
                        <i class="fas fa-folder-open"></i> ${subcategoryName.split(' → ')[1]}
                    </td>
                    <td>${subAmount.toFixed(2)} ₽</td>
                    <td>${subPercentage}%</td>
                </tr>
            `;
                }
            }

            tableHTML += `
                </tbody>
            </table>
            
            <!-- Таблица подкатегорий (скрыта по умолчанию) -->
            <table class="report-table" id="subcategories-table" style="display: none;">
                <thead>
                    <tr>
                        <th>Подкатегория</th>
                        <th>Категория</th>
                        <th>Сумма</th>
                        <th>% от ${reportType === 'expense' ? 'расходов' : 'доходов'}</th>
                    </tr>
                </thead>
                <tbody>
    `;

            // Сортируем подкатегории по убыванию суммы
            const sortedSubcategories = Array.from(subcategoriesMap.entries())
                .sort((a, b) => b[1] - a[1]);

            for (const [subcategoryName, amount] of sortedSubcategories) {
                const [category, subcategory] = subcategoryName.split(' → ');
                const percentage = totalAmount > 0 ? ((amount / totalAmount) * 100).toFixed(1) : 0;

                tableHTML += `
            <tr>
                <td><i class="fas fa-folder-open"></i> ${subcategory}</td>
                <td>${category}</td>
                <td>${amount.toFixed(2)} ₽</td>
                <td>${percentage}%</td>
            </tr>
        `;
            }

            tableHTML += `
                </tbody>
            </table>
        </div>
    `;

            tableContainer.innerHTML = tableHTML;

            // Добавляем обработчики для переключения таблиц
            const showCategoriesBtn = document.getElementById('show-categories-btn');
            const showSubcategoriesBtn = document.getElementById('show-subcategories-btn');

            if (showCategoriesBtn && showSubcategoriesBtn) {
                showCategoriesBtn.addEventListener('click', () => {
                    document.getElementById('categories-table').style.display = 'table';
                    document.getElementById('subcategories-table').style.display = 'none';
                    showCategoriesBtn.classList.add('active');
                    showSubcategoriesBtn.classList.remove('active');
                });

                showSubcategoriesBtn.addEventListener('click', () => {
                    document.getElementById('categories-table').style.display = 'none';
                    document.getElementById('subcategories-table').style.display = 'table';
                    showCategoriesBtn.classList.remove('active');
                    showSubcategoriesBtn.classList.add('active');
                });
            }

            // Обработчики для раскрытия/скрытия подкатегорий
            document.querySelectorAll('.expand-category').forEach(btn => {
                btn.addEventListener('click', function () {
                    const category = this.dataset.category;
                    const rows = document.querySelectorAll(`.subcategory-row[data-parent="${category}"]`);
                    const icon = this.querySelector('i');

                    if (rows[0].style.display === 'none') {
                        rows.forEach(row => row.style.display = 'table-row');
                        icon.className = 'fas fa-chevron-up';
                    } else {
                        rows.forEach(row => row.style.display = 'none');
                        icon.className = 'fas fa-chevron-down';
                    }
                });
            });
        }

        // Генератор цветов для графика
        function generateColors(count) {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384',
                '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
            ];

            return colors.slice(0, count);
        }

        // Генератор случайного цвета
        function getRandomColor() {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#27ae60',
                '#3498db', '#e74c3c', '#9b59b6', '#f39c12', '#1abc9c'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        // Добавляем дополнительные стили
        const additionalCSS = `
/* Стили для страницы счетов */
.accounts-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.add-account-form {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    border-left: 4px solid #4a6fa5;
}

.form-buttons {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.btn-secondary {
    background-color: #6c757d;
    color: white;
}

.btn-secondary:hover {
    background-color: #5a6268;
}

.accounts-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.account-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background-color: #f8f9fa;
    border-radius: 8px;
    border-left: 4px solid #4a6fa5;
}

.account-info {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.account-name {
    font-weight: 600;
    color: #2c3e50;
    display: flex;
    align-items: center;
    gap: 10px;
}

.account-balance {
    font-size: 1.2rem;
    font-weight: bold;
    color: #27ae60;
}

.account-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-icon {
    background: none;
    border: none;
    color: #7f8c8d;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0.5rem;
    border-radius: 4px;
    transition: all 0.3s;
}

.btn-icon:hover {
    background-color: #e0e0e0;
    color: #333;
}

/* Стили для страницы категорий */
.categories-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.category-forms {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.add-category-form {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
}

.categories-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.category-item {
    padding: 1rem;
    background-color: #f8f9fa;
    border-radius: 8px;
}

.category-item.main-category {
    border-left: 4px solid #3498db;
}

.category-item.subcategory {
    border-left: 4px solid #2ecc71;
    margin-left: 2rem;
}

.category-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.category-type-badge {
    padding: 0.2rem 0.5rem;
    border-radius: 12px;
    font-size: 0.8rem;
    margin-left: 0.5rem;
}

.category-type-badge.income {
    background-color: #d5f4e6;
    color: #27ae60;
}

.category-type-badge.expense {
    background-color: #fadbd8;
    color: #e74c3c;
}

.subcategories-list {
    margin-top: 0.5rem;
    padding-left: 1rem;
    border-left: 2px dashed #bdc3c7;
}

/* Стили для страницы лимитов */
.limits-container {
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.planned-income-card {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
    border-left: 4px solid #f39c12;
}

.limits-setup {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
    border-left: 4px solid #9b59b6;
}

.limits-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin: 1.5rem 0;
}

.limit-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    background-color: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
}

.limit-info {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.limit-category {
    font-weight: 600;
    color: #2c3e50;
}

.limit-details {
    display: flex;
    gap: 1rem;
    color: #7f8c8d;
}

.limit-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.limit-slider {
    width: 200px;
}

.slider-value {
    min-width: 50px;
    text-align: center;
    font-weight: bold;
    color: #3498db;
}

.total-limits-info {
    display: flex;
    justify-content: space-between;
    margin: 1.5rem 0;
    padding: 1rem;
    background-color: #e8f4fc;
    border-radius: 8px;
}

.total-percentage, .remaining-percentage {
    font-size: 1.1rem;
    font-weight: 600;
}

#total-percentage {
    color: #e74c3c;
}

#remaining-percentage {
    color: #27ae60;
}

/* Стили для обновленной страницы лимитов */
.limits-header-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}

.input-with-button {
    display: flex;
    gap: 1rem;
    align-items: center;
}

.input-with-button .form-control {
    flex: 1;
}

.add-limit-form {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    border-left: 4px solid #3498db;
}

.add-limit-form h5 {
    margin-bottom: 1rem;
    color: #2c3e50;
}

.limit-header {
    margin-bottom: 1rem;
}

.limit-category-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.limit-category-name {
    font-size: 1.2rem;
    font-weight: 600;
    color: #2c3e50;
}

.limit-category-actions {
    display: flex;
    gap: 0.5rem;
}

.limit-details {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
}

.limit-setting {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.limit-input-group {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.limit-input-group label {
    font-weight: 600;
    color: #34495e;
    white-space: nowrap;
}

.limit-input-with-button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.limit-input-with-button .form-control-sm {
    width: 80px;
    padding: 0.5rem;
    font-size: 1rem;
    text-align: center;
}

.limit-percentage-suffix {
    font-weight: 600;
    color: #7f8c8d;
}

.limit-amount {
    font-size: 1.3rem;
    font-weight: bold;
    color: #2c3e50;
    background-color: #f8f9fa;
    padding: 0.5rem 1rem;
    border-radius: 6px;
}

.limit-progress {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 8px;
}

.progress-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.spent-amount {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.spent-label {
    color: #7f8c8d;
    font-size: 0.9rem;
}

.spent-value {
    font-weight: 600;
    color: #2c3e50;
}

.progress-percentage {
    font-size: 1.2rem;
    font-weight: bold;
    color: #2c3e50;
}

.progress-bar-container {
    width: 100%;
    height: 20px;
    background-color: #ecf0f1;
    border-radius: 10px;
    overflow: hidden;
    margin: 0.5rem 0;
}

.progress-bar {
    height: 100%;
    border-radius: 10px;
    transition: width 0.5s ease, background-color 0.3s ease;
}

.overspend-warning {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: #e74c3c;
    font-weight: 600;
    background-color: rgba(231, 76, 60, 0.1);
    padding: 0.5rem;
    border-radius: 4px;
    margin-top: 0.5rem;
}

/* Стили для страницы сводки */
.report-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 2rem;
}

.date-filters {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
}

.report-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.stat-card {
    background-color: white;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    gap: 1rem;
}

.stat-card.income {
    border-left: 4px solid #27ae60;
}

.stat-card.expense {
    border-left: 4px solid #e74c3c;
}

.stat-card.balance {
    border-left: 4px solid #3498db;
}

.stat-icon {
    font-size: 2rem;
    color: white;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.stat-card.income .stat-icon {
    background-color: #27ae60;
}

.stat-card.expense .stat-icon {
    background-color: #e74c3c;
}

.stat-card.balance .stat-icon {
    background-color: #3498db;
}

.stat-label {
    color: #7f8c8d;
    font-size: 0.9rem;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: #2c3e50;
}

.report-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

.chart-container, .report-table-container {
    background-color: white;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#expenses-chart {
    width: 100%;
    height: 300px;
}

.report-table {
    width: 100%;
    border-collapse: collapse;
}

.report-table th, .report-table td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #e0e0e0;
}

.report-table th {
    background-color: #f8f9fa;
    font-weight: 600;
    color: #2c3e50;
}

.report-table tr:hover {
    background-color: #f5f5f5;
}

/* Стили для кнопок действий в транзакциях */
.transaction-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
    justify-content: flex-end;
}

/* Стили для управления таблицами в отчете */
.table-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.btn-outline {
    background-color: transparent;
    border: 1px solid #3498db;
    color: #3498db;
}

.btn-outline:hover {
    background-color: #3498db;
    color: white;
}

.btn-outline.active {
    background-color: #3498db;
    color: white;
}

.report-table-content {
    overflow-x: auto;
}

.subcategory-row {
    background-color: #fafafa;
}

.btn-icon-sm {
    background: none;
    border: none;
    color: #7f8c8d;
    cursor: pointer;
    font-size: 0.9rem;
    padding: 0.2rem;
    margin-left: 0.5rem;
}

.btn-icon-sm:hover {
    color: #3498db;
}

/* Стили для формы с подкатегориями */
#subcategory-group {
    margin-top: -0.5rem;
    transition: all 0.3s ease;
}

/* Модальное окно для редактирования счета */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background-color: white;
    border-radius: 12px;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem;
    border-bottom: 1px solid #ecf0f1;
}

.modal-header h3 {
    margin: 0;
    color: #2c3e50;
    display: flex;
    align-items: center;
    gap: 10px;
}

.modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    color: #7f8c8d;
    transition: color 0.3s;
}

.modal-close:hover {
    color: #e74c3c;
}

.modal-body {
    padding: 1.5rem;
}

.modal-buttons {
    display: flex;
    gap: 1rem;
    margin-top: 1.5rem;
}

.modal-buttons .btn {
    flex: 1;
}

/* Адаптивность */
@media (max-width: 768px) {
    .report-content {
        grid-template-columns: 1fr;
    }
    
    .report-header {
        flex-direction: column;
        align-items: stretch;
    }
    
    .date-filters {
        flex-direction: column;
        align-items: stretch;
    }
    
    .category-forms {
        flex-direction: column;
    }
    
    .limits-header-row {
        flex-direction: column;
        align-items: stretch;
        gap: 1rem;
    }
    
    .limit-setting {
        flex-direction: column;
        align-items: stretch;
    }
    
    .limit-input-group {
        flex-direction: column;
        align-items: stretch;
    }
    
    .limit-input-with-button {
        justify-content: center;
    }
    
    .modal-content {
        width: 95%;
        margin: 1rem;
    }
}
`;

        // Добавляем дополнительные стили в head документа
        const styleElement = document.createElement('style');
        styleElement.textContent = additionalCSS;
        document.head.appendChild(styleElement);
        // ========== КОНЕЦ app.js ==========
    </script>
</body>

</html>